<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SystemExtensions</name>
    </assembly>
    <members>
        <member name="T:System.ArrayExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.Array"/>, especially for one-dimensional array.
            </summary>
            <seealso cref="T:System.Array"/>
        </member>
        <member name="T:System.ArrayExtensions.">
            <summary>
            Provides extension members on <see cref="T:System.Array"/>.
            </summary>
        </member>
        <member name="M:System.ArrayExtensions..InitializeArray``1(``0[],System.ArrayInitializer{``0})">
            <summary>
            Initializes an array, using the specified method to initialize each element.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="array">The array.</param>
            <param name="initializer">The initializer callback method.</param>
        </member>
        <member name="M:System.ArrayExtensions..Flat``1(``0[0:,0:])">
            <summary>
            Flats the specified 2D array into an 1D array.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="array">An array of elements of type <typeparamref name="T"/>.</param>
            <returns>An 1D array.</returns>
        </member>
        <member name="M:System.ArrayExtensions..ToArrayString``1(``0[])">
            <summary>
            Converts an array into a <see cref="T:System.String"/>.
            </summary>
            <typeparam name="T">The type of each element inside array.</typeparam>
            <param name="array">The array.</param>
            <returns>The string representation.</returns>
        </member>
        <member name="M:System.ArrayExtensions..ToArrayString``1(``0[],System.Func{``0,System.String})">
            <summary>
            Converts an array into a <see cref="T:System.String"/>, using the specified formatter method
            that can convert an instance of type <typeparamref name="T"/> into a <see cref="T:System.String"/> representation.
            </summary>
            <typeparam name="T">The type of each element inside array.</typeparam>
            <param name="array">The array.</param>
            <param name="valueConverter">The value converter method.</param>
            <returns>The string representation.</returns>
        </member>
        <member name="M:System.ArrayExtensions..ToArrayString``1(``0[][])">
            <inheritdoc cref="M:System.ArrayExtensions.ToArrayString``1(``0[])"/>
        </member>
        <member name="M:System.ArrayExtensions..ToArrayString``1(``0[][],System.Func{``0,System.String})">
            <inheritdoc cref="M:System.ArrayExtensions.ToArrayString``1(``0[],System.Func{``0,System.String})"/>
        </member>
        <member name="M:System.ArrayExtensions..ToArrayString``1(``0[0:,0:])">
            <inheritdoc cref="M:System.ArrayExtensions.ToArrayString``1(``0[])"/>
        </member>
        <member name="M:System.ArrayExtensions..ToArrayString``1(``0[0:,0:],System.Func{``0,System.String})">
            <inheritdoc cref="M:System.ArrayExtensions.ToArrayString``1(``0[],System.Func{``0,System.String})"/>
        </member>
        <member name="M:System.ArrayExtensions..AsSpanUnsafe``1(``0[0:,0:])">
            <summary>
            Returns the one-dimensional array representation from the two-dimensional array.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="array">The array.</param>
            <returns>The <see cref="T:System.Span`1"/> casted.</returns>
        </member>
        <member name="M:System.ArrayExtensions..AsSpanUnsafe``1(``0[0:,0:,0:])">
            <summary>
            Returns the one-dimensional array representation from the three-dimensional array.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="array">The array.</param>
            <returns>The <see cref="T:System.Span`1"/> casted.</returns>
        </member>
        <member name="M:System.ArrayExtensions..AsSpanUnsafe``1(System.Array)">
            <summary>
            Reinterpret the specified multiple dimensional array into a <see cref="T:System.Span`1"/> instance.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="array">The multiple dimensional array to be reinterpreted.</param>
            <returns>A <see cref="T:System.Span`1"/> instance.</returns>
        </member>
        <member name="T:System.ArrayInitializer`1">
            <summary>
            Represents a method that initializes for an element of type <typeparamref name="T"/>?,
            and be <typeparamref name="T"/> after the method invoked.
            </summary>
            <typeparam name="T">The type of the element.</typeparam>
            <param name="value">The value to be initialized.</param>
        </member>
        <member name="T:System.Buffers.ReadOnlyMemoryOfCharComparer">
            <summary>
            Represents an equality comparer of <see cref="T:System.ReadOnlySpan`1"/> of <see cref="T:System.Char"/> object,
            but it can also be created by comparing <see cref="T:System.String"/> values as an efficient way in variant collection types
            like <see cref="T:System.Collections.Generic.HashSet`1.AlternateLookup`1"/>.
            </summary>
            <seealso cref="T:System.Collections.Generic.HashSet`1.AlternateLookup`1"/>
        </member>
        <member name="F:System.Buffers.ReadOnlyMemoryOfCharComparer.Instance">
            <summary>
            Indicates the singleton object of this type.
            </summary>
        </member>
        <member name="M:System.Buffers.ReadOnlyMemoryOfCharComparer.#ctor">
            <summary>
            Initializes a <see cref="T:System.Buffers.ReadOnlyMemoryOfCharComparer"/> instance.
            </summary>
        </member>
        <member name="M:System.Buffers.ReadOnlyMemoryOfCharComparer.Equals(System.ReadOnlyMemory{System.Char},System.ReadOnlyMemory{System.Char})">
            <inheritdoc/>
        </member>
        <member name="M:System.Buffers.ReadOnlyMemoryOfCharComparer.Equals(System.ReadOnlySpan{System.Char},System.ReadOnlyMemory{System.Char})">
            <inheritdoc/>
        </member>
        <member name="M:System.Buffers.ReadOnlyMemoryOfCharComparer.GetHashCode(System.ReadOnlyMemory{System.Char})">
            <inheritdoc/>
        </member>
        <member name="M:System.Buffers.ReadOnlyMemoryOfCharComparer.GetHashCode(System.ReadOnlySpan{System.Char})">
            <inheritdoc/>
        </member>
        <member name="M:System.Buffers.ReadOnlyMemoryOfCharComparer.Create(System.ReadOnlySpan{System.Char})">
            <inheritdoc/>
        </member>
        <member name="T:System.Buffers.SingletonArray`1">
            <summary>
            Represents an array with only one element.
            </summary>
            <typeparam name="T">The type of the only element of array.</typeparam>
            <param name="value">Indicates the value.</param>
        </member>
        <member name="M:System.Buffers.SingletonArray`1.#ctor(`0)">
            <summary>
            Represents an array with only one element.
            </summary>
            <typeparam name="T">The type of the only element of array.</typeparam>
            <param name="value">Indicates the value.</param>
        </member>
        <member name="P:System.Buffers.SingletonArray`1.Pointer">
            <summary>
            Indicates the pointer of the value.
            </summary>
        </member>
        <member name="M:System.Buffers.SingletonArray`1.Unpin">
            <inheritdoc/>
        </member>
        <member name="M:System.Buffers.SingletonArray`1.ToString">
            <inheritdoc/>
        </member>
        <member name="M:System.Buffers.SingletonArray`1.GetSpan">
            <inheritdoc/>
        </member>
        <member name="M:System.Buffers.SingletonArray`1.Pin(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:System.Buffers.SingletonArray`1.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:System.Buffers.SingletonArray`1.op_Implicit(System.Buffers.SingletonArray{`0})~System.Span{`0}">
            <summary>
            Creates a <see cref="T:System.Span`1"/> from the current instance without any copy operation.
            </summary>
            <param name="value">The value to be casted from.</param>
        </member>
        <member name="M:System.Buffers.SingletonArray`1.op_Implicit(System.Buffers.SingletonArray{`0})~System.ReadOnlySpan{`0}">
            <summary>
            Creates a <see cref="T:System.ReadOnlySpan`1"/> from the current instance without any copy operation.
            </summary>
            <param name="value">The value to be casted from.</param>
        </member>
        <member name="M:System.Buffers.SingletonArray`1.op_Implicit(System.Buffers.SingletonArray{`0})~System.Memory{`0}">
            <summary>
            Creates a <see cref="T:System.Memory`1"/> from the current instance without any copy operation.
            </summary>
            <param name="value">The value to be casted from.</param>
        </member>
        <member name="M:System.Buffers.SingletonArray`1.op_Implicit(System.Buffers.SingletonArray{`0})~System.ReadOnlyMemory{`0}">
            <summary>
            Creates a <see cref="T:System.ReadOnlyMemory`1"/> from the current instance without any copy operation.
            </summary>
            <param name="value">The value to be casted from.</param>
        </member>
        <member name="F:System.Buffers.SingletonArray`1._value">
            <summary>
            The generated field declaration for parameter <c>value</c>.
            </summary>
        </member>
        <member name="T:System.Collections.BitArrayConverter">
            <summary>
            Provides with a converter that can convert the object <see cref="T:System.Collections.BitArray"/> into an array of commonly-used binary integer types.
            </summary>
        </member>
        <member name="M:System.Collections.BitArrayConverter.ToBooleanArray(System.Collections.BitArray)">
            <summary>
            Converts the specified <see cref="T:System.Collections.BitArray"/> instance into a <see cref="T:System.Boolean"/>[] instance.
            </summary>
            <param name="bits">The bits.</param>
            <returns>A <see cref="T:System.Boolean"/>[] instance.</returns>
        </member>
        <member name="M:System.Collections.BitArrayConverter.ToByteArray(System.Collections.BitArray)">
            <summary>
            Converts the specified <see cref="T:System.Collections.BitArray"/> instance into a <see cref="T:System.Byte"/>[] instance.
            </summary>
            <param name="bits">The bits.</param>
            <returns>A <see cref="T:System.Byte"/>[] instance.</returns>
        </member>
        <member name="M:System.Collections.BitArrayConverter.ToSByteArray(System.Collections.BitArray)">
            <summary>
            Converts the specified <see cref="T:System.Collections.BitArray"/> instance into an <see cref="T:System.SByte"/>[] instance.
            </summary>
            <param name="bits">The bits.</param>
            <returns>An <see cref="T:System.SByte"/>[] instance.</returns>
        </member>
        <member name="M:System.Collections.BitArrayConverter.ToUInt16Array(System.Collections.BitArray)">
            <summary>
            Converts the specified <see cref="T:System.Collections.BitArray"/> instance into a <see cref="T:System.UInt16"/>[] instance.
            </summary>
            <param name="bits">The bits.</param>
            <returns>A <see cref="T:System.UInt16"/>[] instance.</returns>
        </member>
        <member name="M:System.Collections.BitArrayConverter.ToInt16Array(System.Collections.BitArray)">
            <summary>
            Converts the specified <see cref="T:System.Collections.BitArray"/> instance into a <see cref="T:System.Int16"/>[] instance.
            </summary>
            <param name="bits">The bits.</param>
            <returns>A <see cref="T:System.Int16"/>[] instance.</returns>
        </member>
        <member name="M:System.Collections.BitArrayConverter.ToUInt32Array(System.Collections.BitArray)">
            <summary>
            Converts the specified <see cref="T:System.Collections.BitArray"/> instance into a <see cref="T:System.UInt32"/>[] instance.
            </summary>
            <param name="bits">The bits.</param>
            <returns>A <see cref="T:System.UInt32"/>[] instance.</returns>
        </member>
        <member name="M:System.Collections.BitArrayConverter.ToInt32Array(System.Collections.BitArray)">
            <summary>
            Converts the specified <see cref="T:System.Collections.BitArray"/> instance into an <see cref="T:System.Int32"/>[] instance.
            </summary>
            <param name="bits">The bits.</param>
            <returns>An <see cref="T:System.Int32"/>[] instance.</returns>
        </member>
        <member name="M:System.Collections.BitArrayConverter.ToUInt64Array(System.Collections.BitArray)">
            <summary>
            Converts the specified <see cref="T:System.Collections.BitArray"/> instance into a <see cref="T:System.UInt64"/>[] instance.
            </summary>
            <param name="bits">The bits.</param>
            <returns>A <see cref="T:System.UInt64"/>[] instance.</returns>
        </member>
        <member name="M:System.Collections.BitArrayConverter.ToInt64Array(System.Collections.BitArray)">
            <summary>
            Converts the specified <see cref="T:System.Collections.BitArray"/> instance into a <see cref="T:System.Int64"/>[] instance.
            </summary>
            <param name="bits">The bits.</param>
            <returns>A <see cref="T:System.Int64"/>[] instance.</returns>
        </member>
        <member name="M:System.Collections.BitArrayConverter.ToUInt128Array(System.Collections.BitArray)">
            <summary>
            Converts the specified <see cref="T:System.Collections.BitArray"/> instance into a <see cref="T:System.UInt128"/>[] instance.
            </summary>
            <param name="bits">The bits.</param>
            <returns>A <see cref="T:System.UInt128"/>[] instance.</returns>
        </member>
        <member name="M:System.Collections.BitArrayConverter.ToInt128Array(System.Collections.BitArray)">
            <summary>
            Converts the specified <see cref="T:System.Collections.BitArray"/> instance into an <see cref="T:System.Int128"/>[] instance.
            </summary>
            <param name="bits">The bits.</param>
            <returns>An <see cref="T:System.Int128"/>[] instance.</returns>
        </member>
        <member name="M:System.Collections.BitArrayConverter.ToNUIntArray(System.Collections.BitArray)">
            <summary>
            Converts the specified <see cref="T:System.Collections.BitArray"/> instance into an <see cref="T:System.UIntPtr"/>[] instance.
            </summary>
            <param name="bits">The bits.</param>
            <returns>An <see cref="T:System.UIntPtr"/>[] instance.</returns>
        </member>
        <member name="M:System.Collections.BitArrayConverter.ToNIntArray(System.Collections.BitArray)">
            <summary>
            Converts the specified <see cref="T:System.Collections.BitArray"/> instance into an <see cref="T:System.IntPtr"/>[] instance.
            </summary>
            <param name="bits">The bits.</param>
            <returns>An <see cref="T:System.IntPtr"/>[] instance.</returns>
        </member>
        <member name="M:System.Collections.BitArrayConverter.ToArray``1(System.Collections.BitArray)">
            <summary>
            Converts the specified <see cref="T:System.Collections.BitArray"/> instance
            into a <see cref="T:System.ReadOnlySpan`1"/> of <typeparamref name="T"/> instance.
            </summary>
            <typeparam name="T">The type of the binary integer to be converted.</typeparam>
            <param name="bits">The bits.</param>
            <returns>A <see cref="T:System.ReadOnlySpan`1"/> of <typeparamref name="T"/> instance.</returns>
            <exception cref="T:System.OverflowException">
            Throws when create an overflowed <see cref="T:System.Int32"/> value as an index from <typeparamref name="T"/>.
            </exception>
            <exception cref="T:System.NotSupportedException">
            Throws when type <typeparamref name="T"/> is not compatible with <see cref="T:System.Int32"/>.
            </exception>
        </member>
        <member name="M:System.Collections.BitArrayConverter.FromBooleanArray(System.Boolean[])">
            <summary>
            Convert the specified <see cref="T:System.Boolean"/>[] into a <see cref="T:System.Collections.BitArray"/> instance.
            </summary>
            <param name="array">A <see cref="T:System.Boolean"/>[] instance.</param>
            <returns>A <see cref="T:System.Collections.BitArray"/> instance converted.</returns>
        </member>
        <member name="M:System.Collections.BitArrayConverter.FromByteArray(System.Byte[])">
            <summary>
            Convert the specified <see cref="T:System.Byte"/>[] into a <see cref="T:System.Collections.BitArray"/> instance.
            </summary>
            <param name="array">A <see cref="T:System.Byte"/>[] instance.</param>
            <returns>A <see cref="T:System.Collections.BitArray"/> instance converted.</returns>
        </member>
        <member name="M:System.Collections.BitArrayConverter.FromSByteArray(System.SByte[])">
            <summary>
            Convert the specified <see cref="T:System.SByte"/>[] into a <see cref="T:System.Collections.BitArray"/> instance.
            </summary>
            <param name="array">An <see cref="T:System.SByte"/>[] instance.</param>
            <returns>A <see cref="T:System.Collections.BitArray"/> instance converted.</returns>
        </member>
        <member name="M:System.Collections.BitArrayConverter.FromUInt16Array(System.UInt16[])">
            <summary>
            Convert the specified <see cref="T:System.UInt16"/>[] into a <see cref="T:System.Collections.BitArray"/> instance.
            </summary>
            <param name="array">A <see cref="T:System.UInt16"/>[] instance.</param>
            <returns>A <see cref="T:System.Collections.BitArray"/> instance converted.</returns>
        </member>
        <member name="M:System.Collections.BitArrayConverter.FromInt16Array(System.Int16[])">
            <summary>
            Convert the specified <see cref="T:System.Int16"/>[] into a <see cref="T:System.Collections.BitArray"/> instance.
            </summary>
            <param name="array">A <see cref="T:System.Int16"/>[] instance.</param>
            <returns>A <see cref="T:System.Collections.BitArray"/> instance converted.</returns>
        </member>
        <member name="M:System.Collections.BitArrayConverter.FromUInt32Array(System.UInt32[])">
            <summary>
            Convert the specified <see cref="T:System.UInt32"/>[] into a <see cref="T:System.Collections.BitArray"/> instance.
            </summary>
            <param name="array">An <see cref="T:System.UInt32"/>[] instance.</param>
            <returns>A <see cref="T:System.Collections.BitArray"/> instance converted.</returns>
        </member>
        <member name="M:System.Collections.BitArrayConverter.FromInt32Array(System.Int32[])">
            <summary>
            Convert the specified <see cref="T:System.Int32"/>[] into a <see cref="T:System.Collections.BitArray"/> instance.
            </summary>
            <param name="array">An <see cref="T:System.Int32"/>[] instance.</param>
            <returns>A <see cref="T:System.Collections.BitArray"/> instance converted.</returns>
        </member>
        <member name="M:System.Collections.BitArrayConverter.FromUInt64Array(System.UInt64[])">
            <summary>
            Convert the specified <see cref="T:System.UInt64"/>[] into a <see cref="T:System.Collections.BitArray"/> instance.
            </summary>
            <param name="array">A <see cref="T:System.UInt64"/>[] instance.</param>
            <returns>A <see cref="T:System.Collections.BitArray"/> instance converted.</returns>
        </member>
        <member name="M:System.Collections.BitArrayConverter.FromInt64Array(System.Int64[])">
            <summary>
            Convert the specified <see cref="T:System.Int64"/>[] into a <see cref="T:System.Collections.BitArray"/> instance.
            </summary>
            <param name="array">A <see cref="T:System.Int64"/>[] instance.</param>
            <returns>A <see cref="T:System.Collections.BitArray"/> instance converted.</returns>
        </member>
        <member name="M:System.Collections.BitArrayConverter.FromUInt128Array(System.UInt128[])">
            <summary>
            Convert the specified <see cref="T:System.UInt128"/>[] into a <see cref="T:System.Collections.BitArray"/> instance.
            </summary>
            <param name="array">A <see cref="T:System.UInt128"/>[] instance.</param>
            <returns>A <see cref="T:System.Collections.BitArray"/> instance converted.</returns>
        </member>
        <member name="M:System.Collections.BitArrayConverter.FromInt128Array(System.Int128[])">
            <summary>
            Convert the specified <see cref="T:System.Int128"/>[] into a <see cref="T:System.Collections.BitArray"/> instance.
            </summary>
            <param name="array">An <see cref="T:System.Int128"/>[] instance.</param>
            <returns>A <see cref="T:System.Collections.BitArray"/> instance converted.</returns>
        </member>
        <member name="M:System.Collections.BitArrayConverter.FromNUIntArray(System.UIntPtr[])">
            <summary>
            Convert the specified <see cref="T:System.UIntPtr"/>[] into a <see cref="T:System.Collections.BitArray"/> instance.
            </summary>
            <param name="array">An <see cref="T:System.UIntPtr"/>[] instance.</param>
            <returns>A <see cref="T:System.Collections.BitArray"/> instance converted.</returns>
        </member>
        <member name="M:System.Collections.BitArrayConverter.FromNIntArray(System.IntPtr[])">
            <summary>
            Convert the specified <see cref="T:System.IntPtr"/>[] into a <see cref="T:System.Collections.BitArray"/> instance.
            </summary>
            <param name="array">An <see cref="T:System.IntPtr"/>[] instance.</param>
            <returns>A <see cref="T:System.Collections.BitArray"/> instance converted.</returns>
        </member>
        <member name="M:System.Collections.BitArrayConverter.FromArray``1(``0[])">
            <summary>
            Convert the specified <typeparamref name="T"/>[] into a <see cref="T:System.Collections.BitArray"/> instance.
            </summary>
            <typeparam name="T">The type of binary integer.</typeparam>
            <param name="array">An instance of type <typeparamref name="T"/>[].</param>
            <returns>A <see cref="T:System.Collections.BitArray"/> instance converted.</returns>
            <exception cref="T:System.OverflowException">
            Throws when overflow on casting from <typeparamref name="T"/> to <see cref="T:System.Int32"/>.
            </exception>
        </member>
        <member name="T:System.Collections.BitArrayExtensions">
            <summary>
            Provides extension methods on <see cref="T:System.Collections.BitArray"/>.
            </summary>
            <seealso cref="T:System.Collections.BitArray"/>
        </member>
        <member name="T:System.Collections.BitArrayExtensions.">
            <summary>
            Provides extension members on <see cref="T:System.Collections.BitArray"/>.
            </summary>
        </member>
        <member name="P:System.Collections.BitArrayExtensions..Cardinality">
            <summary>
            Get the cardinality of the specified <see cref="T:System.Collections.BitArray"/>,
            indicating the total number of bits set <see langword="true"/>.
            </summary>
        </member>
        <member name="M:System.Collections.BitArrayExtensions..SequenceEqual(System.Collections.BitArray)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:System.Collections.BitArrayExtensions..GetInternalArrayField">
            <summary>
            Try to get internal array field.
            </summary>
            <returns>The field.</returns>
        </member>
        <member name="M:System.Collections.BitArrayExtensions..Slice(System.Int32,System.Int32)">
            <summary>
            Slices the current <see cref="T:System.Collections.BitArray"/> instance.
            </summary>
            <param name="start">The start index.</param>
            <param name="count">The number.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:System.Collections.BitArrayExtensions..Slice(System.Int32)">
            <summary>
            Slices the current <see cref="T:System.Collections.BitArray"/> instance.
            </summary>
            <param name="start">The start index.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:System.Collections.BitArrayExtensions..AlignedOr(System.Collections.BitArray)">
            <summary>
            Performs bitwise-or operation with the other instance at the start position, without equivalent length of the other object.
            </summary>
            <param name="other">The other object.</param>
            <returns>The current instance.</returns>
        </member>
        <member name="T:System.Collections.Entry">
            <summary>
            Represents an entry to call internal fields on <see cref="T:System.Collections.BitArray"/>.
            </summary>
            <seealso cref="T:System.Collections.BitArray"/>
        </member>
        <member name="M:System.Collections.Entry.GetArrayField(System.Collections.BitArray)">
            <summary>
            Try to fetch the internal field <c>m_array</c> in type <see cref="T:System.Collections.BitArray" />.
            </summary>
            <param name="this">The list.</param>
            <returns>The reference to the internal field.</returns>
            <remarks>
            <target name="others">
					<para>
						This method is implemented via <see cref="T:System.Runtime.CompilerServices.UnsafeAccessorAttribute" />,
						which is just like inserting .NET implementation into the current project directly.
					</para>
				</target>
            <target name="field-related-method">
					<para>
						<b>
							Please note that this method will return the reference to the internal field,
							but this doesn't mean you can use its reference and re-assign it.
							You cannot assign a value to the field if the ref kind of a field in fact is <see langword="ref readonly" />;
							it will raise an exception to report this wrong usage.
						</b>
					</para>
				</target>
            </remarks>
        </member>
        <member name="T:System.Collections.Generic.DictionaryExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.Collections.Generic.Dictionary`2"/>.
            </summary>
            <seealso cref="T:System.Collections.Generic.Dictionary`2"/>
        </member>
        <member name="T:System.Collections.Generic.DictionaryExtensions.`2">
            <summary>
            Provides extension members on <see cref="T:System.Collections.Generic.Dictionary`2"/>,
            where <typeparamref name="TKey"/> satisfies <see langword="notnull"/> constraint.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.DictionaryExtensions.`2.GetValueRef(`0@)">
            <summary>
            Try to get the reference to the value whose corresponding key is specified one.
            </summary>
            <param name="key">The key to be checked.</param>
            <returns>The reference to the value; or a <see langword="null"/> reference if the key is not found.</returns>
        </member>
        <member name="M:System.Collections.Generic.DictionaryExtensions.`2.ToDictionaryString">
            <inheritdoc cref="M:System.Collections.Generic.DictionaryExtensions.ToDictionaryString``2(System.Collections.Generic.Dictionary{``0,``1},System.Func{``0,System.String},System.Func{``1,System.String})"/>
        </member>
        <member name="M:System.Collections.Generic.DictionaryExtensions.`2.ToDictionaryString(System.Func{`0,System.String},System.Func{`1,System.String})">
            <summary>
            Converts the current <see cref="T:System.Collections.Generic.Dictionary`2"/> instance into string representation.
            </summary>
            <param name="keyConverter">
            The key converter that converts <typeparamref name="TKey"/> instance into <see cref="T:System.String"/> representation.
            </param>
            <param name="valueConverter">
            The key converter that converts <typeparamref name="TValue"/> instance into <see cref="T:System.String"/> representation.
            </param>
            <returns>The <see cref="T:System.String"/> representation.</returns>
        </member>
        <member name="T:System.Collections.Generic.DictionaryExtensions.`2">
            <summary>
            Provides extension members on <see cref="T:System.Collections.Generic.Dictionary`2"/>, where:<br/>
            <typeparamref name="TKey"/> satisfies <see langword="notnull"/> constraint, <br/>
            <typeparamref name="TValue"/> satisfies <see cref="T:System.IEquatable`1"/> constraint.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.DictionaryExtensions.`2.GetKey(`1)">
            <summary>
            Try to fetch the key whose cooresponding value is the specified one.
            </summary>
            <param name="value">The value to look up.</param>
            <returns>The key.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when the dictionary has no valid value.</exception>
        </member>
        <member name="T:System.Collections.Generic.HashSetExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.Collections.Generic.HashSet`1"/>.
            </summary>
            <seealso cref="T:System.Collections.Generic.HashSet`1"/>
        </member>
        <member name="T:System.Collections.Generic.HashSetExtensions.`1">
            <summary>
            Provides extension members on <see cref="T:System.Collections.Generic.HashSet`1"/>.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.HashSetExtensions.`1.ToArray">
            <summary>
            Try to convert a <see cref="T:System.Collections.Generic.HashSet`1"/> into an array, without any conversions among internal values.
            </summary>
            <returns>An array converted.</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSetExtensions.`1.AsReadOnlySpan">
            <summary>
            Try to convert a <see cref="T:System.Collections.Generic.HashSet`1"/> into a <see cref="T:System.ReadOnlySpan`1"/>,
            without any conversions among internal values.
            </summary>
            <returns>A <see cref="T:System.ReadOnlySpan`1"/> converted.</returns>
        </member>
        <member name="T:System.Collections.Generic.Entry`1">
            <summary>
            Represents an entry to call internal fields on <see cref="T:System.Collections.Generic.HashSet`1"/>.
            </summary>
            <typeparam name="T">The type of each element in <see cref="T:System.Collections.Generic.HashSet`1"/>.</typeparam>
            <seealso cref="T:System.Collections.Generic.HashSet`1"/>
        </member>
        <member name="T:System.Collections.Generic.Entry`1.EnumeratorEntry">
            <summary>
            Represents an entry to call internal fields on <see cref="T:System.Collections.Generic.HashSet`1.Enumerator"/>.
            </summary>
            <seealso cref="T:System.Collections.Generic.HashSet`1.Enumerator"/>
        </member>
        <member name="M:System.Collections.Generic.Entry`1.EnumeratorEntry.GetCurrentFieldRef(System.Collections.Generic.HashSet{`0}.Enumerator@)">
            <summary>
            Try to fetch the internal field <c>_current</c> in type <see cref="T:System.Collections.Generic.HashSet`1.Enumerator" />.
            </summary>
            <param name="this">The set.</param>
            <returns>The reference to the internal field.</returns>
            <remarks>
            <target name="others">
					<para>
						This method is implemented via <see cref="T:System.Runtime.CompilerServices.UnsafeAccessorAttribute" />,
						which is just like inserting .NET implementation into the current project directly.
					</para>
				</target>
            <target name="field-related-method">
					<para>
						<b>
							Please note that this method will return the reference to the internal field,
							but this doesn't mean you can use its reference and re-assign it.
							You cannot assign a value to the field if the ref kind of a field in fact is <see langword="ref readonly" />;
							it will raise an exception to report this wrong usage.
						</b>
					</para>
				</target>
            <target type="struct">
					<para>
						<b>
							In addition, if the target type is a <see langword="struct" />, it requires a <see langword="ref" /> keyword;
							otherwise, <see cref="T:System.BadImageFormatException" /> will be thrown.
						</b>
					</para>
				</target>
            </remarks>
        </member>
        <member name="T:System.Collections.Generic.ICollectionExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <seealso cref="T:System.Collections.Generic.ICollection`1"/>
        </member>
        <member name="T:System.Collections.Generic.ICollectionExtensions.`1">
            <summary>
            Provides extension members on <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.ICollectionExtensions.`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds the elements of the specified collection to the end of the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <param name="elements">The collection whose elements should be added to the end of the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
        </member>
        <member name="T:System.Collections.Generic.IDictionaryEntry`1">
            <summary>
            Represents an entry that can be used as a type parameter <c>TKey</c> in <see cref="T:System.Collections.Generic.Dictionary`2" />.
            </summary>
            <typeparam name="TSelf"><self-type-constraint>
		<para>Indicates the type implementing this interface.</para>
		<para>
			This type doesn't use any extra syntax to constraint such usage, but C# will check for it.
			The type will include a <see langword="where" /> constraint that implements the interface itself
			to declare such "self constraint" usage:
			<code><![CDATA[interface ISelfType<TSelf> where TSelf : ISelfType<TSelf>]]></code>
			In addition, the type should be named <c>TSelf</c> in order to tell type parameters with the others.
		</para>
	</self-type-constraint></typeparam>
            <remarks>
            <b>The type is only used as a constraint, while implementing a data type for key usages temporarily.</b>
            </remarks>
            <seealso cref="T:System.Collections.Generic.Dictionary`2" />
        </member>
        <member name="T:System.Collections.Generic.IFiniteSet`2">
            <summary>
            Represents an object that is a set of elements of type <typeparamref name="T" />, and is a closed set,
            meaning the set contains concept "all", i.e. set can be negated.
            </summary>
            <typeparam name="TSelf"><self-type-constraint>
		<para>Indicates the type implementing this interface.</para>
		<para>
			This type doesn't use any extra syntax to constraint such usage, but C# will check for it.
			The type will include a <see langword="where" /> constraint that implements the interface itself
			to declare such "self constraint" usage:
			<code><![CDATA[interface ISelfType<TSelf> where TSelf : ISelfType<TSelf>]]></code>
			In addition, the type should be named <c>TSelf</c> in order to tell type parameters with the others.
		</para>
	</self-type-constraint></typeparam>
            <typeparam name="T"><inheritdoc cref="T:System.Collections.Generic.ISet`1" path="/typeparam[@name='T']" /></typeparam>
        </member>
        <member name="M:System.Collections.Generic.IFiniteSet`2.Negate">
            <summary>
            Returns an object that inverts elements including the current collection.
            </summary>
            <returns>An instance as the result.</returns>
        </member>
        <member name="T:System.Collections.Generic.IInfiniteSet`2">
            <summary>
            Represents an object that is a set of elements of type <typeparamref name="T" />, and isn't a closed set,
            meaning the set doesn't contain concept "all", i.e. set cannot be negated.
            </summary>
            <typeparam name="TSelf"><self-type-constraint>
		<para>Indicates the type implementing this interface.</para>
		<para>
			This type doesn't use any extra syntax to constraint such usage, but C# will check for it.
			The type will include a <see langword="where" /> constraint that implements the interface itself
			to declare such "self constraint" usage:
			<code><![CDATA[interface ISelfType<TSelf> where TSelf : ISelfType<TSelf>]]></code>
			In addition, the type should be named <c>TSelf</c> in order to tell type parameters with the others.
		</para>
	</self-type-constraint></typeparam>
            <typeparam name="T"><inheritdoc cref="T:System.Collections.Generic.ISet`1" path="/typeparam[@name='T']" /></typeparam>
        </member>
        <member name="M:System.Collections.Generic.IInfiniteSet`2.ExceptWith(`0)">
            <summary>
            Makes an subtraction from two objects of type <typeparamref name="TSelf"/>,
            to get elements that are in the current collection, but not in the collection <paramref name="other"/>.
            </summary>
            <param name="other">The collection to make subraction.</param>
            <returns>An instance as the result.</returns>
        </member>
        <member name="T:System.Collections.Generic.KeyValuePairExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.
            </summary>
            <seealso cref="T:System.Collections.Generic.KeyValuePair`2"/>
        </member>
        <member name="T:System.Collections.Generic.KeyValuePairExtensions.`2">
            <summary>
            Provides extension members on <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.
            </summary>
        </member>
        <member name="P:System.Collections.Generic.KeyValuePairExtensions.`2.KeyRef">
            <summary>
            Indicates the reference of key.
            </summary>
        </member>
        <member name="P:System.Collections.Generic.KeyValuePairExtensions.`2.ValueRef">
            <summary>
            Indicates the reference to value.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.KeyValuePairExtensions.`2.ToTuple">
            <summary>
            Converts the current <see cref="T:System.Collections.Generic.KeyValuePair`2"/> instance into a pair of values.
            </summary>
            <returns>The final pair of values converted.</returns>
        </member>
        <member name="M:System.Collections.Generic.KeyValuePairExtensions.Cast``4(System.Collections.Generic.KeyValuePair{``0,``1}@)">
            <summary>
            Casts the current instance into a new type of <see cref="T:System.Collections.Generic.KeyValuePair`2"/>
            with type projection:
            <list type="bullet">
            <item><typeparamref name="TKey"/> -> <typeparamref name="TKeyResult"/></item>
            <item><typeparamref name="TValue"/> -> <typeparamref name="TValueResult"/></item>
            </list>
            </summary>
            <typeparam name="TKey">The type of key.</typeparam>
            <typeparam name="TValue">The type of value.</typeparam>
            <typeparam name="TKeyResult">The type of result key.</typeparam>
            <typeparam name="TValueResult">The type of result value.</typeparam>
            <param name="this">The instance.</param>
            <returns>The casted result.</returns>
        </member>
        <member name="T:System.Collections.Generic.Entry`2">
            <summary>
            Represents an entry to call internal fields on <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.
            </summary>
            <typeparam name="TKey">The key type of each element in <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.</typeparam>
            <typeparam name="TValue">The value type of each element in <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.</typeparam>
            <seealso cref="T:System.Collections.Generic.KeyValuePair`2"/>
        </member>
        <member name="M:System.Collections.Generic.Entry`2.GetKey(System.Collections.Generic.KeyValuePair{`0,`1}@)">
            <summary>
            Try to fetch the internal field <c>key</c> in type <see cref="T:System.Collections.Generic.KeyValuePair`2" />.
            </summary>
            <param name="this">The key-value pair.</param>
            <returns>The reference to the internal field.</returns>
            <remarks>
            <target name="others">
					<para>
						This method is implemented via <see cref="T:System.Runtime.CompilerServices.UnsafeAccessorAttribute" />,
						which is just like inserting .NET implementation into the current project directly.
					</para>
				</target>
            <target name="field-related-method">
					<para>
						<b>
							Please note that this method will return the reference to the internal field,
							but this doesn't mean you can use its reference and re-assign it.
							You cannot assign a value to the field if the ref kind of a field in fact is <see langword="ref readonly" />;
							it will raise an exception to report this wrong usage.
						</b>
					</para>
				</target>
            <target type="struct">
					<para>
						<b>
							In addition, if the target type is a <see langword="struct" />, it requires a <see langword="ref" /> keyword;
							otherwise, <see cref="T:System.BadImageFormatException" /> will be thrown.
						</b>
					</para>
				</target>
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.Entry`2.GetValue(System.Collections.Generic.KeyValuePair{`0,`1}@)">
            <summary>
            Try to fetch the internal field <c>value</c> in type <see cref="T:System.Collections.Generic.KeyValuePair`2" />.
            </summary>
            <param name="this">The key-value pair.</param>
            <returns>The reference to the internal field.</returns>
            <remarks>
            <target name="others">
					<para>
						This method is implemented via <see cref="T:System.Runtime.CompilerServices.UnsafeAccessorAttribute" />,
						which is just like inserting .NET implementation into the current project directly.
					</para>
				</target>
            <target name="field-related-method">
					<para>
						<b>
							Please note that this method will return the reference to the internal field,
							but this doesn't mean you can use its reference and re-assign it.
							You cannot assign a value to the field if the ref kind of a field in fact is <see langword="ref readonly" />;
							it will raise an exception to report this wrong usage.
						</b>
					</para>
				</target>
            <target type="struct">
					<para>
						<b>
							In addition, if the target type is a <see langword="struct" />, it requires a <see langword="ref" /> keyword;
							otherwise, <see cref="T:System.BadImageFormatException" /> will be thrown.
						</b>
					</para>
				</target>
            </remarks>
        </member>
        <member name="T:System.Collections.Generic.LinkedList">
            <summary>
            Represents a type that creates a <see cref="T:System.Collections.Generic.LinkedList`1"/> instance.
            </summary>
            <seealso cref="T:System.Collections.Generic.LinkedList`1"/>
        </member>
        <member name="M:System.Collections.Generic.LinkedList.Singleton``1(``0)">
            <summary>
            Creates a <see cref="T:System.Collections.Generic.LinkedList`1"/> with only one element.
            </summary>
            <typeparam name="T">The type of each element of the return value.</typeparam>
            <param name="value">The value to be created.</param>
            <returns>A <see cref="T:System.Collections.Generic.LinkedList`1"/> instance, with only one element inside it.</returns>
        </member>
        <member name="M:System.Collections.Generic.LinkedList.Create``1(System.Collections.Generic.LinkedList{``0},``0)">
            <summary>
            Creates a <see cref="T:System.Collections.Generic.LinkedList`1"/> with the original values and a new value.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="original">The original collection.</param>
            <param name="newValue">The new value to be added.</param>
            <returns>A <see cref="T:System.Collections.Generic.LinkedList`1"/> instance.</returns>
        </member>
        <member name="T:System.Collections.Generic.LinkedListExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.Collections.Generic.LinkedList`1"/>.
            </summary>
            <seealso cref="T:System.Collections.Generic.LinkedList`1"/>
        </member>
        <member name="T:System.Collections.Generic.LinkedListExtensions.`1">
            <summary>
            Provides extension members on <see cref="T:System.Collections.Generic.LinkedList`1"/>.
            </summary>
        </member>
        <member name="P:System.Collections.Generic.LinkedListExtensions.`1.FirstValue">
            <summary>
            Indicates the value of the first node.
            </summary>
            <exception cref="T:System.NullReferenceException">Throws when the list is empty.</exception>
        </member>
        <member name="P:System.Collections.Generic.LinkedListExtensions.`1.LastValue">
            <summary>
            Indicates the value of the last node.
            </summary>
            <exception cref="T:System.NullReferenceException">Throws when the list is empty.</exception>
        </member>
        <member name="M:System.Collections.Generic.LinkedListExtensions.`1.Exists(System.Func{`0,System.Boolean})">
            <summary>
            Checks whether the collection exists at least one element satisfying the specified condition.
            </summary>
            <param name="match">A method to be called.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:System.Collections.Generic.LinkedListExtensions.`1.RemoveFirstNode">
            <summary>
            Removes the first element and return that element.
            </summary>
            <returns>The first element to be removed.</returns>
        </member>
        <member name="M:System.Collections.Generic.LinkedListExtensions.`1.RemoveLastNode">
            <summary>
            Removes the last element and return that element.
            </summary>
            <returns>The last element to be removed.</returns>
        </member>
        <member name="T:System.Collections.Generic.ListExtensions">
            <summary>
            Provides extension methods on <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
            <seealso cref="T:System.Collections.Generic.List`1"/>
        </member>
        <member name="T:System.Collections.Generic.ListExtensions.`1">
            <summary>
            Provides extension members on <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.`1.AddRef(`0@)">
            <summary>
            Adds an object to the end of the <see cref="T:System.Collections.Generic.List`1" />.
            </summary>
            <param name="item">The object to be added to the end of the <see cref="T:System.Collections.Generic.List`1" />.</param>
            <remarks>
            <target name="others">
					<para>
						This method is implemented via <see cref="T:System.Runtime.CompilerServices.UnsafeAccessorAttribute" />,
						which is just like inserting .NET implementation into the current project directly.
					</para>
				</target>
            <feature name="unsafe-accessor">
				<para>
					Begin with .NET 9 preview 4, <see cref="T:System.Runtime.CompilerServices.UnsafeAccessorAttribute" />
					supports with generic-typed references.
				</para>
			</feature>
            <para>
            This method passes with a reference to an object, which is unnecessary to be called by a reference-typed object,
            or a value-typed object whose memory size is less than a pointer. <b>Always measure the necessity of the usage.</b>
            </para>
            </remarks>
            <seealso cref="T:System.Runtime.CompilerServices.UnsafeAccessorAttribute" />
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.`1.AddRangeRef(System.ReadOnlySpan{`0})">
            <summary>
            Adds the elements of the specified <see cref="T:System.ReadOnlySpan`1" /> to the end of the <see cref="T:System.Collections.Generic.List`1" />.
            </summary>
            <param name="items">The collection whose elements should be added to the end of the <see cref="T:System.Collections.Generic.List`1" />.</param>
            <remarks>
            <target name="others">
					<para>
						This method is implemented via <see cref="T:System.Runtime.CompilerServices.UnsafeAccessorAttribute" />,
						which is just like inserting .NET implementation into the current project directly.
					</para>
				</target>
            <feature name="unsafe-accessor">
				<para>
					Begin with .NET 9 preview 4, <see cref="T:System.Runtime.CompilerServices.UnsafeAccessorAttribute" />
					supports with generic-typed references.
				</para>
			</feature>
            <para>
            This method passes with a <see cref="T:System.ReadOnlySpan`1" /> instead of <see cref="T:System.Collections.Generic.IEnumerable`1" />,
            allowing iterating on read-only references of collection elements, which is unnecessary to be called
            by a reference-typed object, or a value-typed object whose memory size is less than a pointer.
            <b>Always measure the necessity of the usage.</b>
            </para>
            </remarks>
            <seealso cref="T:System.Runtime.CompilerServices.UnsafeAccessorAttribute" />
            <seealso cref="T:System.ReadOnlySpan`1" />
            <seealso cref="T:System.Collections.Generic.IEnumerable`1" />
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.`1.RemoveAt(System.Index)">
            <inheritdoc cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)"/>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.`1.AsSpan">
            <summary>
            Gets a <see cref="T:System.ReadOnlySpan`1"/> view over the data in a list.
            Items should not be added or removed from the <see cref="T:System.Collections.Generic.List`1"/> while the <see cref="T:System.ReadOnlySpan`1"/> is in use.
            </summary>
            <returns>A <see cref="T:System.ReadOnlySpan`1"/> instance over the <see cref="T:System.Collections.Generic.List`1"/>.</returns>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.`1.AsMemory">
            <summary>
            Try to create a <see cref="T:System.ReadOnlyMemory`1"/> with values from the current <see cref="T:System.Collections.Generic.List`1"/> object,
            without any copy operation.
            </summary>
            <returns>The created <see cref="T:System.ReadOnlyMemory`1"/> instance.</returns>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.`1.GetInternalArray">
            <summary>
            Returns the internal array of <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
            <returns>The internal array.</returns>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.`1.AddWithResize(`0@)">
            <summary>
            Add an item and resize the <see cref="T:System.Collections.Generic.List`1" /> of <typeparamref name="T" />.
            </summary>
            <param name="item">An instance of type <typeparamref name="T" /> to be added.</param>
            <remarks>
            <target name="others">
					<para>
						This method is implemented via <see cref="T:System.Runtime.CompilerServices.UnsafeAccessorAttribute" />,
						which is just like inserting .NET implementation into the current project directly.
					</para>
				</target>
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.`1.GetNewCapacity(System.Int32)">
            <summary>
            Try to get a new capacity value by the desired capacity to be set.
            </summary>
            <param name="capacity">The desired capacity to be set.</param>
            <returns>The result value to be set.</returns>
            <remarks>
            <target name="others">
					<para>
						This method is implemented via <see cref="T:System.Runtime.CompilerServices.UnsafeAccessorAttribute" />,
						which is just like inserting .NET implementation into the current project directly.
					</para>
				</target>
            </remarks>
        </member>
        <member name="T:System.Collections.Generic.ListExtensions.`1">
            <summary>
            Provides extension members on <see cref="T:System.Collections.Generic.List`1"/>,
            where <typeparamref name="T"/> satisfies <see cref="T:System.IEquatable`1"/> constraint.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.`1.SequenceEqual(System.Collections.Generic.List{`0})">
            <summary>
            Determines whether two sequences are equal by comparing the elements
            by using <see cref="M:System.IEquatable`1.Equals(`0)"/> for their type.
            </summary>
            <param name="other">A <see cref="T:System.Collections.Generic.List`1"/> to compare to.</param>
            <returns>
            <see langword="true"/> if the two source sequences are of equal length and their corresponding elements are equal according
            to <see cref="M:System.IEquatable`1.Equals(`0)"/> for their type; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="T:System.Collections.Generic.ListExtensions.`1">
            <summary>
            Provides extension members on <see cref="T:System.Collections.Generic.List`1"/>,
            where <typeparamref name="T"/> satisfies <see cref="T:System.Numerics.IAdditiveIdentity`2"/>, <see cref="T:System.Numerics.IAdditionOperators`3"/> constraints.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.`1.Sum">
            <inheritdoc cref="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Int32})"/>
        </member>
        <member name="T:System.Collections.Generic.Entry`1">
            <summary>
            Represents an entry to call internal fields on <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
            <typeparam name="T">The type of each element in <see cref="T:System.Collections.Generic.List`1"/>.</typeparam>
            <seealso cref="T:System.Collections.Generic.List`1"/>
        </member>
        <member name="M:System.Collections.Generic.Entry`1.GetSize(System.Collections.Generic.List{`0})">
            <summary>
            Try to fetch the internal field <c>_size</c> in type <see cref="T:System.Collections.Generic.List`1" />.
            </summary>
            <param name="this">The list.</param>
            <returns>The reference to the internal field.</returns>
            <remarks>
            <target name="others">
					<para>
						This method is implemented via <see cref="T:System.Runtime.CompilerServices.UnsafeAccessorAttribute" />,
						which is just like inserting .NET implementation into the current project directly.
					</para>
				</target>
            <target name="field-related-method">
					<para>
						<b>
							Please note that this method will return the reference to the internal field,
							but this doesn't mean you can use its reference and re-assign it.
							You cannot assign a value to the field if the ref kind of a field in fact is <see langword="ref readonly" />;
							it will raise an exception to report this wrong usage.
						</b>
					</para>
				</target>
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.Entry`1.GetVersion(System.Collections.Generic.List{`0})">
            <summary>
            Try to fetch the internal field <c>_version</c> in type <see cref="T:System.Collections.Generic.List`1" />.
            </summary>
            <param name="this">The list.</param>
            <returns>The reference to the internal field.</returns>
            <remarks>
            <target name="others">
					<para>
						This method is implemented via <see cref="T:System.Runtime.CompilerServices.UnsafeAccessorAttribute" />,
						which is just like inserting .NET implementation into the current project directly.
					</para>
				</target>
            <target name="field-related-method">
					<para>
						<b>
							Please note that this method will return the reference to the internal field,
							but this doesn't mean you can use its reference and re-assign it.
							You cannot assign a value to the field if the ref kind of a field in fact is <see langword="ref readonly" />;
							it will raise an exception to report this wrong usage.
						</b>
					</para>
				</target>
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.Entry`1.GetItems(System.Collections.Generic.List{`0})">
            <summary>
            Try to fetch the internal reference to the first <typeparamref name="T" /> in a <see cref="T:System.Collections.Generic.List`1" />.
            </summary>
            <param name="this">The list of <typeparamref name="T" /> instances.</param>
            <returns>The reference to the first <typeparamref name="T" />.</returns>
            <remarks>
            <target name="others">
					<para>
						This method is implemented via <see cref="T:System.Runtime.CompilerServices.UnsafeAccessorAttribute" />,
						which is just like inserting .NET implementation into the current project directly.
					</para>
				</target>
            <target name="field-related-method">
					<para>
						<b>
							Please note that this method will return the reference to the internal field,
							but this doesn't mean you can use its reference and re-assign it.
							You cannot assign a value to the field if the ref kind of a field in fact is <see langword="ref readonly" />;
							it will raise an exception to report this wrong usage.
						</b>
					</para>
				</target>
            </remarks>
        </member>
        <member name="T:System.Collections.Generic.SortedSetExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.Collections.Generic.SortedSet`1"/>.
            </summary>
            <seealso cref="T:System.Collections.Generic.SortedSet`1"/>
        </member>
        <member name="T:System.Collections.Generic.SortedSetExtensions.`1">
            <summary>
            Provides extension members on <see cref="T:System.Collections.Generic.SortedSet`1"/>.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.SortedSetExtensions.`1.AddRange(System.ReadOnlySpan{`0})">
            <summary>
            Adds the elements into the collection.
            </summary>
            <param name="values">The elements to be added.</param>
            <returns>The number of elements successfully to be added.</returns>
        </member>
        <member name="M:System.Collections.Generic.SortedSetExtensions.`1.ToArray">
            <summary>
            Try to convert the current instance into an array.
            </summary>
            <returns>An array of <typeparamref name="T"/> elements.</returns>
        </member>
        <member name="T:System.Collections.Generic.StackExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.Collections.Generic.Stack`1"/> instances.
            </summary>
            <seealso cref="T:System.Collections.Generic.Stack`1"/>
        </member>
        <member name="T:System.Collections.Generic.StackExtensions.`1">
            <summary>
            Provides extension members on <see cref="T:System.Collections.Generic.Stack`1"/>.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.StackExtensions.`1.Reverse">
            <inheritdoc cref="M:System.Linq.Enumerable.Reverse``1(System.Collections.Generic.IEnumerable{``0})" />
        </member>
        <member name="M:System.Collections.Generic.StackExtensions.`1.GetInternalArray">
            <summary>
            Returns the internal array of <see cref="T:System.Collections.Generic.Stack`1" />.
            </summary>
            <returns>The internal array.</returns>
            <remarks>
            <target name="others">
					<para>
						This method is implemented via <see cref="T:System.Runtime.CompilerServices.UnsafeAccessorAttribute" />,
						which is just like inserting .NET implementation into the current project directly.
					</para>
				</target>
            <feature name="unsafe-accessor">
				<para>
					Begin with .NET 9 preview 4, <see cref="T:System.Runtime.CompilerServices.UnsafeAccessorAttribute" />
					supports with generic-typed references.
				</para>
			</feature>
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.StackExtensions.`1.GetCount">
            <summary>
            Returns the internal count value of <see cref="T:System.Collections.Generic.Stack`1" />.
            </summary>
            <returns>The internal field <c>_size</c>.</returns>
            <remarks>
            <target name="others">
					<para>
						This method is implemented via <see cref="T:System.Runtime.CompilerServices.UnsafeAccessorAttribute" />,
						which is just like inserting .NET implementation into the current project directly.
					</para>
				</target>
            <feature name="unsafe-accessor">
				<para>
					Begin with .NET 9 preview 4, <see cref="T:System.Runtime.CompilerServices.UnsafeAccessorAttribute" />
					supports with generic-typed references.
				</para>
			</feature>
            </remarks>
        </member>
        <member name="T:System.Collections.Generic.StackEntry`1">
            <summary>
            Represents an entry to call internal fields on <see cref="T:System.Collections.Generic.Stack`1"/>.
            </summary>
            <typeparam name="T">The type of each element in <see cref="T:System.Collections.Generic.Stack`1"/>.</typeparam>
            <seealso cref="T:System.Collections.Generic.Stack`1"/>
        </member>
        <member name="M:System.Collections.Generic.StackEntry`1.GetArray(System.Collections.Generic.Stack{`0})">
            <summary>
            Try to get the backing array of a <see cref="T:System.Collections.Generic.Stack`1" />.
            </summary>
            <param name="this">The stack of <typeparamref name="T" /> instances.</param>
            <returns>The reference to field <c>_array</c>.</returns>
            <remarks>
            <target name="others">
					<para>
						This method is implemented via <see cref="T:System.Runtime.CompilerServices.UnsafeAccessorAttribute" />,
						which is just like inserting .NET implementation into the current project directly.
					</para>
				</target>
            <target name="field-related-method">
					<para>
						<b>
							Please note that this method will return the reference to the internal field,
							but this doesn't mean you can use its reference and re-assign it.
							You cannot assign a value to the field if the ref kind of a field in fact is <see langword="ref readonly" />;
							it will raise an exception to report this wrong usage.
						</b>
					</para>
				</target>
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.StackEntry`1.GetCount(System.Collections.Generic.Stack{`0})">
            <summary>
            Try to get the backing field <c>_size</c> of a <see cref="T:System.Collections.Generic.Stack`1" />.
            </summary>
            <param name="this">The stack of <typeparamref name="T" /> instances.</param>
            <returns>The reference to field <c>_size</c>.</returns>
            <remarks>
            <target name="others">
					<para>
						This method is implemented via <see cref="T:System.Runtime.CompilerServices.UnsafeAccessorAttribute" />,
						which is just like inserting .NET implementation into the current project directly.
					</para>
				</target>
            <target name="field-related-method">
					<para>
						<b>
							Please note that this method will return the reference to the internal field,
							but this doesn't mean you can use its reference and re-assign it.
							You cannot assign a value to the field if the ref kind of a field in fact is <see langword="ref readonly" />;
							it will raise an exception to report this wrong usage.
						</b>
					</para>
				</target>
            </remarks>
        </member>
        <member name="T:System.Collections.ObjectModel.ObservableCollectionExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.Collections.ObjectModel.ObservableCollection`1"/>.
            </summary>
            <seealso cref="T:System.Collections.ObjectModel.ObservableCollection`1"/>
        </member>
        <member name="T:System.Collections.ObjectModel.ObservableCollectionExtensions.`1">
            <summary>
            Provides extension members on <see cref="T:System.Collections.ObjectModel.ObservableCollection`1"/>.
            </summary>
        </member>
        <member name="M:System.Collections.ObjectModel.ObservableCollectionExtensions.`1.FindIndex(System.Func{`0,System.Boolean})">
            <summary>
            Searches for an element that matches the conditions defined by the specified predicate,
            and returns the zero-based index of the first occurrence within the entire <see cref="T:System.Collections.ObjectModel.ObservableCollection`1"/>.
            </summary>
            <param name="match"><inheritdoc cref="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})" path="/param[@name='match']"/></param>
            <returns><inheritdoc cref="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})" path="/returns"/></returns>
        </member>
        <member name="M:System.Collections.ObjectModel.ObservableCollectionExtensions.`1.FindLastIndex(System.Func{`0,System.Boolean})">
            <summary>
            Searches for an element that matches the conditions defined by the specified predicate,
            and returns the zero-based index of the last occurrence within the entire <see cref="T:System.Collections.ObjectModel.ObservableCollection`1"/>.
            </summary>
            <param name="match"><inheritdoc cref="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})" path="/param[@name='match']"/></param>
            <returns><inheritdoc cref="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})" path="/returns"/></returns>
        </member>
        <member name="T:System.Collections.ObjectModel.CollectionExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.Collections.ObjectModel.Collection`1"/>.
            </summary>
            <seealso cref="T:System.Collections.ObjectModel.Collection`1"/>
        </member>
        <member name="T:System.Collections.ObjectModel.CollectionExtensions.`1">
            <summary>
            Provides extension members on <see cref="T:System.Collections.ObjectModel.Collection`1"/>.
            </summary>
        </member>
        <member name="M:System.Collections.ObjectModel.CollectionExtensions.`1.RemoveAt(System.Index)">
            <inheritdoc cref="M:System.Collections.ObjectModel.Collection`1.RemoveAt(System.Int32)"/>
        </member>
        <member name="T:System.delegate">
            <summary>
            Represents a set of method groups that can be used as delegate-typed arguments, in easy ways.
            </summary>
        </member>
        <member name="M:System.delegate.DoNothing">
            <summary>
            Do nothing. This method is equivalent to lambda expression <c>static () => {}</c>.
            </summary>
        </member>
        <member name="M:System.delegate.ReturnEmptyString``1(``0)">
            <summary>
            Returns an empty string equivalent to <see cref="F:System.String.Empty"/> no matter what the argument is.
            </summary>
            <typeparam name="T">The type of the argument. In fact the argument won't be used in this method.</typeparam>
            <param name="instance">The instance. In fact the argument won't be used in this method.</param>
            <returns>A string that is equal to <see cref="F:System.String.Empty"/>.</returns>
            <seealso cref="F:System.String.Empty"/>
        </member>
        <member name="M:System.delegate.BitMerger``1(``0,``0)">
            <summary>
            Merges two integers by bits. This method will be used by LINQ method
            <see cref="M:System.Linq.Enumerable.Aggregate``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0})"/>.
            </summary>
            <typeparam name="TBinaryInteger">The type of the value. The value must be an integer type, and supports for shifting operators.</typeparam>
            <param name="interim">The interim value.</param>
            <param name="next">The next value to be merged by its bits.</param>
            <returns>The final value merged.</returns>
            <seealso cref="M:System.Linq.Enumerable.Aggregate``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0})"/>
        </member>
        <member name="M:System.delegate.EnumFlagMerger``1(``0,``0)">
            <summary>
            Merges two flags of type <typeparamref name="TEnum"/>.
            </summary>
            <typeparam name="TEnum">The type of the enumeration.</typeparam>
            <param name="left">The first instance to be merged.</param>
            <param name="right">The second instance to be merged.</param>
            <returns>A merged result.</returns>
        </member>
        <member name="M:System.delegate.Self``1(``0)">
            <summary>
            Returns the argument <paramref name="value"/>.
            </summary>
            <typeparam name="T">The type of the argument.</typeparam>
            <param name="value">The value.</param>
            <returns>The value itself.</returns>
        </member>
        <member name="M:System.delegate.YCombinator``2(System.Func{System.Func{``0,``1},System.Func{``0,``1}})">
            <summary>
            (Easter egg) Represents Y-Combinator. This method can allow you create recursive lambdas:
            <code><![CDATA[
            var factorial = YCombinator(static (Func<int, int> lambda) => value => value == 0 ? 1 : value * lambda(value - 1));
            int result = factorial(5); // 120
            Console.WriteLine(result);
            ]]></code>
            </summary>
            <typeparam name="T">The type of the argument to be passed.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="f">The recursion logic.</param>
            <returns>A function that creates a nesting lambda that is a recursive lambda.</returns>
        </member>
        <member name="T:System.DelegateExtensions">
            <summary>
            Provides extension methods on <see cref="T:System.Delegate"/>.
            </summary>
            <seealso cref="T:System.Delegate"/>
        </member>
        <member name="T:System.DelegateExtensions.">
            <summary>
            Provides extension members on <see cref="T:System.Delegate"/>.
            </summary>
        </member>
        <member name="M:System.DelegateExtensions..GetInvocations``1(``0)">
            <summary>
            Returns the invocation list of the delegate.
            </summary>
            <typeparam name="TDelegate">The type of the delegate.</typeparam>
            <param name="delegate">The instance.</param>
            <returns>An array of delegates representing the invocation list of the current delegate.</returns>
        </member>
        <member name="M:System.DelegateExtensions..GetEnumerator``1(``0)">
            <inheritdoc cref="M:System.Delegate.EnumerateInvocationList``1(``0)"/>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.ComponentMemberAttribute">
            <summary>
            Represents an attribute type that describes a data member is a component member,
            used by source generator to generate unified source code.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DisposableMemberAttribute">
            <summary>
            Represents an attribute type that can be applied to a field or a property,
            indicating the member can be used and called by methods
            <see cref="M:System.IDisposable.Dispose"/> and <see cref="M:System.IAsyncDisposable.DisposeAsync"/>.
            </summary>
            <seealso cref="M:System.IDisposable.Dispose"/>
            <seealso cref="M:System.IAsyncDisposable.DisposeAsync"/>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.EmitPropertyStyle">
            <summary>
            Represents a style of emit property.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.EmitPropertyStyle.AssignToProperty">
            <summary>
            Indicates the behavior is to generate an assignment to property:
            <code><![CDATA[public int Property { get; } = value;]]></code>
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.EmitPropertyStyle.ReturnParameter">
            <summary>
            Indicates the behavior is to generate a return statement that directly returns parameter:
            <code><![CDATA[public int Property => value;]]></code>
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.EqualsBehavior">
            <summary>
            Defines a behavior by source generator on generating <see cref="M:System.Object.Equals(System.Object)"/> overridden methods.
            </summary>
            <seealso cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.EqualsBehavior.Intelligent">
            <summary>
            Indicates the source generator will automatically adopt a case for an overridden unit.
            <list type="bullet">
            <item>For <see langword="ref struct"/>s, return <see langword="false"/> because there is implicitly box and unbox operation</item>
            <item>For <see langword="class"/>es, use <see langword="as"/> casting and call overloaded <c>Equals</c> method</item>
            <item>For <see langword="struct"/>s, use <see langword="is"/> casting and call overloaded <c>Equals</c> method</item>
            </list>
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.EqualsBehavior.ThrowNotSupportedException">
            <summary>
            Indicates the method always throws <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.EqualsBehavior.MakeAbstract">
            <summary>
            Indicates the method will be made <see langword="abstract"/>.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.EquatableMemberAttribute">
            <summary>
            Indicates the marked member will participate equality comparison operation, especially for <see cref="M:System.IEquatable`1.Equals(`0)"/>.
            </summary>
            <seealso cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.FactoryPropertyAttribute">
            <summary>
            Represents a factory property attribute.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.FactoryPropertyAttribute.ParameterModifiers">
            <summary>
            Indicates the parameter modifiers to be applied.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.FactoryPropertyAttribute.ParameterName">
            <summary>
            Indicates the parameter name to be applied.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.FactoryPropertyAttribute.MethodSuffixName">
            <summary>
            Indicates the method suffix name to be created.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.FactoryPropertyAttribute.Accessibility">
            <summary>
            Indicates the accessibility of the factory method generated. By default the accessibility is same as property's.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.FactoryPropertyAttribute.ParameterType">
            <summary>
            Indicates the parameter type to be created.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.FieldAttribute">
            <summary>
            Indicates the backing generated member of this primary constructor is a field.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.FieldAttribute.IsReadOnlyByDefault">
            <summary>
            Indicates whether the generated field or property is implicitly read-only.
            If the property is <see langword="true"/>, the generated data member (auto-impl'ed propertys or fields) will be modified
            by keyword <see langword="readonly"/> if all following conditions are true:
            <list type="number">
            <item>
            The type is a <see langword="struct"/>, <see langword="record struct"/>,
            <see langword="extension"/> or <see langword="role"/> (will be included in future C# version)
            </item>
            <item>The type is not marked with keyword <see langword="readonly"/></item>
            </list>
            However, sometimes we should use non-<see langword="readonly"/> <see langword="struct"/> member as fields or auto-impl'ed properties,
            but we cannot modify it. By setting the property with <see langword="false"/> value,
            to avoid the source generator marking the generated member as <see langword="readonly"/>.
            </summary>
            <remarks>This property is <see langword="true"/> by default.</remarks>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.GetHashCodeBehavior">
            <summary>
            Defines a behavior by source generator on generating <see cref="M:System.Object.GetHashCode"/> overridden methods.
            </summary>
            <seealso cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.GetHashCodeBehavior.Intelligent">
            <summary>
            Indicates the source generator will adopt an intelligent way to generate hashing expression.
            If none of all data members in a type marked <see cref="T:System.Diagnostics.CodeAnalysis.HashCodeMemberAttribute"/>, a <see cref="T:System.NotSupportedException"/>
            will be thrown; if one member is marked and its type can be directly converted into an <see cref="T:System.Int32"/>, then use itself;
            otherwise, call <see cref="M:System.HashCode.Combine``1(``0)"/> method set or use <see cref="M:System.HashCode.Add``1(``0)"/>.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.GetHashCodeBehavior.ThrowNotSupportedException">
            <summary>
            Indicates throws <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.GetHashCodeBehavior.MakeAbstract">
            <summary>
            Indicates the method will be made <see langword="abstract"/>.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.HashCodeMemberAttribute">
            <summary>
            Indicates the marked member will participate hashing operation.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NamingRules">
            <summary>
            Represents a list of naming rules.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.NamingRules.Field">
            <summary>
            Indicates the naming rule is field.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.NamingRules.Property">
            <summary>
            Indicates the naming rule is property.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NullabilityPrefer">
            <summary>
            Represents an enumeration type that tells source generators which case of nullability should be preferred.
            By default, <see langword="not null"/> for value types and including <see langword="null"/> for reference types.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.NullabilityPrefer.Default">
            <summary>
            Indicates the preferring is default.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.NullabilityPrefer.NotNull">
            <summary>
            Indicates the source generator will prefer <see langword="not null"/>.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.NullabilityPrefer.IncludeNull">
            <summary>
            Indicates the source generator will prefer including <see langword="null"/>.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.ParameterTargetAttribute">
            <summary>
            Represents the base type of attribute target.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.ParameterTargetAttribute.RefKind">
            <summary>
            <para>Indicates the ref modifiers kind.</para>
            <para>
            The value will be as follows by default:
            <list type="table">
            <listheader>
            <term>Case</term>
            <description>Applied ref kind</description>
            </listheader>
            <item>
            <term><see langword="ref"/> parameters in <see langword="ref struct"/></term>
            <description><c>"ref"</c></description>
            </item>
            <item>
            <term><see langword="ref readonly"/> / <see langword="in"/> parameters in <see langword="ref struct"/></term>
            <description><c>"ref readonly"</c></description>
            </item>
            <item>
            <term>Other cases</term>
            <description>No ref kind applied</description>
            </item>
            </list>
            </para>
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.ParameterTargetAttribute.Accessibility">
            <summary>
            Indicates the accessibility of the generated member.
            </summary>
            <remarks>
            <para>
            This property controls the case when you want to customize the accessibility of generated member.
            For example, the value is <c>"private"</c>, the generated member will automatically insert the accessibility modifier
            into property declaration:
            <code><![CDATA[
            private int Parameter { get; } = parameter;
            ]]></code>
            </para>
            <para>
            Also, you can append not only 1 word. For example, the combination <c>"protected internal readonly unsafe"</c> is also acceptable.
            </para>
            <para>By default, the accessibility is <see langword="private"/> for fields and <see langword="public"/> for properties.</para>
            </remarks>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.ParameterTargetAttribute.NamingRule">
            <summary>
            Indicates the naming rule of the generated member name.
            </summary>
            <remarks>
            <para>
            The syntax of this property can be described as two parts:
            <list type="number">
            <item>
            A verbatim symbol <c>@</c> ("At" symbol, may contain an extra character <c><![CDATA[<]]></c> or <c><![CDATA[>]]></c>:
            <c><![CDATA[<@]]></c> or <c><![CDATA[>@]]></c>)
            </item>
            <item>Characters used in a valid identifier</item>
            </list>
            </para>
            <para>
            For example, if you want to set a generated property is named like <c>xxxTargetProperty</c>
            where the <c>xxx</c> is the name of the generated property, you can set this property as value <c>"@TargetProperty"</c>.
            Then the generated property will be like:
            <code><![CDATA[
            public int ParameterTargetProperty { get; } = parameter;
            ]]></code>
            </para>
            <para>
            Also, you can set the first character as lower or upper case via symbols <c><![CDATA[<]]></c> and <c><![CDATA[>]]></c>.
            If this property is <c><![CDATA["_<@"]]></c>, the generated member will be like:
            <code><![CDATA[
            private int _parameter = parameter;
            ]]></code>
            where <c><![CDATA["<@"]]></c> means the generated member name will use lower case for its first character.
            </para>
            <para>
            By default, the naming rule is <c><![CDATA["_<@"]]></c> for fields, and <c><![CDATA[">@"]]></c> for properties.
            </para>
            </remarks>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.PropertyAttribute">
            <summary>
            Indicates the backing generated member of this primary constructor is a property.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.PropertyAttribute.Setter">
            <summary>
            <para>Indicates the extra setter expression. The expression is same declaration as auto-implemented properties.</para>
            <para>
            For example, if the property is declared as <c>public object? Property { get; private set; }</c>,
            the setter expression will be "<c>private set</c>". By default, this value will be <see langword="null"/>,
            which means the target property does not contain a setter.
            </para>
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.PropertyAttribute.EmitPropertyStyle">
            <summary>
            Indicates the target emit property style. By default the value is <see cref="F:System.Diagnostics.CodeAnalysis.EmitPropertyStyle.AssignToProperty"/>.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.PropertySetters">
            <summary>
            Provides an easy way to control property value <see cref="P:System.Diagnostics.CodeAnalysis.PropertyAttribute.Setter"/>.
            </summary>
            <seealso cref="P:System.Diagnostics.CodeAnalysis.PropertyAttribute.Setter"/>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.PropertySetters.Init">
            <summary>
            Represents <see langword="init"/>.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.PropertySetters.Set">
            <summary>
            Represents <see langword="set"/>.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.PropertySetters.InternalSet">
            <summary>
            Represents <see langword="internal set"/>.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.PropertySetters.ProtectedInternalSet">
            <summary>
            Represents <see langword="protected internal set"/>.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.PropertySetters.ProtectedSet">
            <summary>
            Represents <see langword="protected set"/>.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.PropertySetters.PrivateSet">
            <summary>
            Represents <see langword="private set"/>.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.StringMemberAttribute">
            <summary>
            Indicates the marked member will participate to-string operation.
            </summary>
            <param name="displayName">
            Indicates the display name of the field or property to be changed.
            By default the value is <see langword="null"/>, which means no conversion will be existing here.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.StringMemberAttribute.#ctor(System.String)">
            <summary>
            Indicates the marked member will participate to-string operation.
            </summary>
            <param name="displayName">
            Indicates the display name of the field or property to be changed.
            By default the value is <see langword="null"/>, which means no conversion will be existing here.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.StringMemberAttribute.DisplayName">
            <summary>
            The generated property declaration for parameter <c>displayName</c>.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.ToStringBehavior">
            <summary>
            Defines a behavior by source generator on generating <see cref="M:System.Object.ToString"/> overridden methods.
            </summary>
            <seealso cref="M:System.Object.ToString"/>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.ToStringBehavior.Intelligent">
            <summary>
            Indicates the source generator will automatically determine which expression to be output.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.ToStringBehavior.CallOverload">
            <summary>
            Indicates the source generator will generate an expression
            to call overload <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)"/> method.
            </summary>
            <seealso cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.ToStringBehavior.Specified">
            <summary>
            Indicates the source generator will generate an expression
            to output a string whose value is directly from a property or field result.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.ToStringBehavior.RecordLike">
            <summary>
            Indicates the source generator will generate an expression
            like a <see langword="record"/> or <see langword="record struct"/> default output.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.ToStringBehavior.ThrowNotSupportedException">
            <summary>
            Indicates throws <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.ToStringBehavior.MakeAbstract">
            <summary>
            Indicates the method will be made <see langword="abstract"/>.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.TypeImplAttribute">
            <summary>
            Represents an attribute type that can help developers declare types simpler and easier on generating particular code.
            For example, automatically implementing <see cref="T:System.IEquatable`1"/>.
            </summary>
            <param name="flags">Indicates the flags whose corresponding member will be generated.</param>
            <remarks>
            For example, we have defined a record-like type <c>MyColor</c> declared like this:
            <code><![CDATA[
            public readonly struct MyColor(byte a, byte r, byte g, byte b) : IEquatable<MyColor>
            {
                public byte A { get; } = a;
                public byte R { get; } = r;
                public byte G { get; } = g;
                public byte B { get; } = b;
                private int RawValue => A << 24 | R << 16 | G << 8 | B;
            
                public override bool Equals([NotNullWhen(true)] object? other)
                    => other is MyColor comparer && Equals(comparer);
            
                public bool Equals(MyColor other) => RawValue == other.RawValue;
            
                public override int GetHashCode() => RawValue;
            }
            ]]></code>
            By using <see cref="T:System.Diagnostics.CodeAnalysis.TypeImplAttribute"/>, the code can be simplified to this:
            <code><![CDATA[
            [TypeImpl(TypeImplFlags.Equals | TypeImplFlags.GetHashCode | TypeImplFlags.Equatable)]
            public readonly partial struct MyColor([Property] byte a, [Property] byte r, [Property] byte g, [Property] byte b) : IEquatable<MyColor>
            {
                [HashCodeMember]
                [EquatableMember]
                private int RawValue => A << 24 | R << 16 | G << 8 | B;
            }
            ]]></code>
            </remarks>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.TypeImplAttribute.#ctor(System.Diagnostics.CodeAnalysis.TypeImplFlags)">
            <summary>
            Represents an attribute type that can help developers declare types simpler and easier on generating particular code.
            For example, automatically implementing <see cref="T:System.IEquatable`1"/>.
            </summary>
            <param name="flags">Indicates the flags whose corresponding member will be generated.</param>
            <remarks>
            For example, we have defined a record-like type <c>MyColor</c> declared like this:
            <code><![CDATA[
            public readonly struct MyColor(byte a, byte r, byte g, byte b) : IEquatable<MyColor>
            {
                public byte A { get; } = a;
                public byte R { get; } = r;
                public byte G { get; } = g;
                public byte B { get; } = b;
                private int RawValue => A << 24 | R << 16 | G << 8 | B;
            
                public override bool Equals([NotNullWhen(true)] object? other)
                    => other is MyColor comparer && Equals(comparer);
            
                public bool Equals(MyColor other) => RawValue == other.RawValue;
            
                public override int GetHashCode() => RawValue;
            }
            ]]></code>
            By using <see cref="T:System.Diagnostics.CodeAnalysis.TypeImplAttribute"/>, the code can be simplified to this:
            <code><![CDATA[
            [TypeImpl(TypeImplFlags.Equals | TypeImplFlags.GetHashCode | TypeImplFlags.Equatable)]
            public readonly partial struct MyColor([Property] byte a, [Property] byte r, [Property] byte g, [Property] byte b) : IEquatable<MyColor>
            {
                [HashCodeMember]
                [EquatableMember]
                private int RawValue => A << 24 | R << 16 | G << 8 | B;
            }
            ]]></code>
            </remarks>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.TypeImplAttribute.IsLargeStructure">
            <summary>
            Indicates whether source generators will generate source code with modifiers <see langword="ref readonly"/>
            or <see langword="in"/> onto parameters if the parameter type is the current type.
            </summary>
            <remarks>
            The value is <see langword="false"/> by default.
            </remarks>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.TypeImplAttribute.EmitThisCastToInterface">
            <summary>
            Indicates whether the source generator will emit <c>(Interface)<see langword="this"/></c> on implementation,
            especially for cases on calling overloads.
            </summary>
            <remarks>
            The value is <see langword="false"/> by default.
            </remarks>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.TypeImplAttribute.ExplicitlyImplsDisposable">
            <summary>
            Indicates whether the interface type <see cref="T:System.IDisposable"/> will be explicitly-implemented.
            </summary>
            <remarks>
            The value is <see langword="false"/> by default.
            </remarks>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.TypeImplAttribute.ExplicitlyImplsAsyncDisposable">
            <summary>
            Indicates whether the interface type <see cref="T:System.IAsyncDisposable"/> will be explicitly-implemented.
            </summary>
            <remarks>
            The value is <see langword="false"/> by default.
            </remarks>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.TypeImplAttribute.OtherModifiersOnEquals">
            <summary>
            Indicates the extra modifiers can be applied to <see cref="M:System.Object.Equals(System.Object)"/> method.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.TypeImplAttribute.OtherModifiersOnGetHashCode">
            <summary>
            Indicates the extra modifiers can be applied to <see cref="M:System.Object.GetHashCode"/> method.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.TypeImplAttribute.OtherModifiersOnToString">
            <summary>
            Indicates the extra modifiers can be applied to <see cref="M:System.Object.ToString"/> method.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.TypeImplAttribute.OtherModifiersOnEquatableEquals">
            <summary>
            Indicates the extra modifiers can be applied to <see cref="M:System.IEquatable`1.Equals(`0)"/> method.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.TypeImplAttribute.OtherModifiersOnDisposableDispose">
            <summary>
            Indicates the extra modifiers can be applied to <see cref="M:System.IDisposable.Dispose"/> method.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.TypeImplAttribute.OtherModifiersOnAsyncDisposableDisposeAsync">
            <summary>
            Indicates the extra modifiers can be applied to <see cref="M:System.IAsyncDisposable.DisposeAsync"/> method.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.TypeImplAttribute.EquatableLargeStructModifier">
            <summary>
            <para>
            Indicates the modifier that will be applied to implement <c>Equals</c>, as the parameter modifier,
            if the corresponding type (containing type) is a large structure.
            </para>
            <para>
            By default, the modifier is <see langword="ref readonly"/>.
            Supported values can be <see langword="ref"/>, <see langword="ref readonly"/> or <see langword="in"/>.
            </para>
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.TypeImplAttribute.EqualsBehavior">
            <summary>
            Defines a behavior by source generator on generating <see cref="M:System.Object.Equals(System.Object)"/> overridden methods.
            </summary>
            <remarks>
            The value is <see cref="F:System.Diagnostics.CodeAnalysis.EqualsBehavior.Intelligent"/> by default.
            </remarks>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.TypeImplAttribute.GetHashCodeBehavior">
            <summary>
            Defines a behavior by source generator on generating <see cref="M:System.Object.GetHashCode"/> overridden methods.
            </summary>
            <remarks>
            The value is <see cref="F:System.Diagnostics.CodeAnalysis.GetHashCodeBehavior.Intelligent"/> by default.
            </remarks>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.TypeImplAttribute.ToStringBehavior">
            <summary>
            Defines a behavior by source generator on generating <see cref="M:System.Object.ToString"/> overridden methods.
            </summary>
            <remarks>
            The value is <see cref="F:System.Diagnostics.CodeAnalysis.ToStringBehavior.Intelligent"/> by default.
            </remarks>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.TypeImplAttribute.OperandNullabilityPrefer">
            <summary>
            Indicates an extra option to tell source generators which case of nullability should be preferred.
            By default, not null for value types and including null for reference types.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.TypeImplAttribute.Flags">
            <summary>
            The generated property declaration for parameter <c>flags</c>.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.TypeImplFlags">
            <summary>
            Represents a list of flags indicating a member to be automatically implemented by source generator.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.TypeImplFlags.None">
            <summary>
            Indicates no elements will be generated.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.TypeImplFlags.Object_Equals">
            <summary>
            Indicates the method <see cref="M:System.Object.Equals(System.Object)"/> will be generated.
            </summary>
            <seealso cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.TypeImplFlags.Object_GetHashCode">
            <summary>
            Indicates the method <see cref="M:System.Object.GetHashCode"/> will be generated.
            </summary>
            <seealso cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.TypeImplFlags.Object_ToString">
            <summary>
            Indicates the method <see cref="M:System.Object.ToString"/> will be generated.
            </summary>
            <seealso cref="M:System.Object.ToString"/>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.TypeImplFlags.EqualityOperators">
            <summary>
            Indicates the equality operators defined in <see cref="T:System.Numerics.IEqualityOperators`3"/> will be generated.
            </summary>
            <seealso cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
            <seealso cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.TypeImplFlags.ComparisonOperators">
            <summary>
            Indicates the comparison operators defined in <see cref="T:System.Numerics.IComparisonOperators`3"/> will be generated.
            </summary>
            <seealso cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThan(`0,`1)"/>
            <seealso cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThanOrEqual(`0,`1)"/>
            <seealso cref="M:System.Numerics.IComparisonOperators`3.op_LessThan(`0,`1)"/>
            <seealso cref="M:System.Numerics.IComparisonOperators`3.op_LessThanOrEqual(`0,`1)"/>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.TypeImplFlags.TrueAndFalseOperators">
            <summary>
            Indicates operators <see cref="M:System.ILogicalOperators`1.op_True(`0)"/>
            and <see cref="M:System.ILogicalOperators`1.op_False(`0)"/> will be generated.
            </summary>
            <seealso cref="M:System.ILogicalOperators`1.op_True(`0)"/>
            <seealso cref="M:System.ILogicalOperators`1.op_False(`0)"/>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.TypeImplFlags.LogicalNotOperator">
            <summary>
            Indicates operator <see cref="M:System.ILogicalOperators`1.op_LogicalNot(`0)"/> will be generated.
            </summary>
            <seealso cref="M:System.ILogicalOperators`1.op_LogicalNot(`0)"/>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.TypeImplFlags.Equatable">
            <summary>
            Indicates method <see cref="M:System.IEquatable`1.Equals(`0)"/>.
            </summary>
            <seealso cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.TypeImplFlags.Disposable">
            <summary>
            Indicates method <see cref="M:System.IDisposable.Dispose"/>.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.TypeImplFlags.AsyncDisposable">
            <summary>
            Indicates method <see cref="M:System.IAsyncDisposable.DisposeAsync"/>.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.TypeImplFlags.AllObjectMethods">
            <summary>
            Indicates all the methods
            <see cref="M:System.Object.Equals(System.Object)"/>, <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.ToString"/>
            will be generated.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.TypeImplFlags.AllEqualityComparisonOperators">
            <summary>
            Indicates all the operators
            <see cref="T:System.Numerics.IEqualityOperators`3"/> and <see cref="T:System.Numerics.IComparisonOperators`3"/>
            will be generated.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.TypeImplFlags.AllDisposable">
            <summary>
            Indicates all the dispose methods
            <see cref="M:System.IDisposable.Dispose"/> and <see cref="M:System.IAsyncDisposable.DisposeAsync"/> will be generated.
            </summary>
        </member>
        <member name="T:System.EnumExtensions">
            <summary>
            Provides extension methods on <see cref="T:System.Enum"/>.
            </summary>
            <seealso cref="T:System.Enum"/>
        </member>
        <member name="T:System.EnumExtensions.`1">
            <summary>
            Provides extension members on <typeparamref name="T"/>,
            where <typeparamref name="T"/> satisfies <see langword="unmanaged"/>, <see cref="T:System.Enum"/> constraints.
            </summary>
        </member>
        <member name="P:System.EnumExtensions.`1.IsFlag">
            <summary>
            Checks whether the current enumeration field is a flag.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="P:System.EnumExtensions.`1.AllFlags">
            <summary>
            To get all possible flags from a specified enumeration instance.
            </summary>
        </member>
        <member name="M:System.EnumExtensions.`1.GetEnumerator">
            <summary>
            Get all possible flags that the current enumeration field set.
            </summary>
            <returns>All flags.</returns>
            <exception cref="T:System.InvalidOperationException">
            Throws when the type isn't applied the attribute <see cref="T:System.FlagsAttribute"/>.
            </exception>
        </member>
        <member name="T:System.FloatingPointExtensions">
            <summary>
            Provides with extension methods on instances implementing <see cref="T:System.Numerics.IFloatingPoint`1"/>.
            </summary>
            <seealso cref="T:System.Numerics.IFloatingPoint`1"/>
        </member>
        <member name="T:System.FloatingPointExtensions.">
            <summary>
            Provides extension members on <see cref="T:System.Single"/>.
            </summary>
        </member>
        <member name="M:System.FloatingPointExtensions..NearlyEquals(System.Single)">
            <summary>
            Indicates whether the specified value is nearly equals to the current value.
            </summary>
            <param name="other">The other value.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:System.FloatingPointExtensions..NearlyEquals(System.Single,System.Single)">
            <summary>
            Indicates whether the specified value is nearly equals to the current value.
            If the differ of two values to compare is lower than the specified epsilon value,
            the method will return <see langword="true"/>.
            </summary>
            <param name="other">The other value to compare.</param>
            <param name="epsilon">The epsilon value (the minimal differ).</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="T:System.FloatingPointExtensions.">
            <summary>
            Provides extension members on <see cref="T:System.Double"/>.
            </summary>
        </member>
        <member name="M:System.FloatingPointExtensions..NearlyEquals(System.Double)">
            <summary>
            Indicates whether the specified value is nearly equals to the current value.
            </summary>
            <param name="other">The other value.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:System.FloatingPointExtensions..NearlyEquals(System.Double,System.Double)">
            <summary>
            Indicates whether the specified value is nearly equals to the current value.
            If the differ of two values to compare is lower than the specified epsilon value,
            the method will return <see langword="true"/>.
            </summary>
            <param name="other">The other value to compare.</param>
            <param name="epsilon">The epsilon value (the minimal differ).</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="T:System.FloatingPointExtensions.`1">
            <summary>
            Provides extension members on <typeparamref name="T"/>,
            where <typeparamref name="T"/> satisfies <see cref="T:System.Numerics.IFloatingPoint`1"/>, <see cref="T:System.Numerics.IFloatingPointIeee754`1"/> constraints.
            </summary>
        </member>
        <member name="M:System.FloatingPointExtensions.`1.NearlyEquals(`0)">
            <summary>
            Indicates whether the specified value is nearly equals to the current value.
            </summary>
            <param name="other">The other value.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:System.FloatingPointExtensions.`1.NearlyEquals(`0,`0)">
            <summary>
            Indicates whether the specified value is nearly equals to the current value.
            If the differ of two values to compare is lower than the specified epsilon value,
            the method will return <see langword="true"/>.
            </summary>
            <param name="other">The other value to compare.</param>
            <param name="epsilon">The epsilon value (the minimal differ).</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="T:System.IInlineArray`2">
            <summary>
            Represents a type that supports members which are generated automatically if the type is inline array,
            marked <see cref="T:System.Runtime.CompilerServices.InlineArrayAttribute" />.
            </summary>
            <typeparam name="TSelf"><self-type-constraint>
		<para>Indicates the type implementing this interface.</para>
		<para>
			This type doesn't use any extra syntax to constraint such usage, but C# will check for it.
			The type will include a <see langword="where" /> constraint that implements the interface itself
			to declare such "self constraint" usage:
			<code><![CDATA[interface ISelfType<TSelf> where TSelf : ISelfType<TSelf>]]></code>
			In addition, the type should be named <c>TSelf</c> in order to tell type parameters with the others.
		</para>
	</self-type-constraint></typeparam>
            <typeparam name="TElement">The type of each element.</typeparam>
            <seealso cref="T:System.Runtime.CompilerServices.InlineArrayAttribute" />
        </member>
        <member name="P:System.IInlineArray`2.Elements">
            <summary>
            Indicates the elements. For inline arrays, the value is equivalent to <c><see langword="this"/>[..]</c>.
            </summary>
        </member>
        <member name="P:System.IInlineArray`2.InlineArrayLength">
            <summary>
            Indicates the length of inline array configured in <see cref="T:System.Runtime.CompilerServices.InlineArrayAttribute"/>.
            </summary>
        </member>
        <member name="P:System.IInlineArray`2.Item(System.Int32)">
            <summary>
            Returns the reference to the element at the specified index.
            </summary>
            <param name="index">The desired index.</param>
            <returns>The reference to the element.</returns>
            <exception cref="T:System.IndexOutOfRangeException">Throws when the index is out of range.</exception>
        </member>
        <member name="M:System.IInlineArray`2.GetPinnableReference">
            <summary>
            Returns the reference that represents the current instance.
            Generally the method returns <c><see langword="ref"/> <see langword="this"/>[0]</c>.
            </summary>
            <returns>The reference that represents the current instance.</returns>
        </member>
        <member name="M:System.IInlineArray`2.AsSpan">
            <summary>
            Cast the current instance into a <see cref="T:System.Span`1"/> instance.
            </summary>
            <returns>The <see cref="T:System.Span`1"/> instance.</returns>
        </member>
        <member name="M:System.IInlineArray`2.AsReadOnlySpan">
            <summary>
            Cast the current instance into a <see cref="T:System.ReadOnlySpan`1"/> instance.
            </summary>
            <returns>The <see cref="T:System.ReadOnlySpan`1"/> instance.</returns>
        </member>
        <member name="T:System.ILogicalOperators`1">
            <summary>
            Defines a mechanism for computing the logical relation between two instances of type <typeparamref name="TSelf" />.
            </summary>
            <typeparam name="TSelf"><self-type-constraint>
		<para>Indicates the type implementing this interface.</para>
		<para>
			This type doesn't use any extra syntax to constraint such usage, but C# will check for it.
			The type will include a <see langword="where" /> constraint that implements the interface itself
			to declare such "self constraint" usage:
			<code><![CDATA[interface ISelfType<TSelf> where TSelf : ISelfType<TSelf>]]></code>
			In addition, the type should be named <c>TSelf</c> in order to tell type parameters with the others.
		</para>
	</self-type-constraint></typeparam>
        </member>
        <member name="M:System.ILogicalOperators`1.op_True(`0)">
            <summary>
            Determine whether the specified object is determined <see langword="true"/>.
            </summary>
            <param name="value">The value to be determined.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:System.ILogicalOperators`1.op_False(`0)">
            <summary>
            Determine whether the specified object is determined <see langword="false"/>.
            </summary>
            <param name="value">The value to be determined.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:System.ILogicalOperators`1.op_LogicalNot(`0)">
            <summary>
            Negates the current instance, and makes the result to be negated one.
            </summary>
            <param name="value">The value.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="T:System.IndexRangeExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.Index"/> and <see cref="T:System.Range"/> instances.
            </summary>
            <seealso cref="T:System.Index"/>
            <seealso cref="T:System.Range"/>
        </member>
        <member name="T:System.IndexRangeExtensions.">
            <summary>
            Provides extension members on <see cref="T:System.Index"/>.
            </summary>
        </member>
        <member name="M:System.IndexRangeExtensions..Deconstruct(System.Int32@,System.Boolean@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="T:System.IndexRangeExtensions.">
            <summary>
            Provides extension members on <see cref="T:System.Range"/>.
            </summary>
        </member>
        <member name="M:System.IndexRangeExtensions..Deconstruct(System.Index@,System.Index@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="T:System.Int32Extensions">
            <summary>
            Provides with extension methods on <see cref="T:System.Int32"/>.
            </summary>
            <seealso cref="T:System.Int32"/>
        </member>
        <member name="T:System.Int32Extensions.">
            <summary>
            Provides extension members on <see cref="T:System.Int32"/>.
            </summary>
        </member>
        <member name="P:System.Int32Extensions..Seconds">
            <summary>
            Creates a <see cref="T:System.TimeSpan"/> instane using the specified value as seconds.
            </summary>
            <returns>A <see cref="T:System.TimeSpan"/> instance.</returns>
        </member>
        <member name="P:System.Int32Extensions..Milliseconds">
            <summary>
            Creates a <see cref="T:System.TimeSpan"/> instane using the specified value as milliseconds.
            </summary>
            <returns>A <see cref="T:System.TimeSpan"/> instance.</returns>
        </member>
        <member name="T:System.IO.FileExtensions">
            <summary>
            Provides extension methods on <see cref="T:System.IO.File"/>.
            </summary>
            <seealso cref="T:System.IO.File"/>
        </member>
        <member name="F:System.IO.FileExtensions.InvalidCharacters">
            <summary>
            The field for invalid path characters as a file name.
            </summary>
        </member>
        <member name="T:System.IO.FileExtensions.">
            <summary>
            Provides extension members on <see cref="T:System.IO.File"/>.
            </summary>
        </member>
        <member name="M:System.IO.FileExtensions..IsValidFileName(System.String)">
            <summary>
            Determines whether the specified file name is valid.
            </summary>
            <param name="fileName">The file name to be checked.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="T:System.IO.StreamReaderExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.IO.StreamReader"/>.
            </summary>
            <seealso cref="T:System.IO.StreamReader"/>
        </member>
        <member name="T:System.IO.StreamReaderExtensions.">
            <summary>
            Provides extension members on <see cref="T:System.IO.StreamReader"/>.
            </summary>
        </member>
        <member name="P:System.IO.StreamReaderExtensions..EndsWithNewLine">
            <summary>
            Determines whether a file ends with new line character.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
            <exception cref="T:System.ArgumentException">Throws when the stream cannot seek.</exception>
        </member>
        <member name="T:System.Linq.ArrayEnumerable">
            <summary>
            Provides with the LINQ-related methods on type <see cref="T:System.Array"/>, especially for the one-dimensional array.
            </summary>
            <seealso cref="T:System.Array"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.Aggregate``1(``0[],System.Func{``0,``0,``0})">
            <summary>
            Applies an accumulator function over a sequence.
            </summary>
            <typeparam name="TSource">The type of each element.</typeparam>
            <param name="this">An array of elements to be aggregated over.</param>
            <param name="func">The function that aggregates the values.</param>
            <returns>An element accumulated, of type <typeparamref name="TSource"/>.</returns>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.Aggregate``2(``0[],``1,System.Func{``1,``0,``1})">
            <summary>
            Applies an accumulator function over a sequence. The initial value can be set in this method.
            </summary>
            <typeparam name="TSource">The type of each element.</typeparam>
            <typeparam name="TAccumulate">The type of the accumulated values.</typeparam>
            <param name="this">An array of elements to be aggregated over.</param>
            <param name="seed">The initial value.</param>
            <param name="func">The function that aggregates the values.</param>
            <returns>An element accumulated, of type <typeparamref name="TSource"/>.</returns>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.Append``1(``0[],``0)">
            <inheritdoc cref="M:System.Linq.Enumerable.Append``1(System.Collections.Generic.IEnumerable{``0},``0)"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.Prepend``1(``0[],``0)">
            <inheritdoc cref="M:System.Linq.Enumerable.Prepend``1(System.Collections.Generic.IEnumerable{``0},``0)"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.Count``1(``0[],System.Func{``0,System.Boolean})">
            <summary>
            Totals up the number of elements that satisfy the specified condition.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="this">The array.</param>
            <param name="predicate">The condition.</param>
            <returns>The number of elements satisfying the specified condition.</returns>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.CountUnsafe``1(``0[],)">
            <inheritdoc cref="M:System.Linq.ArrayEnumerable.Count``1(``0[],System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.Distinct``1(``0[])">
            <summary>
            Filters duplicate items from an array.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="this">The array to be filtered.</param>
            <returns>A new array of elements that doesn't contain any duplicate items.</returns>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.DistinctBy``2(``0[],System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.DistinctBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.DistinctBy``2(``0[],System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.DistinctBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.Index``1(``0[])">
            <summary>
            Returns a new array instance that contains each element with its corresponding index.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="this">The object to be iterated.</param>
            <returns>A new array instance.</returns>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.Cast``1(System.Object[])">
            <inheritdoc cref="M:System.Linq.Enumerable.Cast``1(System.Collections.IEnumerable)"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.GroupBy``2(``0[],System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.GroupBy``3(``0[],System.Func{``0,``1},System.Func{``0,``2})">
            <inheritdoc cref="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.Join``4(``0[],``1[],System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3})">
            <inheritdoc cref="M:System.Linq.Enumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.Join``4(``0[],``1[],System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})">
            <inheritdoc cref="M:System.Linq.Enumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.GroupJoin``4(``0[],``1[],System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1[],``3})">
            <inheritdoc cref="M:System.Linq.Enumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.GroupJoin``4(``0[],``1[],System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1[],``3},System.Collections.Generic.IEqualityComparer{``2})">
            <inheritdoc cref="M:System.Linq.Enumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3},System.Collections.Generic.IEqualityComparer{``2})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.LeftJoin``4(``0[],``1[],System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3})">
            <inheritdoc cref="M:System.Linq.Providers.ILeftJoinMethod`2.LeftJoin``3(System.Collections.Generic.IEnumerable{``0},System.Func{`1,``1},System.Func{``0,``1},System.Func{`1,``0,``2})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.LeftJoin``4(``0[],``1[],System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})">
            <inheritdoc cref="M:System.Linq.Providers.ILeftJoinMethod`2.LeftJoin``3(System.Collections.Generic.IEnumerable{``0},System.Func{`1,``1},System.Func{``0,``1},System.Func{`1,``0,``2},System.Collections.Generic.IEqualityComparer{``1})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.OrderBy``2(``0[],System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.OrderByDescending``2(``0[],System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.RightJoin``4(``0[],``1[],System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3})">
            <inheritdoc cref="M:System.Linq.Providers.IRightJoinMethod`2.RightJoin``3(System.Collections.Generic.IEnumerable{``0},System.Func{`1,``1},System.Func{``0,``1},System.Func{`1,``0,``2})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.RightJoin``4(``0[],``1[],System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})">
            <inheritdoc cref="M:System.Linq.Providers.IRightJoinMethod`2.RightJoin``3(System.Collections.Generic.IEnumerable{``0},System.Func{`1,``1},System.Func{``0,``1},System.Func{`1,``0,``2},System.Collections.Generic.IEqualityComparer{``1})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.Select``2(``0[],System.Func{``0,``1})">
            <returns>
            An array of <typeparamref name="TResult"/> instances being the result
            of invoking the transform function on each element of <paramref name="source"/>.
            </returns>
            <inheritdoc cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.Select``2(``0[],System.Func{``0,System.Int32,``1})">
            <summary>
            An array of <typeparamref name="TResult"/> instances being the result
            of invoking the transform function on each element of <paramref name="source"/>, and its indices.
            </summary>
            <inheritdoc cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,``1})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.SelectMany``3(``0[],System.Func{``0,System.ReadOnlySpan{``1}},System.Func{``0,``1,``2})">
            <summary>
            Projects each element of a sequence of a collection, flattens the resulting sequence into one sequence,
            and invokes a result selector function on each element therein.
            </summary>
            <returns>
            A same type of collection whose elements are the result of invoking the one-to-many transform function
            <paramref name="collectionSelector"/> on each element of <paramref name="source"/> and then mapping each of those sequence elements
            and their corresponding source element to a result element.
            </returns>
            <inheritdoc cref="M:System.Linq.Enumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.Where``1(``0[],System.Func{``0,System.Boolean})">
            <summary>
            Filters a sequence of values based on a predicate.
            </summary>
            <typeparam name="T">The type of the elements of source.</typeparam>
            <param name="this">An array of <typeparamref name="T"/> instances to filter.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>
            An array of <typeparamref name="T"/> instances that contains elements from the input sequence that satisfy the condition.
            </returns>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.Min``2(``0[],System.Func{``0,``1})">
            <summary>
            Invokes a transform function on each element of a sequence and returns the minimum <typeparamref name="TInterim"/> value.
            </summary>
            <typeparam name="T">The type of the elements of <paramref name="this"/>.</typeparam>
            <typeparam name="TInterim">The type of projected values after the transform function invoked.</typeparam>
            <param name="this">A sequence of values to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The value of type <typeparamref name="TInterim"/> that corresponds to the minimum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.MinUnsafe``2(``0[],)">
            <inheritdoc cref="M:System.Linq.ArrayEnumerable.Min``2(``0[],System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.MinBy``2(``0[],System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.MinBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.MinBy``3(``0[],System.Func{``0,``1},``2)">
            <inheritdoc cref="M:System.Linq.Enumerable.MinBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.Max``2(``0[],System.Func{``0,``1})">
            <summary>
            Invokes a transform function on each element of a sequence and returns the maximum <typeparamref name="TInterim"/> value.
            </summary>
            <typeparam name="T">The type of the elements of <paramref name="this"/>.</typeparam>
            <typeparam name="TInterim">The type of projected values after the transform function invoked.</typeparam>
            <param name="this">A sequence of values to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The value of type <typeparamref name="TInterim"/> that corresponds to the maximum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.MaxUnsafe``2(``0[],)">
            <inheritdoc cref="M:System.Linq.ArrayEnumerable.Max``2(``0[],System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.MaxBy``2(``0[],System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.MaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.MaxBy``3(``0[],System.Func{``0,``1},``2)">
            <inheritdoc cref="M:System.Linq.Enumerable.MaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.OfType``1(System.Object[])">
            <summary>
            Filters the array, removing elements not of type <typeparamref name="TResult"/>.
            </summary>
            <typeparam name="TResult">The type of the target elements.</typeparam>
            <param name="this">The array to be filtered.</param>
            <returns>A list of <typeparamref name="TResult"/> elements.</returns>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.Shuffle``1(``0[])">
            <inheritdoc cref="M:System.Linq.Providers.IShuffleMethod`2.Shuffle"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.Shuffle``1(``0[],System.Random)">
            <inheritdoc cref="M:System.Linq.Providers.IShuffleMethod`2.Shuffle(System.Random)"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.Sum``1(``0[])">
            <summary>
            Sum all elements up and return the result.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="this">The array that contains a list of elements to be calculated.</param>
            <returns>A <typeparamref name="T"/> instance as the result.</returns>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.Sum``2(``0[],System.Func{``0,``1})">
            <summary>
            Computes the sum of the sequence of <typeparamref name="TResult"/> values that are obtained by invoking a transform function
            on each element of the input sequence.
            </summary>
            <typeparam name="T">The type of element of <paramref name="source"/>.</typeparam>
            <typeparam name="TResult">The type of the return value.</typeparam>
            <param name="source">Indicates the source values.</param>
            <param name="selector">The method that projects the value into an instance of type <typeparamref name="TResult"/>.</param>
            <returns>The result value.</returns>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.SumUnsafe``2(``0[],)">
            <inheritdoc cref="M:System.Linq.ArrayEnumerable.Sum``2(``0[],System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.ToLookup``2(``0[],System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.ToLookup``2(``0[],System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.ToLookup``3(``0[],System.Func{``0,``1},System.Func{``0,``2})">
            <inheritdoc cref="M:System.Linq.Enumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.ToLookup``3(``0[],System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.Zip``2(``0[],``1[])">
            <inheritdoc cref="M:System.Linq.Enumerable.Zip``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})"/>
        </member>
        <member name="T:System.Linq.__ImplementedTypes`1">
            <summary>
            This type provides a way to record LINQ methods and interfaces implemented on <typeparamref name="T"/>[].
            This recording will be consumed by future C# <see langword="extension"/> feature
            that may be allowed implementing interface types with some types that I cannot modify them,
            just like <typeparamref name="T"/>[].
            </summary>
            <typeparam name="T">The generic type argument.</typeparam>
        </member>
        <member name="T:System.Linq.ArrayGrouping`2">
            <summary>
            Represents a type that enumerates elements of type <typeparamref name="TSource"/>[],
            grouped by the specified key of type <typeparamref name="TKey"/>.
            </summary>
            <typeparam name="TSource">The type of each element.</typeparam>
            <typeparam name="TKey">The type of the key.</typeparam>
            <param name="elements">Indicates the elements.</param>
            <param name="key">Indicates the key that can compare each element.</param>
        </member>
        <member name="M:System.Linq.ArrayGrouping`2.#ctor(`0[],`1)">
            <summary>
            Represents a type that enumerates elements of type <typeparamref name="TSource"/>[],
            grouped by the specified key of type <typeparamref name="TKey"/>.
            </summary>
            <typeparam name="TSource">The type of each element.</typeparam>
            <typeparam name="TKey">The type of the key.</typeparam>
            <param name="elements">Indicates the elements.</param>
            <param name="key">Indicates the key that can compare each element.</param>
        </member>
        <member name="P:System.Linq.ArrayGrouping`2.System#Linq#IMyGrouping{System#Linq#ArrayGrouping{TSource,TKey},TKey,TSource}#Elements">
            <inheritdoc/>
        </member>
        <member name="P:System.Linq.ArrayGrouping`2.Item(System.Int32)">
            <summary>
            Gets the element at the specified index.
            </summary>
            <param name="index">The desired index.</param>
            <returns>The reference to the element at the specified index.</returns>
        </member>
        <member name="M:System.Linq.ArrayGrouping`2.Equals(System.Linq.ArrayGrouping{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.ArrayGrouping`2.Select``1(System.Func{`0,``0})">
            <summary>
            Projects elements into a new form.
            </summary>
            <typeparam name="TResult">The type of each element in result collection.</typeparam>
            <param name="selector">The selector method that transform the object into new one.</param>
            <returns>A list of <typeparamref name="TResult"/> values.</returns>
        </member>
        <member name="M:System.Linq.ArrayGrouping`2.Where(System.Func{`0,System.Boolean})">
            <summary>
            Filters the collection, only reserving elements satisfying the specified condition.
            </summary>
            <param name="predicate">The condition that checks for each element.</param>
            <returns>A list of <typeparamref name="TSource"/> elements satisfying the condition.</returns>
        </member>
        <member name="M:System.Linq.ArrayGrouping`2.AsReadOnlySpan">
            <inheritdoc cref="M:System.MemoryExtensionsExtensions.AsReadOnlySpan``1(``0[])"/>
        </member>
        <member name="M:System.Linq.ArrayGrouping`2.GetEnumerator">
            <summary>
            Creates an enumerator that can enumerate each element in the source collection.
            </summary>
            <returns>An enumerator instance.</returns>
        </member>
        <member name="M:System.Linq.ArrayGrouping`2.GetPinnableReference">
            <inheritdoc cref="M:System.ReadOnlySpan`1.GetPinnableReference"/>
        </member>
        <member name="M:System.Linq.ArrayGrouping`2.System#Linq#Providers#ISelectMethod{System#Linq#ArrayGrouping{TSource,TKey},TSource}#Select``1(System.Func{`0,``0})">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.ArrayGrouping`2.System#Linq#Providers#IWhereMethod{System#Linq#ArrayGrouping{TSource,TKey},TSource}#Where(System.Func{`0,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="F:System.Linq.ArrayGrouping`2._elements">
            <summary>
            The generated field declaration for parameter <c>elements</c>.
            </summary>
        </member>
        <member name="P:System.Linq.ArrayGrouping`2.Key">
            <summary>
            The generated property declaration for parameter <c>key</c>.
            </summary>
        </member>
        <member name="M:System.Linq.ArrayGrouping`2.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.Linq.ArrayGrouping`2.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:System.Linq.ArrayGrouping`2.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:System.Linq.ArrayGrouping`2.op_Equality(System.Linq.ArrayGrouping{`0,`1},System.Linq.ArrayGrouping{`0,`1})">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:System.Linq.ArrayGrouping`2.op_Inequality(System.Linq.ArrayGrouping{`0,`1},System.Linq.ArrayGrouping{`0,`1})">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:System.Linq.ArrayListEnumerable">
            <summary>
            Provides with extension methods on <see cref="T:System.Collections.ArrayList"/>.
            </summary>
            <seealso cref="T:System.Collections.ArrayList"/>
        </member>
        <member name="M:System.Linq.ArrayListEnumerable.Cast``1(System.Collections.ArrayList)">
            <inheritdoc cref="M:System.Linq.Enumerable.Cast``1(System.Collections.IEnumerable)"/>
        </member>
        <member name="M:System.Linq.ArrayListEnumerable.Select``1(System.Collections.ArrayList,System.Func{System.Object,``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="T:System.Linq.ArrayOrderedEnumerable`1">
            <summary>
            Represents an enumerable instance that is based on an array of type <typeparamref name="T" />.
            </summary>
            <typeparam name="T">Indicates the type of each element.</typeparam>
            <param name="values">Indicates the values.</param>
            <param name="selectors">
            <para>Indicates the selector functions that return <typeparamref name="T" /> instances, to be used as comparison.</para>
            <feature name="scoped-keyword">
			<para>
				The keyword <see langword="scoped" /> means the argument and local variable can only be used inside the method.
				This means you cannot use this variable and argument outside the scope,
				such as <c>new RefStructType(scoped_variable)</c>, <c>return scoped_variable</c> and <c>field = scoped_variable</c>.
				Such expressions may store the <see langword="scoped" /> variables, unsafely expanding the variable's lifecycle.
			</para>
		</feature>
            <target name="parameter">
				<para>
					If a <see langword="ref struct" />-typed parameter is marked as <see langword="params" />,
					it will be implicit-<see langword="scoped" />, which means you must use this variables inside the method.
					Value-storages are not permitted.
				</para>
				<para>
					Use <see cref="T:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute" /> if you want to store variable values.
				</para>
			</target>
            </param>
        </member>
        <member name="M:System.Linq.ArrayOrderedEnumerable`1.#ctor(`0[],System.Func{`0,`0,System.Int32}[])">
            <summary>
            Represents an enumerable instance that is based on an array of type <typeparamref name="T" />.
            </summary>
            <typeparam name="T">Indicates the type of each element.</typeparam>
            <param name="values">Indicates the values.</param>
            <param name="selectors">
            <para>Indicates the selector functions that return <typeparamref name="T" /> instances, to be used as comparison.</para>
            <feature name="scoped-keyword">
			<para>
				The keyword <see langword="scoped" /> means the argument and local variable can only be used inside the method.
				This means you cannot use this variable and argument outside the scope,
				such as <c>new RefStructType(scoped_variable)</c>, <c>return scoped_variable</c> and <c>field = scoped_variable</c>.
				Such expressions may store the <see langword="scoped" /> variables, unsafely expanding the variable's lifecycle.
			</para>
		</feature>
            <target name="parameter">
				<para>
					If a <see langword="ref struct" />-typed parameter is marked as <see langword="params" />,
					it will be implicit-<see langword="scoped" />, which means you must use this variables inside the method.
					Value-storages are not permitted.
				</para>
				<para>
					Use <see cref="T:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute" /> if you want to store variable values.
				</para>
			</target>
            </param>
        </member>
        <member name="P:System.Linq.ArrayOrderedEnumerable`1.Length">
            <summary>
            Indicates the number of elements stored in the collection.
            </summary>
        </member>
        <member name="P:System.Linq.ArrayOrderedEnumerable`1.ArrayOrdered">
            <summary>
            Creates an ordered <typeparamref name="T"/>[] instance.
            </summary>
            <returns>An ordered <typeparamref name="T"/>[] instance, whose value is from the current enumerable instance.</returns>
        </member>
        <member name="P:System.Linq.ArrayOrderedEnumerable`1.System#Collections#Generic#IReadOnlyCollection{T}#Count">
            <inheritdoc/>
        </member>
        <member name="P:System.Linq.ArrayOrderedEnumerable`1.Item(System.Int32)">
            <inheritdoc cref="P:System.ReadOnlySpan`1.Item(System.Int32)"/>
        </member>
        <member name="M:System.Linq.ArrayOrderedEnumerable`1.Select``1(System.Func{`0,``0})">
            <inheritdoc cref="M:System.Linq.Providers.ISelectMethod`2.Select``1(System.Func{`1,``0})"/>
        </member>
        <member name="M:System.Linq.ArrayOrderedEnumerable`1.Where(System.Func{`0,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Providers.IWhereMethod`2.Where(System.Func{`1,System.Boolean})"/>
        </member>
        <member name="M:System.Linq.ArrayOrderedEnumerable`1.OrderBy``1(System.Func{`0,``0})">
            <summary>
            <para>Same as <see cref="M:System.Linq.ArrayOrderedEnumerable`1.ThenBy``1(System.Func{`0,``0})"/>.</para>
            <para><inheritdoc cref="M:System.Linq.SpanOrderedEnumerable`1.OrderBy``1(System.Func{`0,``0})" path="/summary/para[2]"/></para>
            </summary>
            <typeparam name="TKey">The type of key.</typeparam>
            <param name="selector">The selector.</param>
            <returns>A <see cref="T:System.Linq.ArrayOrderedEnumerable`1"/> instance, with a new selector added in the current instance.</returns>
        </member>
        <member name="M:System.Linq.ArrayOrderedEnumerable`1.OrderByDescending``1(System.Func{`0,``0})">
            <summary>
            <para>Same as <see cref="M:System.Linq.ArrayOrderedEnumerable`1.ThenByDescending``1(System.Func{`0,``0})"/>.</para>
            <para><inheritdoc cref="M:System.Linq.SpanOrderedEnumerable`1.OrderBy``1(System.Func{`0,``0})" path="/summary/para[2]"/></para>
            </summary>
            <typeparam name="TKey">The type of key.</typeparam>
            <param name="selector">The selector.</param>
            <returns>A <see cref="T:System.Linq.ArrayOrderedEnumerable`1"/> instance, with a new selector added in the current instance.</returns>
        </member>
        <member name="M:System.Linq.ArrayOrderedEnumerable`1.ThenBy``1(System.Func{`0,``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.ArrayOrderedEnumerable`1.ThenByDescending``1(System.Func{`0,``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.ArrayOrderedEnumerable`1.GroupBy``1(System.Func{`0,``0})">
            <inheritdoc cref="M:System.Linq.Providers.IGroupByMethod`2.GroupBy``1(System.Func{`1,``0})"/>
        </member>
        <member name="M:System.Linq.ArrayOrderedEnumerable`1.GroupBy``2(System.Func{`0,``0},System.Func{`0,``1})">
            <inheritdoc cref="M:System.Linq.Providers.IGroupByMethod`2.GroupBy``2(System.Func{`1,``0},System.Func{`1,``1})"/>
        </member>
        <member name="M:System.Linq.ArrayOrderedEnumerable`1.Aggregate(System.Func{`0,`0,`0})">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.ArrayOrderedEnumerable`1.Aggregate``1(``0,System.Func{``0,`0,``0})">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.ArrayOrderedEnumerable`1.Aggregate``2(``0,System.Func{``0,`0,``0},System.Func{``0,``1})">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.ArrayOrderedEnumerable`1.Slice(System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Linq.Providers.ISliceMethod`2.Slice(System.Int32,System.Int32)"/>
        </member>
        <member name="M:System.Linq.ArrayOrderedEnumerable`1.ToArray">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.ArrayOrderedEnumerable`1.GetEnumerator">
            <inheritdoc cref="M:System.ReadOnlySpan`1.GetEnumerator"/>
        </member>
        <member name="M:System.Linq.ArrayOrderedEnumerable`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.ArrayOrderedEnumerable`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.ArrayOrderedEnumerable`1.System#Linq#Providers#ISliceMethod{System#Linq#ArrayOrderedEnumerable{T},T}#Slice(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.ArrayOrderedEnumerable`1.System#Linq#Providers#IWhereMethod{System#Linq#ArrayOrderedEnumerable{T},T}#Where(System.Func{`0,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.ArrayOrderedEnumerable`1.System#Linq#Providers#IThenByMethod{System#Linq#ArrayOrderedEnumerable{T},T}#ThenBy``1(System.Func{`0,``0})">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.ArrayOrderedEnumerable`1.System#Linq#Providers#IThenByMethod{System#Linq#ArrayOrderedEnumerable{T},T}#ThenByDescending``1(System.Func{`0,``0})">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.ArrayOrderedEnumerable`1.System#Linq#Providers#ISelectMethod{System#Linq#ArrayOrderedEnumerable{T},T}#Select``1(System.Func{`0,``0})">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.ArrayOrderedEnumerable`1.System#Linq#Providers#IGroupByMethod{System#Linq#ArrayOrderedEnumerable{T},T}#GroupBy``1(System.Func{`0,``0})">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.ArrayOrderedEnumerable`1.System#Linq#Providers#IGroupByMethod{System#Linq#ArrayOrderedEnumerable{T},T}#GroupBy``2(System.Func{`0,``0},System.Func{`0,``1})">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.ArrayOrderedEnumerable`1.System#Linq#IOrderedEnumerable{T}#CreateOrderedEnumerable``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0},System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.ArrayOrderedEnumerable`1.Create``1(`0[],System.Func{`0,``0},System.Collections.Generic.IComparer{``0},System.Boolean)">
            <summary>
            Creates an <see cref="T:System.Linq.ArrayOrderedEnumerable`1"/> instance via the specified values.
            </summary>
            <typeparam name="TKey">The type of the key to be compared.</typeparam>
            <param name="values">The values to be used.</param>
            <param name="keySelector">
            The selector method that calculates a <typeparamref name="TKey"/> from each <typeparamref name="T"/> instance.
            </param>
            <param name="comparer">
            A comparable instance that temporarily checks the comparing result of two <typeparamref name="TKey"/> values.
            </param>
            <param name="descending">A <see cref="T:System.Boolean"/> value indicating whether the creation is for descending comparison rule.</param>
            <returns>An <see cref="T:System.Linq.ArrayOrderedEnumerable`1"/> instance.</returns>
        </member>
        <member name="F:System.Linq.ArrayOrderedEnumerable`1._values">
            <summary>
            The generated field declaration for parameter <c>values</c>.
            </summary>
        </member>
        <member name="F:System.Linq.ArrayOrderedEnumerable`1._selectors">
            <summary>
            The generated field declaration for parameter <c>selectors</c>.
            </summary>
        </member>
        <member name="T:System.Linq.DictionaryEnumerable">
            <summary>
            Represents LINQ methods used by <see cref="T:System.Collections.Generic.Dictionary`2"/> instances.
            </summary>
            <seealso cref="T:System.Collections.Generic.Dictionary`2"/>
        </member>
        <member name="M:System.Linq.DictionaryEnumerable.MaxByValue``2(System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
            Get the maximal value in all <see cref="P:System.Collections.Generic.Dictionary`2.Values"/>.
            </summary>
            <typeparam name="TKey">The type of each key.</typeparam>
            <typeparam name="TValue">The type of each value.</typeparam>
            <param name="this">The dictionary instance.</param>
            <returns>An instance of type <typeparamref name="TValue"/> as maximal-valued one.</returns>
            <seealso cref="P:System.Collections.Generic.Dictionary`2.Values"/>
        </member>
        <member name="M:System.Linq.DictionaryEnumerable.MinByValue``2(System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
            Get the minimal value in all <see cref="P:System.Collections.Generic.Dictionary`2.Values"/>.
            </summary>
            <typeparam name="TKey">The type of each key.</typeparam>
            <typeparam name="TValue">The type of each value.</typeparam>
            <param name="this">The dictionary instance.</param>
            <returns>An instance of type <typeparamref name="TValue"/> as minimal-valued one.</returns>
            <seealso cref="P:System.Collections.Generic.Dictionary`2.Values"/>
        </member>
        <member name="M:System.Linq.DictionaryEnumerable.AllKey``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1},System.Func{``0,System.Boolean})">
            <summary>
            Determine whether all keys in the dictionary satisfy the specified condition.
            </summary>
            <typeparam name="TKey">The type of each key.</typeparam>
            <typeparam name="TValue">The type of each value.</typeparam>
            <param name="this">The dictionary to be checked.</param>
            <param name="predicate">The condition to be checked.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:System.Linq.DictionaryEnumerable.AllValue``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1},System.Func{``1,System.Boolean})">
            <summary>
            Determine whether all values in the dictionary satisfy the specified condition.
            </summary>
            <typeparam name="TKey">The type of each key.</typeparam>
            <typeparam name="TValue">The type of each value.</typeparam>
            <param name="this">The dictionary to be checked.</param>
            <param name="predicate">The condition to be checked.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:System.Linq.DictionaryEnumerable.AnyKey``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1},System.Func{``0,System.Boolean})">
            <summary>
            Determine whether at least one key in the dictionary satisfies the specified condition.
            </summary>
            <typeparam name="TKey">The type of each key.</typeparam>
            <typeparam name="TValue">The type of each value.</typeparam>
            <param name="this">The dictionary to be checked.</param>
            <param name="predicate">The condition to be checked.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:System.Linq.DictionaryEnumerable.AnyValue``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1},System.Func{``1,System.Boolean})">
            <summary>
            Determine whether at least one value in the dictionary satisfies the specified condition.
            </summary>
            <typeparam name="TKey">The type of each key.</typeparam>
            <typeparam name="TValue">The type of each value.</typeparam>
            <param name="this">The dictionary to be checked.</param>
            <param name="predicate">The condition to be checked.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:System.Linq.DictionaryEnumerable.ElementAt``2(System.Collections.Generic.Dictionary{``0,``1},System.Int32)">
            <inheritdoc cref="M:System.Linq.Enumerable.ElementAt``1(System.Collections.Generic.IEnumerable{``0},System.Int32)"/>
        </member>
        <member name="M:System.Linq.DictionaryEnumerable.ElementAt``2(System.Collections.Generic.Dictionary{``0,``1},System.Index)">
            <inheritdoc cref="M:System.Linq.Enumerable.ElementAt``1(System.Collections.Generic.IEnumerable{``0},System.Index)"/>
        </member>
        <member name="T:System.Linq.Enumerators.AnonymousSpanEnumerator`1">
            <summary>
            Represents an enumerator that can be used in anonymous span iteration cases.
            </summary>
            <typeparam name="T">The type of elements.</typeparam>
            <param name="elements">Indicates the elements.</param>
        </member>
        <member name="M:System.Linq.Enumerators.AnonymousSpanEnumerator`1.#ctor(System.ReadOnlySpan{`0})">
            <summary>
            Represents an enumerator that can be used in anonymous span iteration cases.
            </summary>
            <typeparam name="T">The type of elements.</typeparam>
            <param name="elements">Indicates the elements.</param>
        </member>
        <member name="F:System.Linq.Enumerators.AnonymousSpanEnumerator`1._index">
            <summary>
            Indicates the index.
            </summary>
        </member>
        <member name="P:System.Linq.Enumerators.AnonymousSpanEnumerator`1.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current"/>
        </member>
        <member name="P:System.Linq.Enumerators.AnonymousSpanEnumerator`1.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="P:System.Linq.Enumerators.AnonymousSpanEnumerator`1.System#Collections#Generic#IEnumerator{T}#Current">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Enumerators.AnonymousSpanEnumerator`1.GetEnuemrator">
            <inheritdoc cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
        </member>
        <member name="M:System.Linq.Enumerators.AnonymousSpanEnumerator`1.MoveNext">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Enumerators.AnonymousSpanEnumerator`1.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Enumerators.AnonymousSpanEnumerator`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Enumerators.AnonymousSpanEnumerator`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="F:System.Linq.Enumerators.AnonymousSpanEnumerator`1._elements">
            <summary>
            The generated field declaration for parameter <c>elements</c>.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerators.AnonymousSpanEnumerator`1.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.Linq.Enumerators.AnonymousSpanEnumerator`1.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:System.Linq.Enumerators.AnonymousSpanEnumerator`1.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:System.Linq.Enumerators.AnonymousSpanEnumerator`1.System#IDisposable#Dispose">
            <inheritdoc/>
            <exception cref="T:System.ObjectDisposedException">Throws when the object had already been disposed.</exception>
        </member>
        <member name="T:System.Linq.Enumerators.ComplexValueTupleEnumerator`2">
            <summary>
            Defines a complex value tuple enumerator.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <typeparam name="TRest">The type that encapsulate for a list of rest elements.</typeparam>
            <param name="tuple">The tuple.</param>
        </member>
        <member name="M:System.Linq.Enumerators.ComplexValueTupleEnumerator`2.#ctor(System.ValueTuple{`0,`0,`0,`0,`0,`0,`0,`1})">
            <summary>
            Defines a complex value tuple enumerator.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <typeparam name="TRest">The type that encapsulate for a list of rest elements.</typeparam>
            <param name="tuple">The tuple.</param>
        </member>
        <member name="F:System.Linq.Enumerators.ComplexValueTupleEnumerator`2._values">
            <summary>
            Indicates the internal values to be iterated.
            </summary>
        </member>
        <member name="F:System.Linq.Enumerators.ComplexValueTupleEnumerator`2._index">
            <summary>
            Indicates the index.
            </summary>
        </member>
        <member name="P:System.Linq.Enumerators.ComplexValueTupleEnumerator`2.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current"/>
        </member>
        <member name="P:System.Linq.Enumerators.ComplexValueTupleEnumerator`2.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="P:System.Linq.Enumerators.ComplexValueTupleEnumerator`2.System#Collections#Generic#IEnumerator{T}#Current">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Enumerators.ComplexValueTupleEnumerator`2.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:System.Linq.Enumerators.ComplexValueTupleEnumerator`2.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Enumerators.ComplexValueTupleEnumerator`2.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.Linq.Enumerators.ComplexValueTupleEnumerator`2.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:System.Linq.Enumerators.ComplexValueTupleEnumerator`2.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:System.Linq.Enumerators.ComplexValueTupleEnumerator`2.System#IDisposable#Dispose">
            <inheritdoc/>
            <exception cref="T:System.ObjectDisposedException">Throws when the object had already been disposed.</exception>
        </member>
        <member name="T:System.Linq.Enumerators.DelegateEnumerator`1">
            <summary>
            Represents an enumerator type that can iterate on each function or action on a complex delegate object
            of type <typeparamref name="TDelegate"/>.
            </summary>
            <typeparam name="TDelegate">The type of each function or action.</typeparam>
            <param name="value">The complex delegate object to be iterated.</param>
        </member>
        <member name="M:System.Linq.Enumerators.DelegateEnumerator`1.#ctor(`0)">
            <summary>
            Represents an enumerator type that can iterate on each function or action on a complex delegate object
            of type <typeparamref name="TDelegate"/>.
            </summary>
            <typeparam name="TDelegate">The type of each function or action.</typeparam>
            <param name="value">The complex delegate object to be iterated.</param>
        </member>
        <member name="F:System.Linq.Enumerators.DelegateEnumerator`1._enumerator">
            <summary>
            Indicates the backing enumerator.
            </summary>
        </member>
        <member name="P:System.Linq.Enumerators.DelegateEnumerator`1.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current"/>
        </member>
        <member name="P:System.Linq.Enumerators.DelegateEnumerator`1.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Enumerators.DelegateEnumerator`1.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:System.Linq.Enumerators.DelegateEnumerator`1.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="P:System.Linq.Enumerators.DelegateEnumerator`1.Value">
            <summary>
            The generated property declaration for parameter <c>value</c>.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerators.DelegateEnumerator`1.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.Linq.Enumerators.DelegateEnumerator`1.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:System.Linq.Enumerators.DelegateEnumerator`1.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:System.Linq.Enumerators.DelegateEnumerator`1.System#IDisposable#Dispose">
            <inheritdoc/>
            <exception cref="T:System.ObjectDisposedException">Throws when the object had already been disposed.</exception>
        </member>
        <member name="T:System.Linq.Enumerators.EnumFlagsEnumerator`1">
            <summary>
            Defines an enumerator that iterates the possible fields of an enumeration type.
            </summary>
            <typeparam name="T">
            The type of the enumeration type, that is marked the attribute <see cref="T:System.FlagsAttribute"/>.
            </typeparam>
            <param name="baseField">Indicates the base field.</param>
        </member>
        <member name="M:System.Linq.Enumerators.EnumFlagsEnumerator`1.#ctor(`0)">
            <summary>
            Defines an enumerator that iterates the possible fields of an enumeration type.
            </summary>
            <typeparam name="T">
            The type of the enumeration type, that is marked the attribute <see cref="T:System.FlagsAttribute"/>.
            </typeparam>
            <param name="baseField">Indicates the base field.</param>
        </member>
        <member name="F:System.Linq.Enumerators.EnumFlagsEnumerator`1._fields">
            <summary>
            Indicates the fields of the type to iterate.
            </summary>
        </member>
        <member name="F:System.Linq.Enumerators.EnumFlagsEnumerator`1._index">
            <summary>
            Indicates the current index being iterated.
            </summary>
        </member>
        <member name="P:System.Linq.Enumerators.EnumFlagsEnumerator`1.Current">
            <inheritdoc cref="P:System.Collections.IEnumerator.Current"/>
        </member>
        <member name="P:System.Linq.Enumerators.EnumFlagsEnumerator`1.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="P:System.Linq.Enumerators.EnumFlagsEnumerator`1.SizeOfT">
            <summary>
            Indicates the size of <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerators.EnumFlagsEnumerator`1.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:System.Linq.Enumerators.EnumFlagsEnumerator`1.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="F:System.Linq.Enumerators.EnumFlagsEnumerator`1._baseField">
            <summary>
            The generated field declaration for parameter <c>baseField</c>.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerators.EnumFlagsEnumerator`1.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.Linq.Enumerators.EnumFlagsEnumerator`1.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:System.Linq.Enumerators.EnumFlagsEnumerator`1.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:System.Linq.Enumerators.EnumFlagsEnumerator`1.System#IDisposable#Dispose">
            <inheritdoc/>
            <exception cref="T:System.ObjectDisposedException">Throws when the object had already been disposed.</exception>
        </member>
        <member name="T:System.Linq.Enumerators.PairEnumerator`1">
            <summary>
            Represents an enumerator that can iterate on elements, paired.
            </summary>
            <typeparam name="T">The type of each element to be iterated.</typeparam>
            <param name="sequence">The sequence value.</param>
        </member>
        <member name="M:System.Linq.Enumerators.PairEnumerator`1.#ctor(System.ReadOnlySpan{`0})">
            <summary>
            Represents an enumerator that can iterate on elements, paired.
            </summary>
            <typeparam name="T">The type of each element to be iterated.</typeparam>
            <param name="sequence">The sequence value.</param>
        </member>
        <member name="F:System.Linq.Enumerators.PairEnumerator`1._index">
            <summary>
            Indicates the index.
            </summary>
        </member>
        <member name="P:System.Linq.Enumerators.PairEnumerator`1.Current">
            <inheritdoc cref="P:System.Collections.IEnumerator.Current"/>
        </member>
        <member name="P:System.Linq.Enumerators.PairEnumerator`1.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Enumerators.PairEnumerator`1.GetEnumerator">
            <inheritdoc cref="M:System.Linq.Enumerators.ReverseEnumerator`1.GetEnumerator"/>
        </member>
        <member name="M:System.Linq.Enumerators.PairEnumerator`1.Cast``2">
            <summary>
            Creates a <see cref="T:System.Linq.Enumerators.PairEnumeratorCasted`3"/> instance that supports down-casting
            for paired elements.
            </summary>
            <typeparam name="TFirst">
            <inheritdoc cref="T:System.Linq.Enumerators.PairEnumeratorCasted`3" path="/typeparam[@name='TFirst']"/>
            </typeparam>
            <typeparam name="TSecond">
            <inheritdoc cref="T:System.Linq.Enumerators.PairEnumeratorCasted`3" path="/typeparam[@name='TSecond']"/>
            </typeparam>
            <returns>A <see cref="T:System.Linq.Enumerators.PairEnumeratorCasted`3"/> instance.</returns>
        </member>
        <member name="M:System.Linq.Enumerators.PairEnumerator`1.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:System.Linq.Enumerators.PairEnumerator`1.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="F:System.Linq.Enumerators.PairEnumerator`1._sequence">
            <summary>
            The generated field declaration for parameter <c>sequence</c>.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerators.PairEnumerator`1.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.Linq.Enumerators.PairEnumerator`1.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:System.Linq.Enumerators.PairEnumerator`1.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:System.Linq.Enumerators.PairEnumerator`1.System#IDisposable#Dispose">
            <inheritdoc/>
            <exception cref="T:System.ObjectDisposedException">Throws when the object had already been disposed.</exception>
        </member>
        <member name="T:System.Linq.Enumerators.PairEnumeratorCasted`3">
            <inheritdoc cref="T:System.Linq.Enumerators.PairEnumerator`1"/>
            <typeparam name="T">The type of each element to be iterated.</typeparam>
            <typeparam name="TFirst">The type of the first element in a pair.</typeparam>
            <typeparam name="TSecond">The type of the second element in a pair.</typeparam>
        </member>
        <member name="M:System.Linq.Enumerators.PairEnumeratorCasted`3.#ctor(System.ReadOnlySpan{`0})">
            <inheritdoc cref="T:System.Linq.Enumerators.PairEnumerator`1"/>
            <typeparam name="T">The type of each element to be iterated.</typeparam>
            <typeparam name="TFirst">The type of the first element in a pair.</typeparam>
            <typeparam name="TSecond">The type of the second element in a pair.</typeparam>
        </member>
        <member name="F:System.Linq.Enumerators.PairEnumeratorCasted`3._index">
            <summary>
            Indicates the index.
            </summary>
        </member>
        <member name="P:System.Linq.Enumerators.PairEnumeratorCasted`3.Current">
            <inheritdoc cref="P:System.Collections.IEnumerator.Current"/>
        </member>
        <member name="P:System.Linq.Enumerators.PairEnumeratorCasted`3.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Enumerators.PairEnumeratorCasted`3.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:System.Linq.Enumerators.PairEnumeratorCasted`3.GetEnumerator">
            <inheritdoc cref="M:System.Linq.Enumerators.ReverseEnumerator`1.GetEnumerator"/>
        </member>
        <member name="M:System.Linq.Enumerators.PairEnumeratorCasted`3.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="F:System.Linq.Enumerators.PairEnumeratorCasted`3._sequence">
            <summary>
            The generated field declaration for parameter <c>sequence</c>.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerators.PairEnumeratorCasted`3.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.Linq.Enumerators.PairEnumeratorCasted`3.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:System.Linq.Enumerators.PairEnumeratorCasted`3.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:System.Linq.Enumerators.PairEnumeratorCasted`3.System#IDisposable#Dispose">
            <inheritdoc/>
            <exception cref="T:System.ObjectDisposedException">Throws when the object had already been disposed.</exception>
        </member>
        <member name="T:System.Linq.Enumerators.ReadOnlyMemoryEnumerator`1">
            <summary>
            Represents an enumerator that iterates on each element of type <typeparamref name="T"/> inside a <see cref="T:System.ReadOnlyMemory`1"/>.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <seealso cref="T:System.ReadOnlyMemory`1"/>
        </member>
        <member name="M:System.Linq.Enumerators.ReadOnlyMemoryEnumerator`1.#ctor(System.ReadOnlyMemory{`0})">
            <summary>
            Represents an enumerator that iterates on each element of type <typeparamref name="T"/> inside a <see cref="T:System.ReadOnlyMemory`1"/>.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <seealso cref="T:System.ReadOnlyMemory`1"/>
        </member>
        <member name="F:System.Linq.Enumerators.ReadOnlyMemoryEnumerator`1._span">
            <summary>
            Indicates the span to the memory.
            </summary>
        </member>
        <member name="F:System.Linq.Enumerators.ReadOnlyMemoryEnumerator`1._index">
            <summary>
            Indicates the index that is currently iterated.
            </summary>
        </member>
        <member name="P:System.Linq.Enumerators.ReadOnlyMemoryEnumerator`1.Current">
            <summary>
            Indicates the current instance.
            </summary>
        </member>
        <member name="P:System.Linq.Enumerators.ReadOnlyMemoryEnumerator`1.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="P:System.Linq.Enumerators.ReadOnlyMemoryEnumerator`1.System#Collections#Generic#IEnumerator{T}#Current">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Enumerators.ReadOnlyMemoryEnumerator`1.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:System.Linq.Enumerators.ReadOnlyMemoryEnumerator`1.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Enumerators.ReadOnlyMemoryEnumerator`1.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.Linq.Enumerators.ReadOnlyMemoryEnumerator`1.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:System.Linq.Enumerators.ReadOnlyMemoryEnumerator`1.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:System.Linq.Enumerators.ReadOnlyMemoryEnumerator`1.System#IDisposable#Dispose">
            <inheritdoc/>
            <exception cref="T:System.ObjectDisposedException">Throws when the object had already been disposed.</exception>
        </member>
        <member name="T:System.Linq.Enumerators.ReverseEnumerator`1">
            <summary>
            Represents a reverse enumerator.
            </summary>
            <typeparam name="T">The type of the element.</typeparam>
            <param name="sequence">The internal sequence to be iterated.</param>
        </member>
        <member name="M:System.Linq.Enumerators.ReverseEnumerator`1.#ctor(System.ReadOnlySpan{`0})">
            <summary>
            Represents a reverse enumerator.
            </summary>
            <typeparam name="T">The type of the element.</typeparam>
            <param name="sequence">The internal sequence to be iterated.</param>
        </member>
        <member name="F:System.Linq.Enumerators.ReverseEnumerator`1._index">
            <summary>
            Indicates the current index.
            </summary>
        </member>
        <member name="P:System.Linq.Enumerators.ReverseEnumerator`1.Length">
            <summary>
            Indicates the length to the sequence.
            </summary>
        </member>
        <member name="P:System.Linq.Enumerators.ReverseEnumerator`1.Current">
            <inheritdoc cref="P:System.Collections.IEnumerator.Current"/>
        </member>
        <member name="P:System.Linq.Enumerators.ReverseEnumerator`1.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="P:System.Linq.Enumerators.ReverseEnumerator`1.System#Collections#Generic#IEnumerator{T}#Current">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Enumerators.ReverseEnumerator`1.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:System.Linq.Enumerators.ReverseEnumerator`1.GetEnumerator">
            <summary>
            Provides the basic iteration rule that iterates on each element using the current enumerator.
            </summary>
            <returns>The current enumerator.</returns>
        </member>
        <member name="M:System.Linq.Enumerators.ReverseEnumerator`1.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="F:System.Linq.Enumerators.ReverseEnumerator`1._sequence">
            <summary>
            The generated field declaration for parameter <c>sequence</c>.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerators.ReverseEnumerator`1.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.Linq.Enumerators.ReverseEnumerator`1.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:System.Linq.Enumerators.ReverseEnumerator`1.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:System.Linq.Enumerators.ReverseEnumerator`1.System#IDisposable#Dispose">
            <inheritdoc/>
            <exception cref="T:System.ObjectDisposedException">Throws when the object had already been disposed.</exception>
        </member>
        <member name="T:System.Linq.Enumerators.ValueTupleEnumerator`1">
            <summary>
            Provides with a mechanism to iterate a value tuple instance of a uniform type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The uniform type of a pair of instances.</typeparam>
        </member>
        <member name="F:System.Linq.Enumerators.ValueTupleEnumerator`1._limit">
            <summary>
            Indicates the maximum number of values to be iterated.
            </summary>
        </member>
        <member name="F:System.Linq.Enumerators.ValueTupleEnumerator`1._innerTuple">
            <summary>
            Indicates the internal tuple.
            </summary>
        </member>
        <member name="F:System.Linq.Enumerators.ValueTupleEnumerator`1._index">
            <summary>
            Indicates the index.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerators.ValueTupleEnumerator`1.#ctor(System.ValueTuple{`0,`0}@)">
            <summary>
            Initializes a <see cref="T:System.Linq.Enumerators.ValueTupleEnumerator`1"/> instance via a <see cref="T:System.ValueTuple`2"/> instance.
            </summary>
            <param name="pair">A pair instance to be iterated.</param>
        </member>
        <member name="M:System.Linq.Enumerators.ValueTupleEnumerator`1.#ctor(System.ValueTuple{`0,`0,`0}@)">
            <summary>
            Initializes a <see cref="T:System.Linq.Enumerators.ValueTupleEnumerator`1"/> instance via a <see cref="T:System.ValueTuple`3"/> instance.
            </summary>
            <param name="triple">A triple instance to be iterated.</param>
        </member>
        <member name="M:System.Linq.Enumerators.ValueTupleEnumerator`1.#ctor(System.ValueTuple{`0,`0,`0,`0}@)">
            <summary>
            Initializes a <see cref="T:System.Linq.Enumerators.ValueTupleEnumerator`1"/> instance via a <see cref="T:System.ValueTuple`4"/> instance.
            </summary>
            <param name="quadruple">A quadruple instance to be iterated.</param>
        </member>
        <member name="M:System.Linq.Enumerators.ValueTupleEnumerator`1.#ctor(System.ValueTuple{`0,`0,`0,`0,`0}@)">
            <summary>
            Initializes a <see cref="T:System.Linq.Enumerators.ValueTupleEnumerator`1"/> instance via a <see cref="T:System.ValueTuple`5"/> instance.
            </summary>
            <param name="quintuple">A quintuple instance to be iterated.</param>
        </member>
        <member name="M:System.Linq.Enumerators.ValueTupleEnumerator`1.#ctor(System.ValueTuple{`0,`0,`0,`0,`0,`0}@)">
            <summary>
            Initializes a <see cref="T:System.Linq.Enumerators.ValueTupleEnumerator`1"/> instance via a <see cref="T:System.ValueTuple`6"/> instance.
            </summary>
            <param name="sextuple">A sextuple instance to be iterated.</param>
        </member>
        <member name="M:System.Linq.Enumerators.ValueTupleEnumerator`1.#ctor(System.ValueTuple{`0,`0,`0,`0,`0,`0,`0}@)">
            <summary>
            Initializes a <see cref="T:System.Linq.Enumerators.ValueTupleEnumerator`1"/> instance via a <see cref="T:System.ValueTuple`7"/> instance.
            </summary>
            <param name="septuple">A septuple instance to be iterated.</param>
        </member>
        <member name="P:System.Linq.Enumerators.ValueTupleEnumerator`1.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current"/>
        </member>
        <member name="P:System.Linq.Enumerators.ValueTupleEnumerator`1.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="P:System.Linq.Enumerators.ValueTupleEnumerator`1.System#Collections#Generic#IEnumerator{T}#Current">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Enumerators.ValueTupleEnumerator`1.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:System.Linq.Enumerators.ValueTupleEnumerator`1.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Enumerators.ValueTupleEnumerator`1.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.Linq.Enumerators.ValueTupleEnumerator`1.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:System.Linq.Enumerators.ValueTupleEnumerator`1.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:System.Linq.Enumerators.ValueTupleEnumerator`1.System#IDisposable#Dispose">
            <inheritdoc/>
            <exception cref="T:System.ObjectDisposedException">Throws when the object had already been disposed.</exception>
        </member>
        <member name="T:System.Linq.EnumFlagsEnumerable">
            <summary>
            Provides with some extension methods for enumeration types.
            </summary>
        </member>
        <member name="M:System.Linq.EnumFlagsEnumerable.Select``2(``0,System.Func{``0,``1})">
            <summary>
            Try to get all <typeparamref name="T"/> elements as flags stored in argument <paramref name="this"/>,
            and convert them into an array of <typeparamref name="TResult"/> instances via specified argument <paramref name="selector"/>,
            then return the array.
            </summary>
            <typeparam name="T">The type of the enumeration.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="this">The enumeration type field.</param>
            <param name="selector">The selector that can convert the enumeration field into the target-typed instance.</param>
            <returns>An array of <typeparamref name="TResult"/> elements.</returns>
            <exception cref="T:System.InvalidOperationException">
            Throws when the enumeration type is not marked <see cref="T:System.FlagsAttribute"/>.
            </exception>
        </member>
        <member name="T:System.Linq.HashSetEnumerable">
            <summary>
            Represents LINQ methods used by <see cref="T:System.Collections.Generic.HashSet`1"/> instances.
            </summary>
            <seealso cref="T:System.Collections.Generic.HashSet`1"/>
        </member>
        <member name="M:System.Linq.HashSetEnumerable.First``1(System.Collections.Generic.HashSet{``0})">
            <summary>
            Indicates the first element of the collection.
            </summary>
            <typeparam name="TSource">The type of each element.</typeparam>
            <param name="source">The collection.</param>
            <returns>The first element of the collection.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when the collection contains no elements.</exception>
        </member>
        <member name="M:System.Linq.HashSetEnumerable.First``1(System.Collections.Generic.HashSet{``0},System.Func{``0,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Enumerable.First``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:System.Linq.HashSetEnumerable.FirstOrDefault``1(System.Collections.Generic.HashSet{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:System.Linq.HashSetEnumerable.FirstOrDefault``1(System.Collections.Generic.HashSet{``0},System.Func{``0,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="T:System.Linq.IMyGrouping`3">
            <summary>
            Represents a grouping data structure for LINQ grouping methods.
            </summary>
            <typeparam name="TSelf"><self-type-constraint>
		<para>Indicates the type implementing this interface.</para>
		<para>
			This type doesn't use any extra syntax to constraint such usage, but C# will check for it.
			The type will include a <see langword="where" /> constraint that implements the interface itself
			to declare such "self constraint" usage:
			<code><![CDATA[interface ISelfType<TSelf> where TSelf : ISelfType<TSelf>]]></code>
			In addition, the type should be named <c>TSelf</c> in order to tell type parameters with the others.
		</para>
	</self-type-constraint></typeparam>
            <typeparam name="TKey">Indicates the type of keys that group values.</typeparam>
            <typeparam name="TElement">The type of each element.</typeparam>
        </member>
        <member name="P:System.Linq.IMyGrouping`3.Elements">
            <summary>
            Indicates the backing elements.
            </summary>
        </member>
        <member name="P:System.Linq.IMyGrouping`3.System#Collections#Generic#IReadOnlyCollection{TElement}#Count">
            <inheritdoc/>
        </member>
        <member name="P:System.Linq.IMyGrouping`3.Item(System.Int32)">
            <summary>
            Gets the element at the specified index.
            </summary>
            <param name="index">The desired index.</param>
            <returns>The reference to the element at the specified index.</returns>
        </member>
        <member name="M:System.Linq.IMyGrouping`3.GetPinnableReference">
            <inheritdoc cref="M:System.ReadOnlySpan`1.GetPinnableReference"/>
        </member>
        <member name="M:System.Linq.IMyGrouping`3.GetEnumerator">
            <summary>
            Creates an enumerator that can enumerate each element in the source collection.
            </summary>
            <returns>An enumerator instance.</returns>
        </member>
        <member name="M:System.Linq.IMyGrouping`3.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.IMyGrouping`3.System#Collections#Generic#IEnumerable{TElement}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="T:System.Linq.Iterators.ArrayAppendIterator`1">
            <summary>
            Represents an enumerator that will be created after <see cref="M:System.Linq.ArrayEnumerable.Append``1(``0[],``0)"/>.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="_array">The array.</param>
            <param name="value">The final element to be iterated.</param>
            <seealso cref="M:System.Linq.ArrayEnumerable.Append``1(``0[],``0)"/>
        </member>
        <member name="M:System.Linq.Iterators.ArrayAppendIterator`1.#ctor(`0[],`0)">
            <summary>
            Represents an enumerator that will be created after <see cref="M:System.Linq.ArrayEnumerable.Append``1(``0[],``0)"/>.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="_array">The array.</param>
            <param name="value">The final element to be iterated.</param>
            <seealso cref="M:System.Linq.ArrayEnumerable.Append``1(``0[],``0)"/>
        </member>
        <member name="F:System.Linq.Iterators.ArrayAppendIterator`1._index">
            <summary>
            Indicates the index.
            </summary>
        </member>
        <member name="P:System.Linq.Iterators.ArrayAppendIterator`1.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current"/>
        </member>
        <member name="P:System.Linq.Iterators.ArrayAppendIterator`1.System#Collections#Generic#IEnumerator{T}#Current">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Iterators.ArrayAppendIterator`1.MoveNext">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Iterators.ArrayAppendIterator`1.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
        </member>
        <member name="F:System.Linq.Iterators.ArrayAppendIterator`1._value">
            <summary>
            The generated field declaration for parameter <c>value</c>.
            </summary>
        </member>
        <member name="T:System.Linq.Iterators.ArrayPrependIterator`1">
            <summary>
            Represents an enumerator that will be created after <see cref="M:System.Linq.ArrayEnumerable.Prepend``1(``0[],``0)"/>.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="_array">The array.</param>
            <param name="value">The final element to be iterated.</param>
            <seealso cref="M:System.Linq.ArrayEnumerable.Prepend``1(``0[],``0)"/>
        </member>
        <member name="M:System.Linq.Iterators.ArrayPrependIterator`1.#ctor(`0[],`0)">
            <summary>
            Represents an enumerator that will be created after <see cref="M:System.Linq.ArrayEnumerable.Prepend``1(``0[],``0)"/>.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="_array">The array.</param>
            <param name="value">The final element to be iterated.</param>
            <seealso cref="M:System.Linq.ArrayEnumerable.Prepend``1(``0[],``0)"/>
        </member>
        <member name="F:System.Linq.Iterators.ArrayPrependIterator`1._index">
            <summary>
            Indicates the index.
            </summary>
        </member>
        <member name="P:System.Linq.Iterators.ArrayPrependIterator`1.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current"/>
        </member>
        <member name="P:System.Linq.Iterators.ArrayPrependIterator`1.System#Collections#Generic#IEnumerator{T}#Current">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Iterators.ArrayPrependIterator`1.MoveNext">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Iterators.ArrayPrependIterator`1.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
        </member>
        <member name="F:System.Linq.Iterators.ArrayPrependIterator`1._value">
            <summary>
            The generated field declaration for parameter <c>value</c>.
            </summary>
        </member>
        <member name="T:System.Linq.Iterators.IIterator`2">
            <summary>
            Represents an iterator type.
            </summary>
            <typeparam name="TSelf"><self-type-constraint>
		<para>Indicates the type implementing this interface.</para>
		<para>
			This type doesn't use any extra syntax to constraint such usage, but C# will check for it.
			The type will include a <see langword="where" /> constraint that implements the interface itself
			to declare such "self constraint" usage:
			<code><![CDATA[interface ISelfType<TSelf> where TSelf : ISelfType<TSelf>]]></code>
			In addition, the type should be named <c>TSelf</c> in order to tell type parameters with the others.
		</para>
	</self-type-constraint></typeparam>
            <typeparam name="T">The type of each element.</typeparam>
        </member>
        <member name="P:System.Linq.Iterators.IIterator`2.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Iterators.IIterator`2.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
        </member>
        <member name="M:System.Linq.Iterators.IIterator`2.System#IDisposable#Dispose">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Iterators.IIterator`2.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Iterators.IIterator`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Iterators.IIterator`2.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="T:System.Linq.LinkedListEnumerable">
            <summary>
            Represents LINQ methods used by <see cref="T:System.Collections.Generic.LinkedList`1"/>.
            </summary>
            <seealso cref="T:System.Collections.Generic.LinkedList`1"/>
        </member>
        <member name="M:System.Linq.LinkedListEnumerable.Select``2(System.Collections.Generic.LinkedList{``0},System.Func{``0,``1})">
            <summary>
            Projects each element into a new form.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <typeparam name="TResult">The type of the transformed value.</typeparam>
            <param name="this">A <see cref="T:System.Collections.Generic.LinkedList`1"/> instance.</param>
            <param name="selector">The function to transform items.</param>
            <returns>The projected values.</returns>
        </member>
        <member name="M:System.Linq.LinkedListEnumerable.Select``2(System.Linq.LinkedListReversed{``0},System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.LinkedListEnumerable.Select``2(System.Collections.Generic.LinkedList{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.LinkedListEnumerable.Reverse``1(System.Collections.Generic.LinkedList{``0})">
            <summary>
            Reverse the enumeration on <see cref="T:System.Collections.Generic.LinkedList`1"/>.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="this">A <see cref="T:System.Collections.Generic.LinkedList`1"/> instance.</param>
            <returns>The reversed enumerator-provider instance.</returns>
        </member>
        <member name="T:System.Linq.LinkedListReversed`1">
            <summary>
            Represent an enumerator type that reversely enumerates on each element in a <see cref="T:System.Collections.Generic.LinkedList`1"/>.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="baseList">The base list.</param>
            <seealso cref="T:System.Collections.Generic.LinkedList`1"/>
        </member>
        <member name="M:System.Linq.LinkedListReversed`1.#ctor(System.Collections.Generic.LinkedList{`0})">
            <summary>
            Represent an enumerator type that reversely enumerates on each element in a <see cref="T:System.Collections.Generic.LinkedList`1"/>.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="baseList">The base list.</param>
            <seealso cref="T:System.Collections.Generic.LinkedList`1"/>
        </member>
        <member name="P:System.Linq.LinkedListReversed`1.Count">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.LinkedListReversed`1.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
        </member>
        <member name="M:System.Linq.LinkedListReversed`1.Reverse">
            <summary>
            Reverses the enumeration on each element. The method will directly return the base <see cref="T:System.Collections.Generic.LinkedList`1"/> instance.
            </summary>
            <returns>The <see cref="T:System.Collections.Generic.LinkedList`1"/> instance.</returns>
        </member>
        <member name="T:System.Linq.LinkedListReversed`1.Enumerator">
            <summary>
            Indicates the enumerator type of the <see cref="T:System.Linq.LinkedListReversed`1"/> instance.
            </summary>
        </member>
        <member name="M:System.Linq.LinkedListReversed`1.Enumerator.#ctor(System.Collections.Generic.LinkedList{`0})">
            <summary>
            Indicates the enumerator type of the <see cref="T:System.Linq.LinkedListReversed`1"/> instance.
            </summary>
        </member>
        <member name="F:System.Linq.LinkedListReversed`1.Enumerator._node">
            <summary>
            Indicates the last node.
            </summary>
        </member>
        <member name="P:System.Linq.LinkedListReversed`1.Enumerator.Current">
            <inheritdoc cref="P:System.Collections.IEnumerator.Current"/>
        </member>
        <member name="P:System.Linq.LinkedListReversed`1.Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="P:System.Linq.LinkedListReversed`1.Enumerator.System#Collections#Generic#IEnumerator{T}#Current">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.LinkedListReversed`1.Enumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:System.Linq.LinkedListReversed`1.Enumerator.System#IDisposable#Dispose">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.LinkedListReversed`1.Enumerator.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="T:System.Linq.ListEnumerable">
            <summary>
            Represents with LINQ methods for <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
            <seealso cref="T:System.Collections.Generic.List`1"/>
        </member>
        <member name="M:System.Linq.ListEnumerable.Count``1(System.Collections.Generic.List{``0},System.Func{``0,System.Boolean})">
            <inheritdoc cref="M:System.Linq.ArrayEnumerable.Count``1(``0[],System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:System.Linq.ListEnumerable.CountUnsafe``1(System.Collections.Generic.List{``0},)">
            <inheritdoc cref="M:System.Linq.ArrayEnumerable.Count``1(``0[],System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:System.Linq.ListEnumerable.Where``1(System.Collections.Generic.List{``0},System.Func{``0,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:System.Linq.ListEnumerable.Select``2(System.Collections.Generic.List{``0},System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.ListEnumerable.SelectMany``3(System.Collections.Generic.List{``0},System.Func{``0,System.ReadOnlySpan{``1}},System.Func{``0,``1,``2})">
            <inheritdoc cref="M:System.Linq.Enumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})"/>
        </member>
        <member name="M:System.Linq.ListEnumerable.SelectMany``3(System.Collections.Generic.List{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})">
            <inheritdoc cref="M:System.Linq.Enumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})"/>
        </member>
        <member name="T:System.Linq.MemoryEnumerable">
            <summary>
            Represents a list of methods that are LINQ methods operating with <see cref="T:System.ReadOnlyMemory`1"/> instances.
            </summary>
            <seealso cref="T:System.ReadOnlyMemory`1"/>
        </member>
        <member name="M:System.Linq.MemoryEnumerable.Select``2(System.ReadOnlyMemory{``0},System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.SpanEnumerable.Select``2(System.ReadOnlySpan{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.MemoryEnumerable.Where``1(System.ReadOnlyMemory{``0},System.Func{``0,System.Boolean})">
            <inheritdoc cref="M:System.Linq.SpanEnumerable.Where``1(System.ReadOnlySpan{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="T:System.Linq.MultidimensionalArrayEnumerable">
            <summary>
            Provides with LINQ methods on multi-dimensional array.
            </summary>
        </member>
        <member name="M:System.Linq.MultidimensionalArrayEnumerable.Select``2(``0[0:,0:],System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.ArrayEnumerable.Select``2(``0[],System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.MultidimensionalArrayEnumerable.Select``2(``0[0:,0:],System.Func{``0,System.Int32,System.Int32,``1})">
            <inheritdoc cref="M:System.Linq.ArrayEnumerable.Select``2(``0[],System.Func{``0,System.Int32,``1})"/>
        </member>
        <member name="T:System.Linq.Providers.IAggregateMethod`2">
            <summary>
            Represents a type that supports method group <c>Aggregate</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.IAggregateMethod`2.Aggregate(System.Func{`1,`1,`1})">
            <inheritdoc cref="M:System.Linq.Enumerable.Aggregate``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0})"/>
        </member>
        <member name="M:System.Linq.Providers.IAggregateMethod`2.Aggregate``1(``0,System.Func{``0,`1,``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.Aggregate``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1})"/>
        </member>
        <member name="M:System.Linq.Providers.IAggregateMethod`2.Aggregate``2(``0,System.Func{``0,`1,``0},System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.Aggregate``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})"/>
        </member>
        <member name="T:System.Linq.Providers.IAllAreMethod`2">
            <summary>
            Represents a type that supports method group <c>AllAre</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.IAllAreMethod`2.AllAre``1">
            <summary>
            Determine whether all elements are of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of the target elements.</typeparam>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="T:System.Linq.Providers.IAnyAllMethod`2">
            <summary>
            Represents a type that supports method group <c>Any</c> and <c>All</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.IAnyAllMethod`2.Any">
            <inheritdoc cref="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:System.Linq.Providers.IAnyAllMethod`2.Any(System.Func{`1,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:System.Linq.Providers.IAnyAllMethod`2.All(System.Func{`1,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Enumerable.All``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="T:System.Linq.Providers.IAppendPrependMethod`2">
            <summary>
            Represents a type that supports method group <c>Append</c> and <c>Prepend</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.IAppendPrependMethod`2.Append(`1)">
            <inheritdoc cref="M:System.Linq.Enumerable.Append``1(System.Collections.Generic.IEnumerable{``0},``0)"/>
        </member>
        <member name="M:System.Linq.Providers.IAppendPrependMethod`2.Prepend(`1)">
            <inheritdoc cref="M:System.Linq.Enumerable.Prepend``1(System.Collections.Generic.IEnumerable{``0},``0)"/>
        </member>
        <member name="T:System.Linq.Providers.IAverageMethod`2">
            <summary>
            Represents a type that supports method group <c>Average</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.IAverageMethod`2.Average">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.IAverageMethod`2.Average``2">
            <inheritdoc/>
        </member>
        <member name="T:System.Linq.Providers.ICastMethod`2">
            <summary>
            Represents a type that supports method group <c>Cast</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.ICastMethod`2.Cast``1">
            <inheritdoc cref="M:System.Linq.Enumerable.Cast``1(System.Collections.IEnumerable)"/>
        </member>
        <member name="T:System.Linq.Providers.IChunkMethod`2">
            <summary>
            Represents a type that supports method group <c>Chunk</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.IChunkMethod`2.Chunk(System.Int32)">
            <inheritdoc cref="M:System.Linq.Enumerable.Chunk``1(System.Collections.Generic.IEnumerable{``0},System.Int32)"/>
        </member>
        <member name="T:System.Linq.Providers.IConcatMethod`2">
            <summary>
            Represents a type that supports method group <c>Concat</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.IConcatMethod`2.Concat(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc cref="M:System.Linq.Enumerable.Concat``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="T:System.Linq.Providers.IContainsMethod`2">
            <summary>
            Represents a type that supports method group <c>Contains</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.IContainsMethod`2.Contains(`1)">
            <inheritdoc cref="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0)"/>
        </member>
        <member name="M:System.Linq.Providers.IContainsMethod`2.Contains(`1,System.Collections.Generic.IEqualityComparer{`1})">
            <inheritdoc cref="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})"/>
        </member>
        <member name="T:System.Linq.Providers.ICountByMethod`2">
            <summary>
            Represents a type that supports method group <c>CountBy</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.ICountByMethod`2.CountBy``1(System.Func{`1,``0})">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.ICountByMethod`2.CountBy``1(System.Func{`1,``0},System.Collections.Generic.IEqualityComparer{``0})">
            <inheritdoc/>
        </member>
        <member name="T:System.Linq.Providers.ICountMethod`2">
            <summary>
            Represents a type that supports method group <c>Count</c> and <c>LongCount</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.ICountMethod`2.Count">
            <inheritdoc cref="M:System.Linq.Enumerable.Count``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:System.Linq.Providers.ICountMethod`2.Count(System.Func{`1,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Enumerable.Count``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:System.Linq.Providers.ICountMethod`2.LongCount">
            <inheritdoc cref="M:System.Linq.Enumerable.LongCount``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:System.Linq.Providers.ICountMethod`2.LongCount(System.Func{`1,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Enumerable.LongCount``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="T:System.Linq.Providers.ICustomLinqMethod`2">
            <summary>
            Represents a type that supports customized LINQ method defined in this repository.
            </summary>
            <inheritdoc/>
        </member>
        <member name="T:System.Linq.Providers.IDefaultIfEmptyMethod`2">
            <summary>
            Represents a type that supports method group <c>DefaultIfEmpty</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.IDefaultIfEmptyMethod`2.DefaultIfEmpty">
            <inheritdoc cref="M:System.Linq.Enumerable.DefaultIfEmpty``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:System.Linq.Providers.IDefaultIfEmptyMethod`2.DefaultIfEmpty(`1)">
            <inheritdoc cref="M:System.Linq.Enumerable.DefaultIfEmpty``1(System.Collections.Generic.IEnumerable{``0},``0)"/>
        </member>
        <member name="T:System.Linq.Providers.IDistinctMethod`2">
            <summary>
            Represents a type that supports method group <c>Distinct</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.IDistinctMethod`2.Distinct">
            <inheritdoc cref="M:System.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:System.Linq.Providers.IDistinctMethod`2.Distinct(System.Collections.Generic.IEqualityComparer{`1})">
            <inheritdoc cref="M:System.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})"/>
        </member>
        <member name="T:System.Linq.Providers.IElementAtMethod`2">
            <summary>
            Represents a type that supports method group <c>ElementAt</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.IElementAtMethod`2.ElementAt(System.Int32)">
            <inheritdoc cref="M:System.Linq.Enumerable.ElementAt``1(System.Collections.Generic.IEnumerable{``0},System.Int32)"/>
        </member>
        <member name="M:System.Linq.Providers.IElementAtMethod`2.ElementAt(System.Index)">
            <inheritdoc cref="M:System.Linq.Enumerable.ElementAt``1(System.Collections.Generic.IEnumerable{``0},System.Index)"/>
        </member>
        <member name="M:System.Linq.Providers.IElementAtMethod`2.ElementAtOrDefault(System.Int32)">
            <inheritdoc cref="M:System.Linq.Enumerable.ElementAtOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Int32)"/>
        </member>
        <member name="M:System.Linq.Providers.IElementAtMethod`2.ElementAtOrDefault(System.Index)">
            <inheritdoc cref="M:System.Linq.Enumerable.ElementAtOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Index)"/>
        </member>
        <member name="T:System.Linq.Providers.IExceptMethod`2">
            <summary>
            Represents a type that supports method group <c>Except</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.IExceptMethod`2.Except(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc cref="M:System.Linq.Enumerable.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:System.Linq.Providers.IExceptMethod`2.Except(System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEqualityComparer{`1})">
            <inheritdoc cref="M:System.Linq.Enumerable.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})"/>
        </member>
        <member name="T:System.Linq.Providers.IFirstLastMethod`2">
            <summary>
            Represents a type that supports method group <c>First</c>, <c>FirstOrDefault</c>, <c>Last</c> and <c>LastOrDefault</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.IFirstLastMethod`2.First">
            <inheritdoc cref="M:System.Linq.Enumerable.First``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:System.Linq.Providers.IFirstLastMethod`2.First(System.Func{`1,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Enumerable.First``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:System.Linq.Providers.IFirstLastMethod`2.FirstOrDefault">
            <inheritdoc cref="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:System.Linq.Providers.IFirstLastMethod`2.FirstOrDefault(`1)">
            <inheritdoc cref="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},``0)"/>
        </member>
        <member name="M:System.Linq.Providers.IFirstLastMethod`2.FirstOrDefault(System.Func{`1,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:System.Linq.Providers.IFirstLastMethod`2.FirstOrDefault(System.Func{`1,System.Boolean},`1)">
            <inheritdoc cref="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},``0)"/>
        </member>
        <member name="M:System.Linq.Providers.IFirstLastMethod`2.Last">
            <inheritdoc cref="M:System.Linq.Enumerable.Last``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:System.Linq.Providers.IFirstLastMethod`2.Last(System.Func{`1,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Enumerable.Last``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:System.Linq.Providers.IFirstLastMethod`2.LastOrDefault">
            <inheritdoc cref="M:System.Linq.Enumerable.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:System.Linq.Providers.IFirstLastMethod`2.LastOrDefault(`1)">
            <inheritdoc cref="M:System.Linq.Enumerable.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0},``0)"/>
        </member>
        <member name="M:System.Linq.Providers.IFirstLastMethod`2.LastOrDefault(System.Func{`1,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Enumerable.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:System.Linq.Providers.IFirstLastMethod`2.LastOrDefault(System.Func{`1,System.Boolean},`1)">
            <inheritdoc cref="M:System.Linq.Enumerable.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},``0)"/>
        </member>
        <member name="M:System.Linq.Providers.IFirstLastMethod`2.TryGetFirst(`1@)">
            <summary>
            Try to get the first element in the sequence.
            </summary>
            <param name="result">The result value.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:System.Linq.Providers.IFirstLastMethod`2.TryGetFirst(System.Func{`1,System.Boolean},`1@)">
            <summary>
            Try to get the first element in the sequence satisfying the specified condition.
            </summary>
            <param name="predicate">The condition to be checked.</param>
            <param name="result">The result value.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:System.Linq.Providers.IFirstLastMethod`2.TryGetLast(`1@)">
            <summary>
            Try to get the last element in the sequence.
            </summary>
            <param name="result">The result value.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:System.Linq.Providers.IFirstLastMethod`2.TryGetLast(System.Func{`1,System.Boolean},`1@)">
            <summary>
            Try to get the last element in the sequence satisfying the specified condition.
            </summary>
            <param name="predicate">The condition to be checked.</param>
            <param name="result">The result value.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="T:System.Linq.Providers.IGetSubsetMethod`2">
            <summary>
            Represents a type that supports method group <c>GetSubset</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.IGetSubsetMethod`2.GetSubsets(System.Int32)">
            <summary>
            Get all subsets from the specified number of the values to take.
            </summary>
            <param name="subsetSize">The number of elements you want to take.</param>
            <returns>
            The subsets of the list.
            For example, if the input array is <c>[1, 2, 3]</c> and the argument <paramref name="subsetSize"/> is 2, the result will be
            <code><![CDATA[
            [[1, 2], [1, 3], [2, 3]]
            ]]></code>
            3 cases.
            </returns>
        </member>
        <member name="T:System.Linq.Providers.IGroupByMethod`2">
            <summary>
            Represents a type that supports method group <c>GroupBy</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.IGroupByMethod`2.GroupBy``1(System.Func{`1,``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.Providers.IGroupByMethod`2.GroupBy``1(System.Func{`1,``0},System.Collections.Generic.IEqualityComparer{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})"/>
        </member>
        <member name="M:System.Linq.Providers.IGroupByMethod`2.GroupBy``2(System.Func{`1,``0},System.Func{`1,``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})"/>
        </member>
        <member name="M:System.Linq.Providers.IGroupByMethod`2.GroupBy``2(System.Func{`1,``0},System.Func{`1,``1},System.Collections.Generic.IEqualityComparer{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})"/>
        </member>
        <member name="M:System.Linq.Providers.IGroupByMethod`2.GroupBy``3(System.Func{`1,``0},System.Func{`1,``1},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``2})">
            <inheritdoc cref="M:System.Linq.Enumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3})"/>
        </member>
        <member name="M:System.Linq.Providers.IGroupByMethod`2.GroupBy``3(System.Func{`1,``0},System.Func{`1,``1},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``2},System.Collections.Generic.IEqualityComparer{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3},System.Collections.Generic.IEqualityComparer{``1})"/>
        </member>
        <member name="T:System.Linq.Providers.IHasMethod`2">
            <summary>
            Represents a type that supports method group <c>Has</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.IHasMethod`2.Has``1">
            <summary>
            Determine whether the collection contains an element of the specified type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of the constraint to be checked.</typeparam>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="T:System.Linq.Providers.IIndexMethod`2">
            <summary>
            Represents a type that supports method group <c>Index</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.IIndexMethod`2.Index">
            <inheritdoc cref="M:System.Linq.Enumerable.Index``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="T:System.Linq.Providers.IIntersectionMethod`2">
            <summary>
            Represents a type that supports method group <c>Intersect</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.IIntersectionMethod`2.Intersect(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc cref="M:System.Linq.Enumerable.Intersect``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:System.Linq.Providers.IIntersectionMethod`2.Intersect(System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEqualityComparer{`1})">
            <inheritdoc cref="M:System.Linq.Enumerable.Intersect``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})"/>
        </member>
        <member name="T:System.Linq.Providers.IJoinMethod`2">
            <summary>
            Represents a type that supports method group <c>Join</c> and <c>GroupJoin</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.IJoinMethod`2.Join``3(System.Collections.Generic.IEnumerable{``0},System.Func{`1,``1},System.Func{``0,``1},System.Func{`1,``0,``2})">
            <inheritdoc cref="M:System.Linq.Enumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3})"/>
        </member>
        <member name="M:System.Linq.Providers.IJoinMethod`2.Join``3(System.Collections.Generic.IEnumerable{``0},System.Func{`1,``1},System.Func{``0,``1},System.Func{`1,``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})"/>
        </member>
        <member name="M:System.Linq.Providers.IJoinMethod`2.GroupJoin``3(System.Collections.Generic.IEnumerable{``0},System.Func{`1,``1},System.Func{``0,``1},System.Func{`1,System.Collections.Generic.IEnumerable{``0},``2})">
            <inheritdoc cref="M:System.Linq.Enumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3})"/>
        </member>
        <member name="M:System.Linq.Providers.IJoinMethod`2.GroupJoin``3(System.Collections.Generic.IEnumerable{``0},System.Func{`1,``1},System.Func{``0,``1},System.Func{`1,System.Collections.Generic.IEnumerable{``0},``2},System.Collections.Generic.IEqualityComparer{``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3},System.Collections.Generic.IEqualityComparer{``2})"/>
        </member>
        <member name="T:System.Linq.Providers.ILeftJoinMethod`2">
            <summary>
            Represents a type that supports method group <c>LeftJoin</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.ILeftJoinMethod`2.LeftJoin``3(System.Collections.Generic.IEnumerable{``0},System.Func{`1,``1},System.Func{``0,``1},System.Func{`1,``0,``2})">
            <summary>
            Performs a left outer join with the other sequence.
            </summary>
            <inheritdoc cref="M:System.Linq.Providers.IJoinMethod`2.Join``3(System.Collections.Generic.IEnumerable{``0},System.Func{`1,``1},System.Func{``0,``1},System.Func{`1,``0,``2})"/>
        </member>
        <member name="M:System.Linq.Providers.ILeftJoinMethod`2.LeftJoin``3(System.Collections.Generic.IEnumerable{``0},System.Func{`1,``1},System.Func{``0,``1},System.Func{`1,``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Performs a left outer join with the other sequence.
            </summary>
            <inheritdoc cref="M:System.Linq.Providers.IJoinMethod`2.Join``3(System.Collections.Generic.IEnumerable{``0},System.Func{`1,``1},System.Func{``0,``1},System.Func{`1,``0,``2},System.Collections.Generic.IEqualityComparer{``1})"/>
        </member>
        <member name="T:System.Linq.Providers.ILinqMethod`2">
            <summary>
            Represents a type that supports a certain method group defined in <see cref="T:System.Linq.Enumerable" />, well-known as LINQ methods.
            </summary>
            <typeparam name="TSelf"><self-type-constraint>
		<para>Indicates the type implementing this interface.</para>
		<para>
			This type doesn't use any extra syntax to constraint such usage, but C# will check for it.
			The type will include a <see langword="where" /> constraint that implements the interface itself
			to declare such "self constraint" usage:
			<code><![CDATA[interface ISelfType<TSelf> where TSelf : ISelfType<TSelf>]]></code>
			In addition, the type should be named <c>TSelf</c> in order to tell type parameters with the others.
		</para>
	</self-type-constraint></typeparam>
            <typeparam name="TSource">The type of each element that the type supports for iteration.</typeparam>
            <seealso cref="T:System.Linq.Enumerable" />
        </member>
        <member name="P:System.Linq.Providers.ILinqMethod`2.IsExtensionMethod">
            <summary>
            Indicates whether the method group supported is extension method.
            </summary>
        </member>
        <member name="P:System.Linq.Providers.ILinqMethod`2.IsValueLazilyCalculated">
            <summary>
            Indicates whether the provider type <typeparamref name="TSelf"/> won't calculate the final result immediately.
            The value can be <see langword="true"/> if such calculation is applied like <see cref="T:System.Collections.Generic.IEnumerable`1"/> values.
            By default, the value is <see langword="false"/>.
            </summary>
            <seealso cref="T:System.Collections.Generic.IEnumerable`1"/>
        </member>
        <member name="P:System.Linq.Providers.ILinqMethod`2.SupportsQuerySyntax">
            <summary>
            Indicates whether the methods defined in type <typeparamref name="TSelf"/> support for query syntax also.
            By default, the value is <see langword="false"/>.
            </summary>
            <remarks>
            All possible query clauses are:
            <list type="table">
            <listheader>
            <term>Query syntax</term>
            <description>Equivalent method</description>
            </listheader>
            </list>
            <list type="bullet">
            <item>
            <term><see langword="from"/> element <see langword="in"/> collection</term>
            <description>N/A</description>
            </item>
            <item>
            <term>
            <see langword="from"/> element1 <see langword="in"/> collection1
            <see langword="from"/> element2 <see langword="in"/> collection2
            </term>
            <description>
            <br/>
            <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            </description>
            </item>
            <item>
            <term><see langword="where"/> condition</term>
            <description><see cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/></description>
            </item>
            <item>
            <term><see langword="let"/> variable = expression</term>
            <description><see cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/></description>
            </item>
            <item>
            <term><see langword="select"/> { variable | expression } [<see langword="into"/> variable]</term>
            <description><see cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/></description>
            </item>
            <item>
            <term><see langword="orderby"/> { variable | expression } <see langword="ascending"/>?</term>
            <description><see cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/></description>
            </item>
            <item>
            <term><see langword="orderby"/> { variable | expression } <see langword="descending"/></term>
            <description>
            <see cref="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
            </description>
            </item>
            <item>
            <term><see langword="orderby"/> { v1 | e1 }, { v2 | e2 } <see langword="ascending"/>? ...</term>
            <description><see cref="M:System.Linq.Enumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})"/></description>
            </item>
            <item>
            <term>
            <see langword="orderby"/> { v1 | e1 }, { v2 | e2 } <see langword="descending"/> ...
            </term>
            <description>
            <see cref="M:System.Linq.Enumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})"/>
            </description>
            </item>
            <item>
            <term><see langword="group"/> variable <see langword="by"/> { variable | expression } [<see langword="into"/> variable]</term>
            <description>
            <see cref="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
            </description>
            </item>
            <item>
            <term><see langword="group"/> expression <see langword="by"/> expression [<see langword="into"/> variable]</term>
            <description>
            <see cref="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})"/>
            </description>
            </item>
            <item>
            <term>
            <see langword="join"/> variable <see langword="in"/> collection
            <see langword="on"/> previousVariable <see langword="equals"/> variable
            </term>
            <description>
            <br/>
            <see cref="M:System.Linq.Enumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3})"/>
            </description>
            </item>
            <item>
            <term>
            <see langword="join"/> variable2 <see langword="in"/> collection2
            <see langword="on"/> variable1 <see langword="equals"/> variable2
            <see langword="into"/> joinedGroup
            </term>
            <description>
            <br/>
            <see cref="M:System.Linq.Enumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3})"/>
            </description>
            </item>
            <item>
            <term>
            <see langword="left join"/> variable2 <see langword="in"/> collection2
            <see langword="on"/> variable1 <see langword="equals"/> variable2
            </term>
            <description>
            <c>LeftJoin</c> (will be added in future version of .NET library)
            </description>
            </item>
            <item>
            <term>
            <see langword="right join"/> variable2 <see langword="in"/> collection2
            <see langword="on"/> variable1 <see langword="equals"/> variable2
            </term>
            <description>
            <c>RightJoin</c> (will be added in future version of .NET library)
            </description>
            </item>
            </list>
            </remarks>
        </member>
        <member name="T:System.Linq.Providers.IMinMaxMethod`2">
            <summary>
            Represents a type that supports method group <c>Min</c>, <c>MinBy</c>, <c>Max</c> and <c>MaxBy</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.IMinMaxMethod`2.Min">
            <inheritdoc cref="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:System.Linq.Providers.IMinMaxMethod`2.Min(System.Comparison{`1})">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.IMinMaxMethod`2.Min(System.Collections.Generic.IComparer{`1})">
            <inheritdoc cref="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})"/>
        </member>
        <member name="M:System.Linq.Providers.IMinMaxMethod`2.MinBy``1(System.Func{`1,``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.MinBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.Providers.IMinMaxMethod`2.MinBy``1(System.Func{`1,``0},System.Collections.Generic.IComparer{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.MinBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})"/>
        </member>
        <member name="M:System.Linq.Providers.IMinMaxMethod`2.Max">
            <inheritdoc cref="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:System.Linq.Providers.IMinMaxMethod`2.Max(System.Comparison{`1})">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.IMinMaxMethod`2.Max(System.Collections.Generic.IComparer{`1})">
            <inheritdoc cref="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})"/>
        </member>
        <member name="M:System.Linq.Providers.IMinMaxMethod`2.MaxBy``1(System.Func{`1,``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.MaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.Providers.IMinMaxMethod`2.MaxBy``1(System.Func{`1,``0},System.Collections.Generic.IComparer{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.MaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})"/>
        </member>
        <member name="T:System.Linq.Providers.IOfTypeMethod`2">
            <summary>
            Represents a type that supports method group <c>OfType</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.IOfTypeMethod`2.OfType``1">
            <inheritdoc cref="M:System.Linq.Enumerable.OfType``1(System.Collections.IEnumerable)"/>
        </member>
        <member name="T:System.Linq.Providers.IOrderByMethod`2">
            <summary>
            Represents a type that supports method group <c>OrderBy</c> and <c>OrderByDescending</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="P:System.Linq.Providers.IOrderByMethod`2.System#Linq#Providers#ILinqMethod{TSelf,TSource}#IsValueLazilyCalculated">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.IOrderByMethod`2.OrderBy``1(System.Func{`1,``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.Providers.IOrderByMethod`2.OrderBy``1(System.Func{`1,``0},System.Collections.Generic.IComparer{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})"/>
        </member>
        <member name="M:System.Linq.Providers.IOrderByMethod`2.OrderByDescending``1(System.Func{`1,``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.Providers.IOrderByMethod`2.OrderByDescending``1(System.Func{`1,``0},System.Collections.Generic.IComparer{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})"/>
        </member>
        <member name="T:System.Linq.Providers.IQueryExpressionMethod`2">
            <summary>
            Represents a type that supports method groups that will be target method invocation of query expressions.
            </summary>
            <inheritdoc/>
        </member>
        <member name="P:System.Linq.Providers.IQueryExpressionMethod`2.System#Linq#Providers#ILinqMethod{TSelf,TSource}#SupportsQuerySyntax">
            <inheritdoc/>
        </member>
        <member name="T:System.Linq.Providers.IRangeMethod`2">
            <summary>
            Represents a type that supports method group <c>Range</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="P:System.Linq.Providers.IRangeMethod`2.System#Linq#Providers#ILinqMethod{TSelf,TSource}#IsExtensionMethod">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.IRangeMethod`2.Range(System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Linq.Enumerable.Range(System.Int32,System.Int32)"/>
        </member>
        <member name="T:System.Linq.Providers.IRightJoinMethod`2">
            <summary>
            Represents a type that supports method group <c>RightJoin</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.IRightJoinMethod`2.RightJoin``3(System.Collections.Generic.IEnumerable{``0},System.Func{`1,``1},System.Func{``0,``1},System.Func{`1,``0,``2})">
            <summary>
            Performs a right outer join with the other sequence.
            </summary>
            <inheritdoc cref="M:System.Linq.Providers.IJoinMethod`2.Join``3(System.Collections.Generic.IEnumerable{``0},System.Func{`1,``1},System.Func{``0,``1},System.Func{`1,``0,``2})"/>
        </member>
        <member name="M:System.Linq.Providers.IRightJoinMethod`2.RightJoin``3(System.Collections.Generic.IEnumerable{``0},System.Func{`1,``1},System.Func{``0,``1},System.Func{`1,``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Performs a right outer join with the other sequence.
            </summary>
            <inheritdoc cref="M:System.Linq.Providers.IJoinMethod`2.Join``3(System.Collections.Generic.IEnumerable{``0},System.Func{`1,``1},System.Func{``0,``1},System.Func{`1,``0,``2},System.Collections.Generic.IEqualityComparer{``1})"/>
        </member>
        <member name="T:System.Linq.Providers.ISelectManyMethod`2">
            <summary>
            Represents a type that supports method group <c>SelectMany</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.ISelectManyMethod`2.SelectMany``1(System.Func{`1,System.Collections.Generic.IEnumerable{``0}})">
            <inheritdoc cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
        </member>
        <member name="M:System.Linq.Providers.ISelectManyMethod`2.SelectMany``1(System.Func{`1,System.Int32,System.Collections.Generic.IEnumerable{``0}})">
            <inheritdoc cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}})"/>
        </member>
        <member name="M:System.Linq.Providers.ISelectManyMethod`2.SelectMany``2(System.Func{`1,System.Collections.Generic.IEnumerable{``0}},System.Func{`1,``0,``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})"/>
        </member>
        <member name="M:System.Linq.Providers.ISelectManyMethod`2.SelectMany``2(System.Func{`1,System.Int32,System.Collections.Generic.IEnumerable{``0}},System.Func{`1,``0,``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})"/>
        </member>
        <member name="T:System.Linq.Providers.ISelectMethod`2">
            <summary>
            Represents a type that supports method group <c>Select</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.ISelectMethod`2.Select``1(System.Func{`1,``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.Providers.ISelectMethod`2.Select``1(System.Func{`1,System.Int32,``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,``1})"/>
        </member>
        <member name="T:System.Linq.Providers.ISequenceEqualMethod`2">
            <summary>
            Represents a type that supports method group <c>SequenceEqual</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.ISequenceEqualMethod`2.SequenceEqual(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc cref="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:System.Linq.Providers.ISequenceEqualMethod`2.SequenceEqual(System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEqualityComparer{`1})">
            <inheritdoc cref="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})"/>
        </member>
        <member name="T:System.Linq.Providers.IShuffleMethod`2">
            <summary>
            Represents a type that supports method group <c>Shuffle</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.IShuffleMethod`2.Shuffle">
            <summary>
            Shuffles the whole collection.
            </summary>
            <returns>The whole collection, shuffled.</returns>
        </member>
        <member name="M:System.Linq.Providers.IShuffleMethod`2.Shuffle(System.Random)">
            <summary>
            Shuffles the whole collection.
            </summary>
            <param name="random">The random number generator to be called.</param>
            <returns>The whole collection, shuffled.</returns>
        </member>
        <member name="T:System.Linq.Providers.ISkipMethod`2">
            <summary>
            Represents a type that supports method group <c>Skip</c>, <c>SkipLast</c> and <c>SkipWhile</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.ISkipMethod`2.Skip(System.Int32)">
            <inheritdoc cref="M:System.Linq.Enumerable.Skip``1(System.Collections.Generic.IEnumerable{``0},System.Int32)"/>
        </member>
        <member name="M:System.Linq.Providers.ISkipMethod`2.SkipLast(System.Int32)">
            <inheritdoc cref="M:System.Linq.Enumerable.SkipLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)"/>
        </member>
        <member name="M:System.Linq.Providers.ISkipMethod`2.SkipWhile(System.Func{`1,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Enumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="T:System.Linq.Providers.ISliceMethod`2">
            <summary>
            Represents a type that supports method group <c>Slice</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.ISliceMethod`2.Slice(System.Int32,System.Int32)">
            <inheritdoc cref="M:System.ReadOnlySpan`1.Slice(System.Int32,System.Int32)"/>
        </member>
        <member name="T:System.Linq.Providers.ISumMethod`2">
            <summary>
            Represents a type that supports method group <c>Sum</c> and <c>SumBy</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.ISumMethod`2.Sum">
            <inheritdoc/>
        </member>
        <member name="T:System.Linq.Providers.ITakeMethod`2">
            <summary>
            Represents a type that supports method group <c>Take</c>, <c>TakeLast</c> and <c>TakeWhile</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.ITakeMethod`2.Take(System.Int32)">
            <inheritdoc cref="M:System.Linq.Enumerable.Take``1(System.Collections.Generic.IEnumerable{``0},System.Int32)"/>
        </member>
        <member name="M:System.Linq.Providers.ITakeMethod`2.Take(System.Range)">
            <inheritdoc cref="M:System.Linq.Enumerable.Take``1(System.Collections.Generic.IEnumerable{``0},System.Range)"/>
        </member>
        <member name="M:System.Linq.Providers.ITakeMethod`2.TakeLast(System.Int32)">
            <inheritdoc cref="M:System.Linq.Enumerable.TakeLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)"/>
        </member>
        <member name="M:System.Linq.Providers.ITakeMethod`2.TakeWhile(System.Func{`1,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:System.Linq.Providers.ITakeMethod`2.TakeWhile(System.Func{`1,System.Int32,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})"/>
        </member>
        <member name="T:System.Linq.Providers.IThenByMethod`2">
            <summary>
            Represents a type that supports method group <c>ThenBy</c> and <c>ThenByDescending</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="P:System.Linq.Providers.IThenByMethod`2.System#Linq#Providers#ILinqMethod{TSelf,TSource}#IsValueLazilyCalculated">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.IThenByMethod`2.ThenBy``1(System.Func{`1,``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.Providers.IThenByMethod`2.ThenBy``1(System.Func{`1,``0},System.Collections.Generic.IComparer{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})"/>
        </member>
        <member name="M:System.Linq.Providers.IThenByMethod`2.ThenByDescending``1(System.Func{`1,``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.Providers.IThenByMethod`2.ThenByDescending``1(System.Func{`1,``0},System.Collections.Generic.IComparer{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})"/>
        </member>
        <member name="T:System.Linq.Providers.IToArrayMethod`2">
            <summary>
            Represents a type that supports method group <c>ToArray</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.IToArrayMethod`2.ToArray">
            <inheritdoc cref="M:System.Linq.Enumerable.ToArray``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="T:System.Linq.Providers.IUnionMethod`2">
            <summary>
            Represents a type that supports method group <c>Union</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.IUnionMethod`2.Union(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc cref="M:System.Linq.Enumerable.Union``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:System.Linq.Providers.IUnionMethod`2.Union(System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEqualityComparer{`1})">
            <inheritdoc cref="M:System.Linq.Enumerable.Union``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})"/>
        </member>
        <member name="T:System.Linq.Providers.IWhereMethod`2">
            <summary>
            Represents a type that supports method group <c>Where</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.IWhereMethod`2.Where(System.Func{`1,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:System.Linq.Providers.IWhereMethod`2.Where(System.Func{`1,System.Int32,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})"/>
        </member>
        <member name="T:System.Linq.Providers.IZipMethod`2">
            <summary>
            Represents a type that supports method group <c>Zip</c>.
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.Providers.IZipMethod`2.Zip``1(System.Collections.Generic.IEnumerable{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.Zip``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})"/>
        </member>
        <member name="M:System.Linq.Providers.IZipMethod`2.Zip``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})"/>
        </member>
        <member name="M:System.Linq.Providers.IZipMethod`2.Zip``2(System.Collections.Generic.IEnumerable{``0},System.Func{`1,``0,``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})"/>
        </member>
        <member name="M:System.Linq.Providers.IZipMethod`2.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{`1,``0,``1,``2})">
            <inheritdoc/>
        </member>
        <member name="T:System.Linq.SpanEnumerable">
            <summary>
            Provides LINQ-based extension methods on <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
            <seealso cref="T:System.ReadOnlySpan`1"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.Aggregate``1(System.ReadOnlySpan{``0},System.Func{``0,``0,``0})">
            <inheritdoc cref="M:System.Linq.Providers.IAggregateMethod`2.Aggregate(System.Func{`1,`1,`1})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.Aggregate``2(System.ReadOnlySpan{``0},``1,System.Func{``1,``0,``1})">
            <inheritdoc cref="M:System.Linq.Providers.IAggregateMethod`2.Aggregate``2(``0,System.Func{``0,`1,``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.AllAre``2(System.ReadOnlySpan{``0})">
            <summary>
            Determines whether all elements are of type <typeparamref name="TDerived"/>.
            </summary>
            <typeparam name="TBase">The type of each element.</typeparam>
            <typeparam name="TDerived">The derived type to be checked.</typeparam>
            <param name="this">The collection to be used and checked.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:System.Linq.SpanEnumerable.Any``1(System.ReadOnlySpan{``0},System.Func{``0,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Providers.IAnyAllMethod`2.Any(System.Func{`1,System.Boolean})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.AnyUnsafe``1(System.ReadOnlySpan{``0},)">
            <inheritdoc cref="M:System.Linq.SpanEnumerable.Any``1(System.ReadOnlySpan{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.All``1(System.ReadOnlySpan{``0},System.Func{``0,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Providers.IAnyAllMethod`2.All(System.Func{`1,System.Boolean})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.AllUnsafe``1(System.ReadOnlySpan{``0},)">
            <inheritdoc cref="M:System.Linq.SpanEnumerable.All``1(System.ReadOnlySpan{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.Average``2(System.ReadOnlySpan{``0})">
            <inheritdoc cref="M:System.Linq.Providers.IAverageMethod`2.Average``2"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.Count``1(System.ReadOnlySpan{``0},System.Func{``0,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Providers.ICountMethod`2.Count(System.Func{`1,System.Boolean})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.First``1(System.ReadOnlySpan{``0})">
            <summary>
            Returns <paramref name="this"/>[0].
            </summary>
            <typeparam name="TSource">The type of each element.</typeparam>
            <param name="this">The source elements.</param>
            <returns>The element.</returns>
        </member>
        <member name="M:System.Linq.SpanEnumerable.FirstOrDefault``1(System.ReadOnlySpan{``0})">
            <summary>
            Returns first element of <paramref name="this"/> or <see langword="default"/>(<typeparamref name="TSource"/>)
            if the list is empty.
            </summary>
            <typeparam name="TSource">The type of each element.</typeparam>
            <param name="this">The sourc elementse.</param>
            <returns>The element.</returns>
        </member>
        <member name="M:System.Linq.SpanEnumerable.First``1(System.ReadOnlySpan{``0},System.Func{``0,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Providers.IFirstLastMethod`2.First(System.Func{`1,System.Boolean})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.FirstRef``1(System.ReadOnlySpan{``0},System.Func{``0,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Providers.IFirstLastMethod`2.First(System.Func{`1,System.Boolean})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.FirstOrDefault``1(System.ReadOnlySpan{``0},System.Func{``0,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Providers.IFirstLastMethod`2.FirstOrDefault(System.Func{`1,System.Boolean},`1)"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.Last``1(System.ReadOnlySpan{``0},System.Func{``0,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Providers.IFirstLastMethod`2.Last(System.Func{`1,System.Boolean})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.LastOrDefault``1(System.ReadOnlySpan{``0},System.Func{``0,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Providers.IFirstLastMethod`2.LastOrDefault(System.Func{`1,System.Boolean})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.Index``1(System.ReadOnlySpan{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.Index``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.Cast``2(System.ReadOnlySpan{``0})">
            <inheritdoc cref="M:System.Linq.Providers.ICastMethod`2.Cast``1"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.GroupBy``2(System.ReadOnlySpan{``0},System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.Providers.IGroupByMethod`2.GroupBy``1(System.Func{`1,``0})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.GroupBy``3(System.ReadOnlySpan{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <inheritdoc cref="M:System.Linq.Providers.IGroupByMethod`2.GroupBy``2(System.Func{`1,``0},System.Func{`1,``1})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.Join``4(System.ReadOnlySpan{``0},System.ReadOnlySpan{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3})">
            <inheritdoc cref="M:System.Linq.Providers.IJoinMethod`2.Join``3(System.Collections.Generic.IEnumerable{``0},System.Func{`1,``1},System.Func{``0,``1},System.Func{`1,``0,``2})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.Join``4(System.ReadOnlySpan{``0},System.ReadOnlySpan{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})">
            <inheritdoc cref="M:System.Linq.Providers.IJoinMethod`2.Join``3(System.Collections.Generic.IEnumerable{``0},System.Func{`1,``1},System.Func{``0,``1},System.Func{`1,``0,``2},System.Collections.Generic.IEqualityComparer{``1})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.GroupJoin``4(System.ReadOnlySpan{``0},System.ReadOnlySpan{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1[],``3})">
            <inheritdoc cref="M:System.Linq.Providers.IJoinMethod`2.GroupJoin``3(System.Collections.Generic.IEnumerable{``0},System.Func{`1,``1},System.Func{``0,``1},System.Func{`1,System.Collections.Generic.IEnumerable{``0},``2})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.GroupJoin``4(System.ReadOnlySpan{``0},System.ReadOnlySpan{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1[],``3},System.Collections.Generic.IEqualityComparer{``2})">
            <inheritdoc cref="M:System.Linq.Providers.IJoinMethod`2.GroupJoin``3(System.Collections.Generic.IEnumerable{``0},System.Func{`1,``1},System.Func{``0,``1},System.Func{`1,System.Collections.Generic.IEnumerable{``0},``2},System.Collections.Generic.IEqualityComparer{``1})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.LeftJoin``4(System.ReadOnlySpan{``0},System.ReadOnlySpan{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3})">
            <inheritdoc cref="M:System.Linq.Providers.ILeftJoinMethod`2.LeftJoin``3(System.Collections.Generic.IEnumerable{``0},System.Func{`1,``1},System.Func{``0,``1},System.Func{`1,``0,``2})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.LeftJoin``4(System.ReadOnlySpan{``0},System.ReadOnlySpan{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})">
            <inheritdoc cref="M:System.Linq.Providers.ILeftJoinMethod`2.LeftJoin``3(System.Collections.Generic.IEnumerable{``0},System.Func{`1,``1},System.Func{``0,``1},System.Func{`1,``0,``2},System.Collections.Generic.IEqualityComparer{``1})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.OrderBy``2(System.ReadOnlySpan{``0},System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.Providers.IOrderByMethod`2.OrderBy``1(System.Func{`1,``0})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.OrderByDescending``2(System.ReadOnlySpan{``0},System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.Providers.IOrderByMethod`2.OrderByDescending``1(System.Func{`1,``0})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.RightJoin``4(System.ReadOnlySpan{``0},System.ReadOnlySpan{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3})">
            <inheritdoc cref="M:System.Linq.Providers.IRightJoinMethod`2.RightJoin``3(System.Collections.Generic.IEnumerable{``0},System.Func{`1,``1},System.Func{``0,``1},System.Func{`1,``0,``2})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.RightJoin``4(System.ReadOnlySpan{``0},System.ReadOnlySpan{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})">
            <inheritdoc cref="M:System.Linq.Providers.IRightJoinMethod`2.RightJoin``3(System.Collections.Generic.IEnumerable{``0},System.Func{`1,``1},System.Func{``0,``1},System.Func{`1,``0,``2},System.Collections.Generic.IEqualityComparer{``1})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.Select``2(System.ReadOnlySpan{``0},System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.Providers.ISelectMethod`2.Select``1(System.Func{`1,``0})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.Select``2(System.ReadOnlySpan{``0},System.Func{``0,System.Int32,``1})">
            <inheritdoc cref="M:System.Linq.Providers.ISelectMethod`2.Select``1(System.Func{`1,System.Int32,``0})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.SelectMany``3(System.ReadOnlySpan{``0},System.Func{``0,System.ReadOnlySpan{``1}},System.Func{``0,``1,``2})">
            <inheritdoc cref="M:System.Linq.Providers.ISelectManyMethod`2.SelectMany``2(System.Func{`1,System.Collections.Generic.IEnumerable{``0}},System.Func{`1,``0,``1})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.Where``1(System.ReadOnlySpan{``0},System.Func{``0,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Providers.IWhereMethod`2.Where(System.Func{`1,System.Boolean})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.Min``1(System.ReadOnlySpan{``0})">
            <inheritdoc cref="M:System.Linq.Providers.IMinMaxMethod`2.Min"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.Min``2(System.ReadOnlySpan{``0},System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.MinBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.MinBy``2(System.ReadOnlySpan{``0},System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.Providers.IMinMaxMethod`2.MinBy``1(System.Func{`1,``0})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.MinUnsafe``2(System.ReadOnlySpan{``0},)">
            <inheritdoc cref="M:System.Linq.SpanEnumerable.Min``2(System.ReadOnlySpan{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.Max``1(System.ReadOnlySpan{``0})">
            <inheritdoc cref="M:System.Linq.Providers.IMinMaxMethod`2.Max"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.Max``2(System.ReadOnlySpan{``0},System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.MaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.MaxBy``2(System.ReadOnlySpan{``0},System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.Providers.IMinMaxMethod`2.MaxBy``1(System.Func{`1,``0})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.MaxUnsafe``2(System.ReadOnlySpan{``0},)">
            <inheritdoc cref="M:System.Linq.SpanEnumerable.Max``2(System.ReadOnlySpan{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.MaxIf``1(System.ReadOnlySpan{``0},System.Func{``0,System.Boolean})">
            <summary>
            Gets the maximum value of the sequence, and ignore elements to be compared if they are not satisfy the specified condition.
            </summary>
            <typeparam name="TSource">The type of source elements.</typeparam>
            <param name="this">The source sequence.</param>
            <param name="predicate">The condition to be checked.</param>
            <returns>The maximum value.</returns>
        </member>
        <member name="M:System.Linq.SpanEnumerable.MaxIf``1(System.ReadOnlySpan{``0},System.Func{``0,System.Boolean},``0)">
            <summary>
            Gets the maximum value of the sequence, and ignore elements to be compared if they are not satisfy the specified condition.
            </summary>
            <typeparam name="TSource">The type of source elements.</typeparam>
            <param name="this">The source sequence.</param>
            <param name="predicate">The condition to be checked.</param>
            <param name="default">The default value if all elements in sequence are ignored.</param>
            <returns>The maximum value.</returns>
        </member>
        <member name="M:System.Linq.SpanEnumerable.OfType``2(System.ReadOnlySpan{``0})">
            <inheritdoc cref="M:System.Linq.Providers.IOfTypeMethod`2.OfType``1"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.Shuffle``1(System.ReadOnlySpan{``0})">
            <inheritdoc cref="M:System.Linq.Providers.IShuffleMethod`2.Shuffle"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.Shuffle``1(System.ReadOnlySpan{``0},System.Random)">
            <inheritdoc cref="M:System.Linq.Providers.IShuffleMethod`2.Shuffle(System.Random)"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.Skip``1(System.ReadOnlySpan{``0},System.Int32)">
            <inheritdoc cref="M:System.Linq.Providers.ISkipMethod`2.Skip(System.Int32)"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.Range(System.Int32)">
            <summary>
            Create a range of variables that starts with 0, incrementing values and putting them into the other positions.
            </summary>
            <param name="count">The number of elements created.</param>
            <returns>The result sequence [0, 1, 2, 3, ..].</returns>
        </member>
        <member name="M:System.Linq.SpanEnumerable.Range(System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Linq.Providers.IRangeMethod`2.Range(System.Int32,System.Int32)"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.Range``1(System.Int32)">
            <summary>
            Create a range of variables that starts with <see cref="P:System.Numerics.INumberBase`1.Zero"/> from type <typeparamref name="TInteger"/>,
            incrementing values and putting them into the other positions.
            </summary>
            <typeparam name="TInteger">The type of integer.</typeparam>
            <param name="count">The number of elements created.</param>
            <returns>The result sequence [0, 1, 2, 3, ..].</returns>
        </member>
        <member name="M:System.Linq.SpanEnumerable.Range``1(``0,System.Int32,System.Func{``0,``0})">
            <summary>
            Create a range of variables that starts with the specified value, and iterates the value to create followed values.
            </summary>
            <typeparam name="T">The type of the target value.</typeparam>
            <param name="start">The start value.</param>
            <param name="count">The number of elements created.</param>
            <param name="iterator">The creator method that create a value from the previous value.</param>
            <returns>The result sequence.</returns>
        </member>
        <member name="M:System.Linq.SpanEnumerable.Sum``1(System.ReadOnlySpan{``0})">
            <inheritdoc cref="M:System.Linq.Providers.ISumMethod`2.Sum"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.Sum``2(System.ReadOnlySpan{``0},System.Func{``0,``1})">
            <summary>
            Totals up all elements, and return the result of the sum by the specified property calculated from each element.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TKey">The type of key to add up.</typeparam>
            <param name="this">The collection to be used and checked.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <returns>The value with the sum key in the sequence.</returns>
        </member>
        <member name="M:System.Linq.SpanEnumerable.SumUnsafe``2(System.ReadOnlySpan{``0},)">
            <inheritdoc cref="M:System.Linq.SpanEnumerable.Sum``2(System.ReadOnlySpan{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.Take``1(System.ReadOnlySpan{``0},System.Int32)">
            <inheritdoc cref="M:System.Linq.Providers.ITakeMethod`2.Take(System.Int32)"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.Take``1(System.ReadOnlySpan{``0},System.Range)">
            <inheritdoc cref="M:System.Linq.Providers.ITakeMethod`2.Take(System.Range)"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.ToLookup``2(System.ReadOnlySpan{``0},System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.ToLookup``2(System.ReadOnlySpan{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.ToLookup``3(System.ReadOnlySpan{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <inheritdoc cref="M:System.Linq.Enumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})"/>
        </member>
        <member name="M:System.Linq.SpanEnumerable.ToLookup``3(System.ReadOnlySpan{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})"/>
        </member>
        <member name="T:System.Linq.__ImplementedTypes`1">
            <summary>
            This type provides a way to record LINQ methods and interfaces implemented on <see cref="T:System.ReadOnlySpan`1"/>.
            This recording will be consumed by future C# <see langword="extension"/> feature
            that may be allowed implementing interface types with some types that I cannot modify them,
            just like <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
            <typeparam name="T">The generic type argument.</typeparam>
        </member>
        <member name="T:System.Linq.SpanGrouping`2">
            <summary>
            Represents a type that enumerates elements of type <typeparamref name="TSource"/> in a <see cref="T:System.ReadOnlySpan`1"/>,
            grouped by the specified key of type <typeparamref name="TKey"/>.
            </summary>
            <typeparam name="TSource">The type of each element.</typeparam>
            <typeparam name="TKey">The type of the key.</typeparam>
            <param name="elements">Indicates the elements.</param>
            <param name="key">Indicates the key that can compare each element.</param>
        </member>
        <member name="M:System.Linq.SpanGrouping`2.#ctor(`0[],`1)">
            <summary>
            Represents a type that enumerates elements of type <typeparamref name="TSource"/> in a <see cref="T:System.ReadOnlySpan`1"/>,
            grouped by the specified key of type <typeparamref name="TKey"/>.
            </summary>
            <typeparam name="TSource">The type of each element.</typeparam>
            <typeparam name="TKey">The type of the key.</typeparam>
            <param name="elements">Indicates the elements.</param>
            <param name="key">Indicates the key that can compare each element.</param>
        </member>
        <member name="P:System.Linq.SpanGrouping`2.Length">
            <summary>
            Indicates the length of the value.
            </summary>
        </member>
        <member name="P:System.Linq.SpanGrouping`2.SourceSpan">
            <summary>
            Creates a <see cref="T:System.ReadOnlySpan`1"/> instance that is aligned as <see cref="F:System.Linq.SpanGrouping`2._elements"/>.
            </summary>
            <seealso cref="F:System.Linq.SpanGrouping`2._elements"/>
        </member>
        <member name="P:System.Linq.SpanGrouping`2.System#Linq#IMyGrouping{System#Linq#SpanGrouping{TSource,TKey},TKey,TSource}#Elements">
            <inheritdoc/>
        </member>
        <member name="P:System.Linq.SpanGrouping`2.Item(System.Int32)">
            <summary>
            Gets the element at the specified index.
            </summary>
            <param name="index">The desired index.</param>
            <returns>The reference to the element at the specified index.</returns>
        </member>
        <member name="M:System.Linq.SpanGrouping`2.Equals(System.Linq.SpanGrouping{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.SpanGrouping`2.Select``1(System.Func{`0,``0})">
            <summary>
            Projects elements into a new form.
            </summary>
            <typeparam name="TResult">The type of each element in result collection.</typeparam>
            <param name="selector">The selector method that transform the object into new one.</param>
            <returns>A list of <typeparamref name="TResult"/> values.</returns>
        </member>
        <member name="M:System.Linq.SpanGrouping`2.Where(System.Func{`0,System.Boolean})">
            <summary>
            Filters the collection, only reserving elements satisfying the specified condition.
            </summary>
            <param name="predicate">The condition that checks for each element.</param>
            <returns>A list of <typeparamref name="TSource"/> elements satisfying the condition.</returns>
        </member>
        <member name="M:System.Linq.SpanGrouping`2.AsSpan">
            <summary>
            Casts the current object into a <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
            <returns>A <see cref="T:System.ReadOnlySpan`1"/> instance.</returns>
        </member>
        <member name="M:System.Linq.SpanGrouping`2.GetEnumerator">
            <summary>
            Creates an enumerator that can enumerate each element in the source collection.
            </summary>
            <returns>An enumerator instance.</returns>
        </member>
        <member name="M:System.Linq.SpanGrouping`2.GetPinnableReference">
            <inheritdoc cref="M:System.ReadOnlySpan`1.GetPinnableReference"/>
        </member>
        <member name="M:System.Linq.SpanGrouping`2.System#Linq#Providers#ISelectMethod{System#Linq#SpanGrouping{TSource,TKey},TSource}#Select``1(System.Func{`0,``0})">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.SpanGrouping`2.System#Linq#Providers#IWhereMethod{System#Linq#SpanGrouping{TSource,TKey},TSource}#Where(System.Func{`0,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="F:System.Linq.SpanGrouping`2._elements">
            <summary>
            The generated field declaration for parameter <c>elements</c>.
            </summary>
        </member>
        <member name="P:System.Linq.SpanGrouping`2.Key">
            <summary>
            The generated property declaration for parameter <c>key</c>.
            </summary>
        </member>
        <member name="M:System.Linq.SpanGrouping`2.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.Linq.SpanGrouping`2.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:System.Linq.SpanGrouping`2.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:System.Linq.SpanGrouping`2.op_Equality(System.Linq.SpanGrouping{`0,`1},System.Linq.SpanGrouping{`0,`1})">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:System.Linq.SpanGrouping`2.op_Inequality(System.Linq.SpanGrouping{`0,`1},System.Linq.SpanGrouping{`0,`1})">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:System.Linq.SpanOrderedEnumerable`1">
            <summary>
            Represents an enumerable instance that is based on a <see cref="T:System.ReadOnlySpan`1" />.
            </summary>
            <typeparam name="T">Indicates the type of each element.</typeparam>
            <param name="values">Indicates the values.</param>
            <param name="selectors">
            <para>Indicates the selector functions that return <typeparamref name="T" /> instances, to be used as comparison.</para>
            <feature name="scoped-keyword">
			<para>
				The keyword <see langword="scoped" /> means the argument and local variable can only be used inside the method.
				This means you cannot use this variable and argument outside the scope,
				such as <c>new RefStructType(scoped_variable)</c>, <c>return scoped_variable</c> and <c>field = scoped_variable</c>.
				Such expressions may store the <see langword="scoped" /> variables, unsafely expanding the variable's lifecycle.
			</para>
		</feature>
            <target name="parameter">
				<para>
					If a <see langword="ref struct" />-typed parameter is marked as <see langword="params" />,
					it will be implicit-<see langword="scoped" />, which means you must use this variables inside the method.
					Value-storages are not permitted.
				</para>
				<para>
					Use <see cref="T:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute" /> if you want to store variable values.
				</para>
			</target>
            </param>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.#ctor(System.ReadOnlySpan{`0},System.ReadOnlySpan{System.Func{`0,`0,System.Int32}})">
            <summary>
            Represents an enumerable instance that is based on a <see cref="T:System.ReadOnlySpan`1" />.
            </summary>
            <typeparam name="T">Indicates the type of each element.</typeparam>
            <param name="values">Indicates the values.</param>
            <param name="selectors">
            <para>Indicates the selector functions that return <typeparamref name="T" /> instances, to be used as comparison.</para>
            <feature name="scoped-keyword">
			<para>
				The keyword <see langword="scoped" /> means the argument and local variable can only be used inside the method.
				This means you cannot use this variable and argument outside the scope,
				such as <c>new RefStructType(scoped_variable)</c>, <c>return scoped_variable</c> and <c>field = scoped_variable</c>.
				Such expressions may store the <see langword="scoped" /> variables, unsafely expanding the variable's lifecycle.
			</para>
		</feature>
            <target name="parameter">
				<para>
					If a <see langword="ref struct" />-typed parameter is marked as <see langword="params" />,
					it will be implicit-<see langword="scoped" />, which means you must use this variables inside the method.
					Value-storages are not permitted.
				</para>
				<para>
					Use <see cref="T:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute" /> if you want to store variable values.
				</para>
			</target>
            </param>
        </member>
        <member name="P:System.Linq.SpanOrderedEnumerable`1.Length">
            <summary>
            Indicates the number of elements stored in the collection.
            </summary>
        </member>
        <member name="P:System.Linq.SpanOrderedEnumerable`1.System#Collections#Generic#IReadOnlyCollection{T}#Count">
            <inheritdoc/>
        </member>
        <member name="P:System.Linq.SpanOrderedEnumerable`1.Span">
            <summary>
            Creates an ordered <see cref="T:System.Span`1"/> instance.
            </summary>
            <returns>An ordered <see cref="T:System.Span`1"/> instance, whose value is from the current enumerable instance.</returns>
        </member>
        <member name="P:System.Linq.SpanOrderedEnumerable`1.Item(System.Int32)">
            <inheritdoc cref="P:System.ReadOnlySpan`1.Item(System.Int32)"/>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.Select``1(System.Func{`0,``0})">
            <summary>
            Projects each element into a new transform.
            </summary>
            <typeparam name="TResult">The type of the result values.</typeparam>
            <param name="selector">The selector to be used by transforming the <typeparamref name="T"/> instances.</param>
            <returns>A span of <typeparamref name="TResult"/> values.</returns>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.Where(System.Func{`0,System.Boolean})">
            <summary>
            Filters the collection using the specified condition.
            </summary>
            <param name="condition">The condition to be used.</param>
            <returns>A span of <typeparamref name="T"/> instances.</returns>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.OrderBy``1(System.Func{`0,``0})">
            <summary>
            <para>Same as <see cref="M:System.Linq.SpanOrderedEnumerable`1.ThenBy``1(System.Func{`0,``0})"/>.</para>
            <para>
            In query expression level, this method will be a little different with standard LINQ design -
            two adjacent <see langword="orderby"/> clauses will be translated into two methods invocation:
            methods <see cref="M:System.Linq.SpanOrderedEnumerable`1.OrderBy``1(System.Func{`0,``0})"/> and <see cref="M:System.Linq.SpanOrderedEnumerable`1.OrderByDescending``1(System.Func{`0,``0})"/>.
            However, due to consideration of optimization on syntax, the second <see langword="orderby"/> clause
            will be treated as <see cref="M:System.Linq.SpanOrderedEnumerable`1.ThenBy``1(System.Func{`0,``0})"/> or <see cref="M:System.Linq.SpanOrderedEnumerable`1.ThenByDescending``1(System.Func{`0,``0})"/>
            invocation instead.
            </para>
            </summary>
            <typeparam name="TKey">The type of key.</typeparam>
            <param name="selector">The selector.</param>
            <returns>A <see cref="T:System.Linq.SpanOrderedEnumerable`1"/> instance, with a new selector added in the current instance.</returns>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.OrderByDescending``1(System.Func{`0,``0})">
            <summary>
            <para>Same as <see cref="M:System.Linq.SpanOrderedEnumerable`1.ThenByDescending``1(System.Func{`0,``0})"/>.</para>
            <para><inheritdoc cref="M:System.Linq.SpanOrderedEnumerable`1.OrderBy``1(System.Func{`0,``0})" path="/summary/para[2]"/></para>
            </summary>
            <typeparam name="TKey">The type of key.</typeparam>
            <param name="selector">The selector.</param>
            <returns>A <see cref="T:System.Linq.SpanOrderedEnumerable`1"/> instance, with a new selector added in the current instance.</returns>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.ThenBy``1(System.Func{`0,``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.ThenByDescending``1(System.Func{`0,``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.GroupBy``1(System.Func{`0,``0})">
            <inheritdoc cref="M:System.Linq.SpanEnumerable.GroupBy``2(System.ReadOnlySpan{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.GroupBy``2(System.Func{`0,``0},System.Func{`0,``1})">
            <inheritdoc cref="M:System.Linq.SpanEnumerable.GroupBy``3(System.ReadOnlySpan{``0},System.Func{``0,``1},System.Func{``0,``2})"/>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.Slice(System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Linq.Providers.ISliceMethod`2.Slice(System.Int32,System.Int32)"/>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.GetEnumerator">
            <inheritdoc cref="M:System.ReadOnlySpan`1.GetEnumerator"/>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.AsArrayOrderedEnumerable">
            <summary>
            Casts the current instance into equivalent-comparison <see cref="T:System.Linq.ArrayOrderedEnumerable`1"/> instance.
            </summary>
            <returns>An <see cref="T:System.Linq.ArrayOrderedEnumerable`1"/> instance.</returns>
            <seealso cref="T:System.Linq.ArrayOrderedEnumerable`1"/>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.ToArray">
            <inheritdoc cref="M:System.Linq.Providers.IToArrayMethod`2.ToArray"/>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.System#Linq#IOrderedEnumerable{T}#CreateOrderedEnumerable``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0},System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.System#Linq#Providers#IGroupByMethod{System#Linq#SpanOrderedEnumerable{T},T}#GroupBy``1(System.Func{`0,``0})">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.System#Linq#Providers#IGroupByMethod{System#Linq#SpanOrderedEnumerable{T},T}#GroupBy``2(System.Func{`0,``0},System.Func{`0,``1})">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.System#Linq#Providers#IGroupByMethod{System#Linq#SpanOrderedEnumerable{T},T}#GroupBy``1(System.Func{`0,``0},System.Collections.Generic.IEqualityComparer{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})"/>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.System#Linq#Providers#IGroupByMethod{System#Linq#SpanOrderedEnumerable{T},T}#GroupBy``2(System.Func{`0,``0},System.Func{`0,``1},System.Collections.Generic.IEqualityComparer{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})"/>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.System#Linq#Providers#IGroupByMethod{System#Linq#SpanOrderedEnumerable{T},T}#GroupBy``3(System.Func{`0,``0},System.Func{`0,``1},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``2})">
            <inheritdoc cref="M:System.Linq.Enumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3})"/>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.System#Linq#Providers#IGroupByMethod{System#Linq#SpanOrderedEnumerable{T},T}#GroupBy``3(System.Func{`0,``0},System.Func{`0,``1},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``2},System.Collections.Generic.IEqualityComparer{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3},System.Collections.Generic.IEqualityComparer{``1})"/>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.System#Linq#Providers#ISelectMethod{System#Linq#SpanOrderedEnumerable{T},T}#Select``1(System.Func{`0,``0})">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.System#Linq#Providers#ISelectMethod{System#Linq#SpanOrderedEnumerable{T},T}#Select``1(System.Func{`0,System.Int32,``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,``1})"/>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.System#Linq#Providers#ISliceMethod{System#Linq#SpanOrderedEnumerable{T},T}#Slice(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.System#Linq#Providers#IWhereMethod{System#Linq#SpanOrderedEnumerable{T},T}#Where(System.Func{`0,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.System#Linq#Providers#IWhereMethod{System#Linq#SpanOrderedEnumerable{T},T}#Where(System.Func{`0,System.Int32,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})"/>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.System#Linq#Providers#IThenByMethod{System#Linq#SpanOrderedEnumerable{T},T}#ThenBy``1(System.Func{`0,``0})">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.System#Linq#Providers#IThenByMethod{System#Linq#SpanOrderedEnumerable{T},T}#ThenByDescending``1(System.Func{`0,``0})">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.System#Linq#Providers#IThenByMethod{System#Linq#SpanOrderedEnumerable{T},T}#ThenBy``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})"/>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.System#Linq#Providers#IThenByMethod{System#Linq#SpanOrderedEnumerable{T},T}#ThenByDescending``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})"/>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.Create``1(System.ReadOnlySpan{`0},System.Func{`0,``0},System.Collections.Generic.IComparer{``0},System.Boolean)">
            <summary>
            Creates an <see cref="T:System.Linq.SpanOrderedEnumerable`1"/> instance via the specified values.
            </summary>
            <typeparam name="TKey">The type of the key to be compared.</typeparam>
            <param name="values">The values to be used.</param>
            <param name="keySelector">
            The selector method that calculates a <typeparamref name="TKey"/> from each <typeparamref name="T"/> instance.
            </param>
            <param name="comparer">
            A comparable instance that temporarily checks the comparing result of two <typeparamref name="TKey"/> values.
            </param>
            <param name="descending">A <see cref="T:System.Boolean"/> value indicating whether the creation is for descending comparison rule.</param>
            <returns>An <see cref="T:System.Linq.SpanOrderedEnumerable`1"/> instance.</returns>
        </member>
        <member name="F:System.Linq.SpanOrderedEnumerable`1._values">
            <summary>
            The generated field declaration for parameter <c>values</c>.
            </summary>
        </member>
        <member name="F:System.Linq.SpanOrderedEnumerable`1._selectors">
            <summary>
            The generated field declaration for parameter <c>selectors</c>.
            </summary>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:System.Linq.SpanOrderedEnumerable`1.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:System.Linq.StringEnumerable">
            <summary>
            Provides with LINQ methods on a <see cref="T:System.String"/> value.
            </summary>
        </member>
        <member name="M:System.Linq.StringEnumerable.Index(System.String)">
            <inheritdoc cref="M:System.Linq.Enumerable.Index``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:System.Linq.StringEnumerable.Select``1(System.String,System.Func{System.Char,``0})">
            <summary>
            <inheritdoc cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" path="/summary"/>
            </summary>
            <param name="this">The string instance.</param>
            <param name="selector">
            <inheritdoc cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" path="/param[@name='selector']"/>
            </param>
            <returns>
            A <see cref="T:System.ReadOnlySpan`1"/> of <typeparamref name="TResult"/> whose elements are the result of invoking the transfrom function
            on each element of <paramref name="this"/>.
            </returns>
        </member>
        <member name="M:System.Linq.StringEnumerable.Where(System.String,System.Func{System.Char,System.Boolean})">
            <summary>
            <inheritdoc cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" path="/summary"/>
            </summary>
            <param name="this">The string instance.</param>
            <param name="predicate">
            <inheritdoc cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" path="/param[@name='selector']"/>
            </param>
            <returns>
            A new <see cref="T:System.String"/> instance that contains characters from the input sequence that satisfy the condition.
            </returns>
        </member>
        <member name="M:System.Linq.StringEnumerable.SelectMany(System.String,System.Func{System.Char,System.String},System.Func{System.Char,System.Char,System.String})">
            <summary>
            Projects each element of a sequence to a <see cref="T:System.String"/>, flattens the resulting sequences into one sequence,
            and invokes a result selector function on each element therein.
            </summary>
            <param name="this"></param>
            <param name="collectionSelector"></param>
            <param name="resultSelector"></param>
            <returns>
            A <see cref="T:System.String"/> whose elements are the result of invoking the one-to-many transform function
            <paramref name="collectionSelector"/> on each element of <paramref name="this"/>
            and then mapping each of those sequence elements and their corresponding source element to a result element.
            </returns>
        </member>
        <member name="T:System.Linq.TupleEnumerable">
            <summary>
            Provides with LINQ methods for <see cref="T:System.Runtime.CompilerServices.ITuple"/> instances.
            </summary>
            <seealso cref="T:System.Runtime.CompilerServices.ITuple"/>
        </member>
        <member name="M:System.Linq.TupleEnumerable.Cast``1(System.Runtime.CompilerServices.ITuple)">
            <inheritdoc cref="M:System.Linq.Enumerable.Cast``1(System.Collections.IEnumerable)"/>
        </member>
        <member name="M:System.Linq.TupleEnumerable.Select``2(System.Runtime.CompilerServices.ITuple,System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="T:System.Linq.ValueLookup`2">
            <summary>
            Represents an instance that supports looking up on elements of type <typeparamref name="TElement"/>,
            grouped by key of type <typeparamref name="TKey"/>.
            </summary>
            <param name="groups">Indicates the groups to be initialized.</param>
            <typeparam name="TKey">The type of key.</typeparam>
            <typeparam name="TElement">The type of each element.</typeparam>
            <remarks>
            Please note, this type only supports for <see cref="T:System.Linq.Providers.ISelectMethod`2"/>,
            <see cref="T:System.Linq.Providers.ISelectManyMethod`2"/> and <see cref="T:System.Linq.Providers.IWhereMethod`2"/>,
            while other LINQ methods are not supported.
            If you want to use advanced ones, cast the object to a <see cref="T:System.ReadOnlySpan`1"/> by calling
            method <see cref="M:System.Linq.ValueLookup`2.AsSpan"/> and try them up then.
            </remarks>
        </member>
        <member name="M:System.Linq.ValueLookup`2.#ctor(System.Collections.Generic.Dictionary{`0,`1[]})">
            <summary>
            Represents an instance that supports looking up on elements of type <typeparamref name="TElement"/>,
            grouped by key of type <typeparamref name="TKey"/>.
            </summary>
            <param name="groups">Indicates the groups to be initialized.</param>
            <typeparam name="TKey">The type of key.</typeparam>
            <typeparam name="TElement">The type of each element.</typeparam>
            <remarks>
            Please note, this type only supports for <see cref="T:System.Linq.Providers.ISelectMethod`2"/>,
            <see cref="T:System.Linq.Providers.ISelectManyMethod`2"/> and <see cref="T:System.Linq.Providers.IWhereMethod`2"/>,
            while other LINQ methods are not supported.
            If you want to use advanced ones, cast the object to a <see cref="T:System.ReadOnlySpan`1"/> by calling
            method <see cref="M:System.Linq.ValueLookup`2.AsSpan"/> and try them up then.
            </remarks>
        </member>
        <member name="P:System.Linq.ValueLookup`2.Count">
            <inheritdoc/>
        </member>
        <member name="P:System.Linq.ValueLookup`2.Keys">
            <inheritdoc cref="P:System.Collections.Generic.IReadOnlyDictionary`2.Keys"/>
        </member>
        <member name="P:System.Linq.ValueLookup`2.Values">
            <inheritdoc cref="P:System.Collections.Generic.IReadOnlyDictionary`2.Values"/>
        </member>
        <member name="P:System.Linq.ValueLookup`2.System#Collections#Generic#IReadOnlyDictionary{TKey,TElement[]}#Keys">
            <inheritdoc/>
        </member>
        <member name="P:System.Linq.ValueLookup`2.System#Collections#Generic#IReadOnlyDictionary{TKey,TElement[]}#Values">
            <inheritdoc/>
        </member>
        <member name="P:System.Linq.ValueLookup`2.Item(`0)">
            <inheritdoc cref="P:System.Linq.ILookup`2.Item(`0)"/>
        </member>
        <member name="P:System.Linq.ValueLookup`2.System#Collections#Generic#IReadOnlyDictionary{TKey,TElement[]}#Item(`0)">
            <inheritdoc/>
        </member>
        <member name="P:System.Linq.ValueLookup`2.System#Linq#ILookup{TKey,TElement}#Item(`0)">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.ValueLookup`2.ContainsKey(`0)">
            <inheritdoc cref="M:System.Linq.ILookup`2.Contains(`0)"/>
        </member>
        <member name="M:System.Linq.ValueLookup`2.AsSpan">
            <summary>
            Converts the current instance into a <see cref="T:System.ReadOnlySpan`1"/> of <see cref="T:System.Linq.SpanGrouping`2"/> instance.
            </summary>
            <returns>An instance of type <see cref="T:System.ReadOnlySpan`1"/> of <see cref="T:System.Linq.SpanGrouping`2"/>.</returns>
        </member>
        <member name="M:System.Linq.ValueLookup`2.AsDictionary">
            <summary>
            Converts the current instance into a <see cref="T:System.Collections.Generic.Dictionary`2"/> instance.
            </summary>
            <returns>The converted <see cref="T:System.Collections.Generic.Dictionary`2"/> instance.</returns>
        </member>
        <member name="M:System.Linq.ValueLookup`2.System#Linq#ILookup{TKey,TElement}#Contains(`0)">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.ValueLookup`2.TryGetValue(`0,`1[]@)">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.ValueLookup`2.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
        </member>
        <member name="M:System.Linq.ValueLookup`2.Select``1(System.Func{System.Linq.SpanGrouping{`1,`0},``0})">
            <inheritdoc cref="M:System.Linq.Providers.ISelectMethod`2.Select``1(System.Func{`1,``0})"/>
        </member>
        <member name="M:System.Linq.ValueLookup`2.SelectMany``1(System.Func{System.Linq.SpanGrouping{`1,`0},System.ReadOnlySpan{``0}})">
            <inheritdoc cref="M:System.Linq.Providers.ISelectManyMethod`2.SelectMany``1(System.Func{`1,System.Collections.Generic.IEnumerable{``0}})"/>
        </member>
        <member name="M:System.Linq.ValueLookup`2.SelectMany``2(System.Func{System.Linq.SpanGrouping{`1,`0},System.ReadOnlySpan{``0}},System.Func{System.Linq.SpanGrouping{`1,`0},``0,``1})">
            <inheritdoc cref="M:System.Linq.Providers.ISelectManyMethod`2.SelectMany``2(System.Func{`1,System.Collections.Generic.IEnumerable{``0}},System.Func{`1,``0,``1})"/>
        </member>
        <member name="M:System.Linq.ValueLookup`2.Where(System.Func{System.Linq.SpanGrouping{`1,`0},System.Boolean})">
            <inheritdoc cref="M:System.Linq.Providers.IWhereMethod`2.Where(System.Func{`1,System.Boolean})"/>
        </member>
        <member name="M:System.Linq.ValueLookup`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.ValueLookup`2.System#Collections#Generic#IEnumerable{System#Linq#IGrouping{TKey,TElement}}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.ValueLookup`2.System#Collections#Generic#IEnumerable{System#Linq#SpanGrouping{TElement,TKey}}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.ValueLookup`2.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{TKey,TElement[]}}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="T:System.Linq.ValueLookup`2.Enumerator">
            <summary>
            Represents an enumerator type that supports iterating on each element of <see cref="T:System.Linq.SpanGrouping`2"/>.
            </summary>
            <param name="_groups">The groups.</param>
            <seealso cref="T:System.Linq.SpanGrouping`2"/>
        </member>
        <member name="M:System.Linq.ValueLookup`2.Enumerator.#ctor(System.Collections.Generic.Dictionary{`0,`1[]})">
            <summary>
            Represents an enumerator type that supports iterating on each element of <see cref="T:System.Linq.SpanGrouping`2"/>.
            </summary>
            <param name="_groups">The groups.</param>
            <seealso cref="T:System.Linq.SpanGrouping`2"/>
        </member>
        <member name="F:System.Linq.ValueLookup`2.Enumerator._enumerator">
            <summary>
            Indicates the backing enumerator.
            </summary>
        </member>
        <member name="P:System.Linq.ValueLookup`2.Enumerator.Current">
            <inheritdoc/>
        </member>
        <member name="P:System.Linq.ValueLookup`2.Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.ValueLookup`2.Enumerator.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
        </member>
        <member name="M:System.Linq.ValueLookup`2.Enumerator.MoveNext">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.ValueLookup`2.Enumerator.System#IDisposable#Dispose">
            <inheritdoc/>
        </member>
        <member name="M:System.Linq.ValueLookup`2.Enumerator.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="F:System.Linq.ValueLookup`2._groups">
            <summary>
            The generated field declaration for parameter <c>groups</c>.
            </summary>
        </member>
        <member name="T:System.Text.RegularExpressions.GroupCollectionEnumerable">
            <summary>
            Provides LINQ-based extension methods on <see cref="T:System.Text.RegularExpressions.GroupCollection"/>.
            </summary>
            <seealso cref="T:System.Text.RegularExpressions.GroupCollection"/>
        </member>
        <member name="M:System.Text.RegularExpressions.GroupCollectionEnumerable.Select``1(System.Text.RegularExpressions.GroupCollection,System.Func{System.Text.RegularExpressions.Group,``0})">
            <inheritdoc cref="M:System.Linq.SpanEnumerable.Select``2(System.ReadOnlySpan{``0},System.Func{``0,``1})"/>
        </member>
        <member name="T:System.Text.RegularExpressions.MatchCollectionEnumerable">
            <summary>
            Provides LINQ-based extension methods on <see cref="T:System.Text.RegularExpressions.MatchCollection"/>.
            </summary>
            <seealso cref="T:System.Text.RegularExpressions.MatchCollection"/>
        </member>
        <member name="M:System.Text.RegularExpressions.MatchCollectionEnumerable.Select``1(System.Text.RegularExpressions.MatchCollection,System.Func{System.Text.RegularExpressions.Match,``0})">
            <inheritdoc cref="M:System.Linq.SpanEnumerable.Select``2(System.ReadOnlySpan{``0},System.Func{``0,``1})"/>
        </member>
        <member name="T:System.Text.RegularExpressions.RegexExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.
            </summary>
            <seealso cref="T:System.Text.RegularExpressions.Regex"/>
        </member>
        <member name="T:System.Text.RegularExpressions.RegexExtensions.">
            <summary>
            Provides extension members on <see cref="T:System.Text.RegularExpressions.Regex"/>.
            </summary>
        </member>
        <member name="M:System.Text.RegularExpressions.RegexExtensions..FindOccurenceAt(System.ReadOnlySpan{System.Char},System.Int32)">
            <summary>
            Find the string pattern occurred at the specified time from the specified string.
            </summary>
            <param name="str">The string to be matched.</param>
            <param name="index">The index.</param>
            <returns>The index.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.ValueMatchExtensions">
            <summary>
            Provides with extension methdos on <see cref="T:System.Text.RegularExpressions.ValueMatch"/>.
            </summary>
            <seealso cref="T:System.Text.RegularExpressions.ValueMatch"/>
        </member>
        <member name="T:System.Text.RegularExpressions.ValueMatchExtensions.">
            <summary>
            Provides extension members on <see cref="T:System.Text.RegularExpressions.ValueMatch"/>.
            </summary>
        </member>
        <member name="M:System.Text.RegularExpressions.ValueMatchExtensions..MatchString(System.ReadOnlySpan{System.Char})">
            <summary>
            Try to get the target match string at the specified position the current instance specified.
            </summary>
            <param name="originalString">The original string.</param>
            <returns>The target string.</returns>
        </member>
        <member name="T:System.Text.Json.CultureInfoConverter">
            <summary>
            Represents a JSON convetrer that serializes and deserializes a <see cref="T:System.Globalization.CultureInfo"/> object.
            </summary>
            <seealso cref="T:System.Globalization.CultureInfo"/>
        </member>
        <member name="P:System.Text.Json.CultureInfoConverter.HandleNull">
            <inheritdoc/>
        </member>
        <member name="P:System.Text.Json.CultureInfoConverter.UseUserOverride">
            <summary>
            <para><inheritdoc cref="M:System.Globalization.CultureInfo.#ctor(System.String,System.Boolean)" path="/param[@name='useUserOverride']"/></para>
            <para>The default value is <see langword="true"/>.</para>
            </summary>
        </member>
        <member name="M:System.Text.Json.CultureInfoConverter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:System.Text.Json.CultureInfoConverter.Write(System.Text.Json.Utf8JsonWriter,System.Globalization.CultureInfo,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="T:System.Text.Json.DateOnlyConverter">
            <summary>
            Represents a converter for <see cref="T:System.DateOnly"/> instance.
            </summary>
            <seealso cref="T:System.DateOnly"/>
        </member>
        <member name="P:System.Text.Json.DateOnlyConverter.Format">
            <summary>
            Indicates the format text to be used.
            </summary>
        </member>
        <member name="M:System.Text.Json.DateOnlyConverter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:System.Text.Json.DateOnlyConverter.Write(System.Text.Json.Utf8JsonWriter,System.DateOnly,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="T:System.Text.Json.JsonSerializerOptionsExtensions">
            <summary>
            Provides extension methods on <see cref="T:System.Text.Json.JsonSerializerOptions"/>.
            </summary>
            <seealso cref="T:System.Text.Json.JsonSerializerOptions"/>
        </member>
        <member name="T:System.Text.Json.JsonSerializerOptionsExtensions.">
            <summary>
            Provides extension members on <see cref="T:System.Text.Json.JsonSerializerOptions"/>.
            </summary>
        </member>
        <member name="M:System.Text.Json.JsonSerializerOptionsExtensions..GetConverter``2">
            <summary>
            Returns the converter that supports the given type, or the <typeparamref name="TConverter"/>
            will be used when the property <see cref="P:System.Text.Json.JsonSerializerOptions.Converters"/>
            doesn't contain any valid converters.
            </summary>
            <typeparam name="T">The type to get converter.</typeparam>
            <typeparam name="TConverter">
            The type that is the converter type to convert the instance of type <typeparamref name="T"/>.
            </typeparam>
            <returns>
            The converter that supports the given type, or the <typeparamref name="TConverter"/>
            will be used when the property <see cref="P:System.Text.Json.JsonSerializerOptions.Converters"/>
            doesn't contain any valid converters.
            </returns>
            <seealso cref="P:System.Text.Json.JsonSerializerOptions.Converters"/>
        </member>
        <member name="T:System.Text.Json.PascalCaseJsonNamingPolicy">
            <summary>
            Defines the pascal casing JSON naming policy.
            </summary>
            <remarks>
            This type cannot be initialized; instead, you can use the property <see cref="P:System.Text.Json.PascalCaseJsonNamingPolicy.PascalCase"/> to get the instance.
            </remarks>
            <seealso cref="P:System.Text.Json.PascalCaseJsonNamingPolicy.PascalCase"/>
        </member>
        <member name="P:System.Text.Json.PascalCaseJsonNamingPolicy.PascalCase">
            <summary>
            Gets the naming policy for pascal-casing.
            </summary>
            <returns>The naming policy for pascal-casing.</returns>
        </member>
        <member name="M:System.Text.Json.PascalCaseJsonNamingPolicy.ConvertName(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:System.Text.Json.RangeConverter">
            <summary>
            Represents a JSON converter that serializes and deserializes a <see cref="T:System.Range"/> object.
            </summary>
            <seealso cref="T:System.Range"/>
        </member>
        <member name="M:System.Text.Json.RangeConverter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:System.Text.Json.RangeConverter.Write(System.Text.Json.Utf8JsonWriter,System.Range,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="T:System.Text.Json.ReadOnlyMemoryConverter`1">
            <summary>
            Represents a JSON converter that can convert <see cref="T:System.ReadOnlyMemory`1"/> instances into JSON strings.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
        </member>
        <member name="P:System.Text.Json.ReadOnlyMemoryConverter`1.HandleNull">
            <inheritdoc/>
        </member>
        <member name="M:System.Text.Json.ReadOnlyMemoryConverter`1.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:System.Text.Json.ReadOnlyMemoryConverter`1.Write(System.Text.Json.Utf8JsonWriter,System.ReadOnlyMemory{`0},System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="T:System.Text.Json.Utf8JsonReaderExtensions">
            <summary>
            Provides extension methods on <see cref="T:System.Text.Json.Utf8JsonReader"/>.
            </summary>
            <seealso cref="T:System.Text.Json.Utf8JsonReader"/>
        </member>
        <member name="T:System.Text.Json.Utf8JsonReaderExtensions.">
            <summary>
            Provides extension members on <see langword="ref"/> <see cref="T:System.Text.Json.Utf8JsonReader"/>.
            </summary>
        </member>
        <member name="M:System.Text.Json.Utf8JsonReaderExtensions..GetNestedObject``1(System.Text.Json.JsonSerializerOptions)">
            <summary>
            To read as a nested object in the JSON string stream.
            </summary>
            <typeparam name="T">The type of the instance to be deserialized.</typeparam>
            <param name="options">The options.</param>
        </member>
        <member name="T:System.Text.Json.Utf8JsonWriterExtensions">
            <summary>
            Provides extension methods on <see cref="T:System.Text.Json.Utf8JsonWriter"/>.
            </summary>
            <seealso cref="T:System.Text.Json.Utf8JsonWriter"/>
        </member>
        <member name="T:System.Text.Json.Utf8JsonWriterExtensions.">
            <summary>
            Provides extension members on <see cref="T:System.Text.Json.Utf8JsonWriter"/>.
            </summary>
        </member>
        <member name="M:System.Text.Json.Utf8JsonWriterExtensions..WriteNestedObject``1(``0,System.Text.Json.JsonSerializerOptions)">
            <summary>
            To write an object as nested one in the JSON string stream.
            </summary>
            <typeparam name="T">The type of the instance to be serialized.</typeparam>
            <param name="instance">The instance to be serialized.</param>
            <param name="options">The options.</param>
        </member>
        <member name="M:System.Text.Json.Utf8JsonWriterExtensions..WriteArray``1(``0[],System.Text.Json.JsonSerializerOptions)">
            <summary>
            To write an array of element type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="array">The array.</param>
            <param name="options">The options.</param>
        </member>
        <member name="T:System.Text.StringBuilderExtensions">
            <summary>
            Provides extension methods on <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <seealso cref="T:System.Text.StringBuilder"/>
        </member>
        <member name="T:System.Text.StringBuilderExtensions.">
            <summary>
            Provides extension members on <see cref="T:System.Text.StringBuilder"/>.
            </summary>
        </member>
        <member name="M:System.Text.StringBuilderExtensions..RemoveFrom(System.Int32)">
            <summary>
            Remove all characters behind the character whose index is specified.
            </summary>
            <param name="startIndex">The start index.</param>
            <returns>The reference of the current instance.</returns>
        </member>
        <member name="M:System.Text.StringBuilderExtensions..RemoveFrom(System.Index)">
            <summary>
            Remove all characters behind the character whose index is specified.
            </summary>
            <param name="startIndex">The start index.</param>
            <returns>The reference of the current instance.</returns>
        </member>
        <member name="M:System.Text.StringBuilderExtensions..AppendRange``1(System.Func{``0,System.String},System.Func{System.Text.StringBuilder,System.String,System.Text.StringBuilder},System.ReadOnlySpan{``0})">
            <summary>
            Appends a list of elements of type <typeparamref name="T" /> into the <see cref="T:System.Text.StringBuilder" /> instance,
            using the specified converter to convert each element into <see cref="T:System.String" /> value.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="stringConverter">The converter method.</param>
            <param name="appender">
            The append method for the builder instance, telling the handler which appending operation will be handled.
            By default, the method is equivalent to lambda:
            <code>
            <see langword="static" /> (<see cref="T:System.Text.StringBuilder" /> sb, <typeparamref name="T" /> v) =&gt; sb.Append(v)
            </code>
            </param>
            <param name="elements">
            <para>The elements to be appended.</para>
            <target name="parameter">
				<para>
					If a <see langword="ref struct" />-typed parameter is marked as <see langword="params" />,
					it will be implicit-<see langword="scoped" />, which means you must use this variables inside the method.
					Value-storages are not permitted.
				</para>
				<para>
					Use <see cref="T:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute" /> if you want to store variable values.
				</para>
			</target>
            </param>
            <returns>The reference of the current instance.</returns>
        </member>
        <member name="T:System.Text.VariableExtractor">
            <summary>
            Represents a type that can analyze text difference and fetch the values on different parts, parsing them into variables.
            </summary>
            <param name="literalLength">Indicates the number of characters in literal.</param>
            <param name="formattedCount">Indicates the number of interpolated items (variables).</param>
            <param name="original">Indicates the original string to be parsed.</param>
        </member>
        <member name="M:System.Text.VariableExtractor.#ctor(System.Int32,System.Int32,System.String)">
            <summary>
            Represents a type that can analyze text difference and fetch the values on different parts, parsing them into variables.
            </summary>
            <param name="literalLength">Indicates the number of characters in literal.</param>
            <param name="formattedCount">Indicates the number of interpolated items (variables).</param>
            <param name="original">Indicates the original string to be parsed.</param>
        </member>
        <member name="F:System.Text.VariableExtractor.PlaceholderReservedCharacter">
            <summary>
            Indicates the placeholder character.
            </summary>
        </member>
        <member name="F:System.Text.VariableExtractor._pointers">
            <summary>
            Indicates the string variable pointers.
            </summary>
        </member>
        <member name="F:System.Text.VariableExtractor._builder">
            <summary>
            Indicates the backing builder object.
            </summary>
        </member>
        <member name="F:System.Text.VariableExtractor._index">
            <summary>
            Indicates the current variable index.
            </summary>
        </member>
        <member name="M:System.Text.VariableExtractor.AppendLiteral(System.String)">
            <summary>
            Appends a list of unchanged characters into the collection.
            </summary>
            <param name="s">The sequence of characters, unchanged.</param>
        </member>
        <member name="M:System.Text.VariableExtractor.AppendFormatted(System.String@)">
            <summary>
            Appends a variable into the collection, recording its variable pointer (address).
            </summary>
            <param name="variable">The reference to the variable.</param>
        </member>
        <member name="M:System.Text.VariableExtractor.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:System.Text.VariableExtractor.Assign(System.String,System.Text.VariableExtractor@)">
            <summary>
            Try to analyze the text difference and assign to interpolated variables.
            </summary>
            <param name="original">Indicates the original text.</param>
            <param name="extractor">Indicates the interpolated string that inserts custom variables to be parsed.</param>
            <exception cref="T:System.InvalidOperationException">Throws when the text is invalid to be checked.</exception>
        </member>
        <member name="F:System.Text.VariableExtractor._literalLength">
            <summary>
            The generated field declaration for parameter <c>literalLength</c>.
            </summary>
        </member>
        <member name="F:System.Text.VariableExtractor._formattedCount">
            <summary>
            The generated field declaration for parameter <c>formattedCount</c>.
            </summary>
        </member>
        <member name="F:System.Text.VariableExtractor._original">
            <summary>
            The generated field declaration for parameter <c>original</c>.
            </summary>
        </member>
        <member name="M:System.Text.VariableExtractor.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.Text.VariableExtractor.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="T:System.MathExtensions">
            <summary>
            Provides extension methods on <see cref="T:System.Math"/>.
            </summary>
            <seealso cref="T:System.Math"/>
        </member>
        <member name="T:System.MathExtensions.">
            <summary>
            Provides extension members on <see cref="T:System.Math"/>.
            </summary>
        </member>
        <member name="M:System.MathExtensions..Min(System.Int32,System.Int32,System.Int32)">
            <summary>
            Get the minimal one of three values.
            </summary>
            <param name="a">The first value.</param>
            <param name="b">The second value.</param>
            <param name="c">The third value.</param>
            <returns>Which is the minimal value.</returns>
        </member>
        <member name="M:System.MathExtensions..Max(System.Int32,System.Int32,System.Int32)">
            <summary>
            Get the maximum one of three values.
            </summary>
            <param name="a">The first value.</param>
            <param name="b">The second value.</param>
            <param name="c">The third value.</param>
            <returns>Which is the maximum value.</returns>
        </member>
        <member name="T:System.MemoryExtensionsExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.MemoryExtensions"/>.
            </summary>
            <seealso cref="T:System.MemoryExtensions"/>
        </member>
        <member name="T:System.MemoryExtensionsExtensions.`1">
            <summary>
            Provides extension members of <typeparamref name="T"/>[]? instances.
            </summary>
        </member>
        <member name="M:System.MemoryExtensionsExtensions.`1.AsReadOnlySpan">
            <inheritdoc cref="M:System.MemoryExtensions.AsSpan``1(``0[])"/>
        </member>
        <member name="T:System.ModuleInitializer">
            <target name="type">
				<summary>
					<para>
						Provides with the type that contains a module initializer method, called automatically by the CLR
						(Common Language Runtime) to initialize some values.
					</para>
					<para>
						<i>
							The type is called by the compiler and the CLR (Common Language Runtime),
							which means you cannot use any members in this type manually.
						</i>
					</para>
				</summary>
			</target>
        </member>
        <member name="M:System.ModuleInitializer.Initialize">
            <target name="method">
				<summary>
					Called by the runtime automatically while booting on this solution to initialize the values,
					data members or any other things that can or should be initialized here.
				</summary>
				<remarks>
					The concept <b>module</b> is different with <b>assembly</b>.
					The solution can contain multiple assemblies, while each assembly can contain multiple modules.
					However, due to the design of Visual Studio project file system, each assembly will only contain
					one module by default.
				</remarks>
			</target>
        </member>
        <member name="T:System.Numerics.BitCombinationEnumerator`1">
            <summary>
            Indicates the enumerator of the current instance.
            </summary>
            <typeparam name="TInteger">The type of the target integer value.</typeparam>
            <param name="bitCount">The number of bits.</param>
            <param name="oneCount">The number of <see langword="true"/> bits.</param>
        </member>
        <member name="M:System.Numerics.BitCombinationEnumerator`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Indicates the enumerator of the current instance.
            </summary>
            <typeparam name="TInteger">The type of the target integer value.</typeparam>
            <param name="bitCount">The number of bits.</param>
            <param name="oneCount">The number of <see langword="true"/> bits.</param>
        </member>
        <member name="F:System.Numerics.BitCombinationEnumerator`1._mask">
            <summary>
            The mask.
            </summary>
        </member>
        <member name="F:System.Numerics.BitCombinationEnumerator`1._isLast">
            <summary>
            Indicates whether that the value is the last one.
            </summary>
        </member>
        <member name="P:System.Numerics.BitCombinationEnumerator`1.Current">
            <inheritdoc cref="P:System.Collections.IEnumerator.Current"/>
        </member>
        <member name="P:System.Numerics.BitCombinationEnumerator`1.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="M:System.Numerics.BitCombinationEnumerator`1.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:System.Numerics.BitCombinationEnumerator`1.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="M:System.Numerics.BitCombinationEnumerator`1.HasNext">
            <summary>
            Changes the state of the fields, and check whether the bit has another available possibility to be iterated.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:System.Numerics.BitCombinationEnumerator`1.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.Numerics.BitCombinationEnumerator`1.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:System.Numerics.BitCombinationEnumerator`1.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:System.Numerics.BitCombinationEnumerator`1.System#IDisposable#Dispose">
            <inheritdoc/>
            <exception cref="T:System.ObjectDisposedException">Throws when the object had already been disposed.</exception>
        </member>
        <member name="T:System.Numerics.BitCombinationGenerator`1">
            <summary>
            Represents a combination generator that iterations each combination of bits for the specified number of bits, and how many 1's in it.
            </summary>
            <typeparam name="TInteger">The type of the target integer value.</typeparam>
            <param name="bitCount">Indicates the number of bits.</param>
            <param name="oneCount">Indicates the number of bits set <see langword="true"/>.</param>
        </member>
        <member name="M:System.Numerics.BitCombinationGenerator`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Represents a combination generator that iterations each combination of bits for the specified number of bits, and how many 1's in it.
            </summary>
            <typeparam name="TInteger">The type of the target integer value.</typeparam>
            <param name="bitCount">Indicates the number of bits.</param>
            <param name="oneCount">Indicates the number of bits set <see langword="true"/>.</param>
        </member>
        <member name="M:System.Numerics.BitCombinationGenerator`1.GetEnumerator">
            <summary>
            Gets the enumerator of the current instance in order to use <see langword="foreach"/> loop.
            </summary>
            <returns>The enumerator instance.</returns>
        </member>
        <member name="F:System.Numerics.BitCombinationGenerator`1._bitCount">
            <summary>
            The generated field declaration for parameter <c>bitCount</c>.
            </summary>
        </member>
        <member name="F:System.Numerics.BitCombinationGenerator`1._oneCount">
            <summary>
            The generated field declaration for parameter <c>oneCount</c>.
            </summary>
        </member>
        <member name="M:System.Numerics.BitCombinationGenerator`1.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.Numerics.BitCombinationGenerator`1.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:System.Numerics.BitCombinationGenerator`1.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:System.Numerics.BitOperationsExtensions">
            <summary>
            Provides extension methods on <see cref="T:System.Numerics.BitOperations"/>.
            </summary>
            <seealso cref="T:System.Numerics.BitOperations"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.SByte)">
            <summary>
            Find all offsets of set bits of the binary representation of a specified value.
            </summary>
            <param name="this">The value.</param>
            <returns>All offsets.</returns>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.Byte)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.Int16)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.UInt16)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.UInt32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.Int64)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.UInt64)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.Int128)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.UInt128)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.IntPtr)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.UIntPtr)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetAllSets``1(``0)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.SByte)">
            <summary>
            <para>Get an enumerator to iterate on each bits of the specified integer value.</para>
            <para>This method will allow you to use <see langword="foreach"/> loop to iterate on all indices of set bits.</para>
            </summary>
            <param name="this">The value.</param>
            <returns>All indices of set bits.</returns>
            <remarks>
            This method allows you using <see langword="foreach"/> loop to iterate this value:
            <code><![CDATA[
            foreach (var bit in 17)
            {
                // Do something...
            }
            ]]></code>
            </remarks>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.Byte)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.Int16)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.UInt16)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.UInt32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.Int64)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.UInt64)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.Int128)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.UInt128)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.IntPtr)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.UIntPtr)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetEnumerator``1(``0)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetNextSet(System.Byte,System.Int32)">
            <summary>
            Find an index of the binary representation of a value after the specified index whose bit is set <see langword="true"/>.
            </summary>
            <param name="this">The value.</param>
            <param name="index">The index. The value will be automatically plus 1 in loop. Don't pass the value added 1.</param>
            <returns>The index.</returns>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetNextSet(System.Int16,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetNextSet(System.Byte,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetNextSet(System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetNextSet(System.Byte,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetNextSet(System.Int64,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetNextSet(System.Byte,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.ReverseBits(System.Byte@)">
            <summary>
            <para>Reverse all bits in a specified value.</para>
            <para>Note that the value is passed by <b>reference</b> though the method is an extension method, and returns nothing.</para>
            </summary>
            <param name="this">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.ReverseBits(System.Int16@)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.ReverseBits(System.Byte@)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.ReverseBits(System.Int32@)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.ReverseBits(System.Byte@)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.ReverseBits(System.Int64@)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.ReverseBits(System.Byte@)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.SetAt(System.SByte,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.SetAt(System.Byte,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.SetAt(System.Byte,System.Int32)">
            <summary>
            Get an <see cref="T:System.Int32"/> value, indicating that the absolute position of all set bits with the specified set bit order.
            </summary>
            <param name="this">The value.</param>
            <param name="order">The number of the order of set bits.</param>
            <returns>The position.</returns>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.SetAt(System.Int16,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.SetAt(System.Byte,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.SetAt(System.UInt16,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.SetAt(System.Byte,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.SetAt(System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.SetAt(System.Byte,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.SetAt(System.UInt32,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.SetAt(System.Byte,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.SetAt(System.Int64,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.SetAt(System.Byte,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.SetAt(System.UInt64,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.SetAt(System.Byte,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.SetAt(System.Int128,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.SetAt(System.Byte,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.SetAt(System.UInt128,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.SetAt(System.Byte,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.SetAt(System.IntPtr,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.SetAt(System.Byte,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.SetAt(System.UIntPtr,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.SetAt(System.Byte,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.SetAt``1(``0,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.SetAt(System.Byte,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.SkipSetBit(System.Byte,System.Int32)">
            <summary>
            Skip the specified number of set bits and iterate on the integer with other set bits.
            </summary>
            <param name="this">The integer to iterate.</param>
            <param name="setBitPosCount">Indicates how many set bits you want to skip to iterate.</param>
            <returns>The byte value that only contains the other set bits.</returns>
            <remarks>
            For example:
            <code><![CDATA[
            byte value = 0b00010111;
            foreach (int bitPos in value.SkipSetBit(2))
            {
                yield return bitPos + 1;
            }
            ]]></code>
            You will get 3 and 5, because all set bit positions are 0, 1, 2 and 4, and we have skipped
            two of them, so the result set bit positions to iterate on are only 2 and 4.
            </remarks>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.SkipSetBit(System.Int16,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.SkipSetBit(System.Byte,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.SkipSetBit(System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.SkipSetBit(System.Byte,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.SkipSetBit(System.Int64,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.SkipSetBit(System.Byte,System.Int32)"/>
        </member>
        <member name="T:System.Numerics.Bits">
            <summary>
            Represents a list of methods that operates with bits.
            </summary>
        </member>
        <member name="M:System.Numerics.Bits.EnumerateOf``1(System.Int32,System.Int32)">
            <summary>
            Creates a <see cref="T:System.Numerics.BitCombinationGenerator`1"/> instance that can generate a list of <see cref="T:System.Int64"/>
            values that are all possibilities of combinations of integer values containing specified number of bits,
            and the specified number of bits set 1.
            </summary>
            <typeparam name="TInteger">The type of target integer value.</typeparam>
            <param name="bitCount">Indicates how many bits should be enumerated.</param>
            <param name="oneCount">Indicates how many bits set one contained in the value.</param>
            <returns>A <see cref="T:System.Numerics.BitCombinationGenerator`1"/> instance.</returns>
        </member>
        <member name="T:System.Numerics.Combinatorial">
            <summary>
            Extracts the type that includes the methods that operates with combinatorial values.
            </summary>
        </member>
        <member name="F:System.Numerics.Combinatorial.PascalTriangle">
            <summary>
            Indicates the <see href="https://en.wikipedia.org/wiki/Pascal%27s_triangle">Pascal's Triangle</see>
            (in Chinese: Yang Hui's Triangle), i.e. the combinatorial numbers from <c>C(1, 1)</c> to <c>C(30, 30)</c>.
            </summary>
        </member>
        <member name="T:System.Numerics.Combinatorial.`1">
            <summary>
            Provides extension members on <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
        </member>
        <member name="M:System.Numerics.Combinatorial.`1.GetSubsets">
            <summary>
            Get all subsets from the collection.
            </summary>
            <returns>
            All possible subsets returned.
            </returns>
        </member>
        <member name="M:System.Numerics.Combinatorial.`1.GetSubsets(System.Int32)">
            <summary>
            Get all subsets from the specified number of the values to take.
            </summary>
            <param name="count">The number of elements you want to take.</param>
            <returns>
            The subsets of the list.
            For example, if the input array is <c>[1, 2, 3]</c> and the argument <paramref name="count"/> is 2, the result will be
            <code><![CDATA[
            [[1, 2], [1, 3], [2, 3]]
            ]]></code>
            3 cases.
            </returns>
        </member>
        <member name="M:System.Numerics.Combinatorial.`1.GetPermutations">
            <summary>
            Get all permutations from the collection.
            </summary>
            <returns>
            All possible permutations returned.
            </returns>
        </member>
        <member name="M:System.Numerics.Combinatorial.`1.GetPermutations(System.Int32)">
            <summary>
            Get all permutations from the specified number of the values to take.
            </summary>
            <param name="count">The number of elements you want to take.</param>
            <returns>
            The permutations of the list.
            For example, if the input array is <c>[1, 2, 3]</c> and the argument <paramref name="count"/> is 2, the result will be
            <code><![CDATA[
            [[1, 2], [2, 1], [1, 3], [3, 1], [2, 3], [3, 2]]
            ]]></code>
            6 cases.
            </returns>
        </member>
        <member name="T:System.Numerics.Combinatorial.`1">
            <summary>
            Provides extension members on <typeparamref name="T"/>[][].
            </summary>
        </member>
        <member name="M:System.Numerics.Combinatorial.`1.GetExtractedCombinations">
            <summary>
            Get all combinations that each sub-array only choose one.
            </summary>
            <returns>
            All combinations that each sub-array choose one.
            For example, if one array is <c>[[1, 2, 3], [1, 3], [1, 4, 7, 10]]</c>, the final combinations will be
            <code><![CDATA[
            [
                [1, 1, 1], [1, 1, 4], [1, 1, 7], [1, 1, 10],
                [1, 3, 1], [1, 3, 4], [1, 3, 7], [1, 3, 10],
                [2, 1, 1], [2, 1, 4], [2, 1, 7], [2, 1, 10],
                [2, 3, 1], [2, 3, 4], [2, 3, 7], [2, 3, 10],
                [3, 1, 1], [3, 1, 4], [3, 1, 7], [3, 1, 10],
                [3, 3, 1], [3, 3, 4], [3, 3, 7], [3, 3, 10]
            ]
            ]]></code>
            24 cases.
            </returns>
        </member>
        <member name="M:System.Numerics.Combinatorial.CombinationOf(System.Int32,System.Int32)">
            <summary>
            Returns the combination of (n, m).
            </summary>
            <param name="n">The number of all values.</param>
            <param name="m">The number of values to get.</param>
            <returns>An <see cref="T:System.Int32"/> of result.</returns>
            <exception cref="T:System.OverflowException">Throws when the result value is too large.</exception>
        </member>
        <member name="M:System.Numerics.Combinatorial.PermutationOf(System.Int32,System.Int32)">
            <summary>
            Returns the permutation of (n, m).
            </summary>
            <param name="n">The number of all values.</param>
            <param name="m">The number of values to get.</param>
            <returns>An <see cref="T:System.Int32"/> of result.</returns>
            <exception cref="T:System.OverflowException">Throws when the result value is too large.</exception>
        </member>
        <member name="M:System.Numerics.Combinatorial.Factorial(System.Int32)">
            <summary>
            Returns the factorial of <paramref name="n"/> (n!).
            </summary>
            <param name="n">The value.</param>
            <returns>The result.</returns>
        </member>
        <member name="T:System.Numerics.GenericIntegerEnumerator`1">
            <summary>
            Defines an enumerator type that iterates on bits of an integer of generic type.
            </summary>
            <typeparam name="TInteger">The type of the integer that supports for iteration on bits.</typeparam>
            <param name="_value">The integer to be iterated.</param>
            <param name="_bitsCount">The integer of bits to be iterated.</param>
        </member>
        <member name="M:System.Numerics.GenericIntegerEnumerator`1.#ctor(`0,System.Int32)">
            <summary>
            Defines an enumerator type that iterates on bits of an integer of generic type.
            </summary>
            <typeparam name="TInteger">The type of the integer that supports for iteration on bits.</typeparam>
            <param name="_value">The integer to be iterated.</param>
            <param name="_bitsCount">The integer of bits to be iterated.</param>
        </member>
        <member name="P:System.Numerics.GenericIntegerEnumerator`1.PopulationCount">
            <inheritdoc/>
        </member>
        <member name="P:System.Numerics.GenericIntegerEnumerator`1.Bits">
            <inheritdoc/>
        </member>
        <member name="P:System.Numerics.GenericIntegerEnumerator`1.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current"/>
        </member>
        <member name="P:System.Numerics.GenericIntegerEnumerator`1.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="P:System.Numerics.GenericIntegerEnumerator`1.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:System.Numerics.GenericIntegerEnumerator`1.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:System.Numerics.GenericIntegerEnumerator`1.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="M:System.Numerics.GenericIntegerEnumerator`1.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.Numerics.GenericIntegerEnumerator`1.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:System.Numerics.GenericIntegerEnumerator`1.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:System.Numerics.GenericIntegerEnumerator`1.System#IDisposable#Dispose">
            <inheritdoc/>
            <exception cref="T:System.ObjectDisposedException">Throws when the object had already been disposed.</exception>
        </member>
        <member name="T:System.Numerics.IBitEnumerator">
            <summary>
            Represents an enumerator that can iterate bits on numeric type.
            </summary>
        </member>
        <member name="P:System.Numerics.IBitEnumerator.PopulationCount">
            <summary>
            Indicates the population count of the value.
            </summary>
        </member>
        <member name="P:System.Numerics.IBitEnumerator.Bits">
            <summary>
            Indicates the bits set.
            </summary>
        </member>
        <member name="P:System.Numerics.IBitEnumerator.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="P:System.Numerics.IBitEnumerator.Item(System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.SetAt(System.UInt32,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.IBitEnumerator.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="T:System.Numerics.Int128Enumerator">
            <summary>
            Represents an enumerator that iterates a <see cref="T:System.Int128"/> or <see cref="T:System.UInt128"/> value.
            </summary>
            <param name="_value">The value to be iterated.</param>
        </member>
        <member name="M:System.Numerics.Int128Enumerator.#ctor(System.UInt128)">
            <summary>
            Represents an enumerator that iterates a <see cref="T:System.Int128"/> or <see cref="T:System.UInt128"/> value.
            </summary>
            <param name="_value">The value to be iterated.</param>
        </member>
        <member name="P:System.Numerics.Int128Enumerator.PopulationCount">
            <inheritdoc/>
        </member>
        <member name="P:System.Numerics.Int128Enumerator.Bits">
            <inheritdoc/>
        </member>
        <member name="P:System.Numerics.Int128Enumerator.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current"/>
        </member>
        <member name="P:System.Numerics.Int128Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="P:System.Numerics.Int128Enumerator.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:System.Numerics.Int128Enumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:System.Numerics.Int128Enumerator.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="M:System.Numerics.Int128Enumerator.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.Numerics.Int128Enumerator.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:System.Numerics.Int128Enumerator.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:System.Numerics.Int128Enumerator.System#IDisposable#Dispose">
            <inheritdoc/>
            <exception cref="T:System.ObjectDisposedException">Throws when the object had already been disposed.</exception>
        </member>
        <member name="T:System.Numerics.Int32Enumerator">
            <summary>
            Represents an enumerator that iterates an <see cref="T:System.Int32"/> or <see cref="T:System.UInt32"/> value.
            </summary>
            <param name="_value">The value to be iterated.</param>
        </member>
        <member name="M:System.Numerics.Int32Enumerator.#ctor(System.UInt32)">
            <summary>
            Represents an enumerator that iterates an <see cref="T:System.Int32"/> or <see cref="T:System.UInt32"/> value.
            </summary>
            <param name="_value">The value to be iterated.</param>
        </member>
        <member name="P:System.Numerics.Int32Enumerator.PopulationCount">
            <inheritdoc/>
        </member>
        <member name="P:System.Numerics.Int32Enumerator.Bits">
            <inheritdoc/>
        </member>
        <member name="P:System.Numerics.Int32Enumerator.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current"/>
        </member>
        <member name="P:System.Numerics.Int32Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="P:System.Numerics.Int32Enumerator.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:System.Numerics.Int32Enumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:System.Numerics.Int32Enumerator.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="M:System.Numerics.Int32Enumerator.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.Numerics.Int32Enumerator.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:System.Numerics.Int32Enumerator.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:System.Numerics.Int32Enumerator.System#IDisposable#Dispose">
            <inheritdoc/>
            <exception cref="T:System.ObjectDisposedException">Throws when the object had already been disposed.</exception>
        </member>
        <member name="T:System.Numerics.Int64Enumerator">
            <summary>
            Represents an enumerator that iterates a <see cref="T:System.Int64"/> or <see cref="T:System.UInt64"/> value.
            </summary>
            <param name="_value">The value to be iterated.</param>
        </member>
        <member name="M:System.Numerics.Int64Enumerator.#ctor(System.UInt64)">
            <summary>
            Represents an enumerator that iterates a <see cref="T:System.Int64"/> or <see cref="T:System.UInt64"/> value.
            </summary>
            <param name="_value">The value to be iterated.</param>
        </member>
        <member name="P:System.Numerics.Int64Enumerator.PopulationCount">
            <inheritdoc/>
        </member>
        <member name="P:System.Numerics.Int64Enumerator.Bits">
            <inheritdoc/>
        </member>
        <member name="P:System.Numerics.Int64Enumerator.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current"/>
        </member>
        <member name="P:System.Numerics.Int64Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="P:System.Numerics.Int64Enumerator.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:System.Numerics.Int64Enumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:System.Numerics.Int64Enumerator.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="M:System.Numerics.Int64Enumerator.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.Numerics.Int64Enumerator.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:System.Numerics.Int64Enumerator.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:System.Numerics.Int64Enumerator.System#IDisposable#Dispose">
            <inheritdoc/>
            <exception cref="T:System.ObjectDisposedException">Throws when the object had already been disposed.</exception>
        </member>
        <member name="T:System.Numerics.NIntEnumerator">
            <summary>
            Represents an enumerator that iterates an <see cref="T:System.IntPtr"/> or <see cref="T:System.UIntPtr"/> value.
            </summary>
            <param name="_value">The value to be iterated.</param>
        </member>
        <member name="M:System.Numerics.NIntEnumerator.#ctor(System.UIntPtr)">
            <summary>
            Represents an enumerator that iterates an <see cref="T:System.IntPtr"/> or <see cref="T:System.UIntPtr"/> value.
            </summary>
            <param name="_value">The value to be iterated.</param>
        </member>
        <member name="P:System.Numerics.NIntEnumerator.PopulationCount">
            <summary>
            Indicates the population count of the value.
            </summary>
        </member>
        <member name="P:System.Numerics.NIntEnumerator.Bits">
            <summary>
            Indicates the bits set.
            </summary>
        </member>
        <member name="P:System.Numerics.NIntEnumerator.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current"/>
        </member>
        <member name="P:System.Numerics.NIntEnumerator.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="P:System.Numerics.NIntEnumerator.Item(System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.SetAt(System.UInt32,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.NIntEnumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:System.Numerics.NIntEnumerator.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="M:System.Numerics.NIntEnumerator.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.Numerics.NIntEnumerator.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:System.Numerics.NIntEnumerator.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:System.Numerics.NIntEnumerator.System#IDisposable#Dispose">
            <inheritdoc/>
            <exception cref="T:System.ObjectDisposedException">Throws when the object had already been disposed.</exception>
        </member>
        <member name="T:System.RandomExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.Random"/>.
            </summary>
            <seealso cref="T:System.Random"/>
        </member>
        <member name="T:System.RandomExtensions.">
            <summary>
            Provides extension members on <see cref="T:System.Random"/>.
            </summary>
        </member>
        <member name="M:System.RandomExtensions..NextGaussian(System.Double,System.Double)">
            <summary>
            Generates a random number obeying Gaussian's Normal Distribution,
            with  value <paramref name="sigma"/> and  value <paramref name="mu"/>.
            </summary>
            <param name="mu">Mu  value.</param>
            <param name="sigma">Sigma  value.</param>
            <returns>The result value.</returns>
        </member>
        <member name="T:System.ReadOnlyMemoryExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.ReadOnlyMemory`1"/>.
            </summary>
            <seealso cref="T:System.ReadOnlyMemory`1"/>
        </member>
        <member name="T:System.ReadOnlyMemoryExtensions.`1">
            <summary>
            Provides extension members on <see cref="T:System.ReadOnlyMemory`1"/>.
            </summary>
        </member>
        <member name="P:System.ReadOnlyMemoryExtensions.`1.Item(System.Int32)">
            <summary>
            Gets the element at the specified index.
            </summary>
            <param name="index">The desired index.</param>
            <returns>The reference to the element at the specified index.</returns>
        </member>
        <member name="P:System.ReadOnlyMemoryExtensions.`1.Item(System.Index)">
            <inheritdoc cref="M:System.ReadOnlyMemoryExtensions.get_Item``1(System.ReadOnlyMemory{``0},System.Int32)"/>
        </member>
        <member name="M:System.ReadOnlyMemoryExtensions.`1.ElementAt(System.Int32)">
            <summary>
            Fetch the element at the specified index inside a <see cref="T:System.ReadOnlyMemory`1"/>.
            </summary>
            <param name="index">The desired index.</param>
            <returns>The reference to the element at the specified index.</returns>
        </member>
        <member name="M:System.ReadOnlyMemoryExtensions.`1.ElementAt(System.Index)">
            <inheritdoc cref="M:System.ReadOnlyMemoryExtensions.ElementAt``1(System.ReadOnlyMemory{``0},System.Int32)"/>
        </member>
        <member name="M:System.ReadOnlyMemoryExtensions.`1.GetEnumerator">
            <summary>
            Creates a <see cref="T:System.Linq.Enumerators.ReadOnlyMemoryEnumerator`1"/> instance that can be consumed by a <see langword="foreach"/> loop.
            </summary>
            <returns>A <see cref="T:System.Linq.Enumerators.ReadOnlyMemoryEnumerator`1"/> instance.</returns>
        </member>
        <member name="T:System.ReadOnlySpanExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.Span`1"/> and <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
            <seealso cref="T:System.Span`1"/>
            <seealso cref="T:System.ReadOnlySpan`1"/>
        </member>
        <member name="T:System.ReadOnlySpanExtensions.`1">
            <summary>
            Provides extension members on <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
        </member>
        <member name="M:System.ReadOnlySpanExtensions.`1.FirstIndex(System.Func{`0,System.Boolean})">
            <summary>
            Finds the first element satisfying the specified condition, and return its corresponding index.
            </summary>
            <param name="predicate">The condition.</param>
            <returns>
            An <see cref="T:System.Int32"/> indicating the found element. -1 returns if the sequence has no element satisfying the condition.
            </returns>
        </member>
        <member name="M:System.ReadOnlySpanExtensions.`1.LastIndex(System.Func{`0,System.Boolean})">
            <summary>
            Finds the last element satisfying the specified condition, and return its corresponding index.
            </summary>
            <param name="predicate">The condition.</param>
            <returns>
            An <see cref="T:System.Int32"/> indicating the found element. -1 returns if the sequence has no element satisfying the condition.
            </returns>
        </member>
        <member name="M:System.ReadOnlySpanExtensions.`1.FindIndex(System.Func{`0,System.Boolean})">
            <inheritdoc cref="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})"/>
        </member>
        <member name="M:System.ReadOnlySpanExtensions.`1.EnumerateReversely">
            <summary>
            Iterates on each element, in reverse order.
            </summary>
            <returns>An enumerator type that iterates on each element.</returns>
        </member>
        <member name="M:System.ReadOnlySpanExtensions.`1.FindAll(System.Func{`0,System.Boolean})">
            <summary>
            Retrieves all the elements that match the conditions defined by the specified predicate.
            </summary>
            <param name="match">The <see cref="T:System.Func`2"/> that defines the conditions of the elements to search for.</param>
            <returns>
            A <see cref="T:System.ReadOnlySpan`1"/> containing all the elements that match the conditions defined
            by the specified predicate, if found; otherwise, an empty <see cref="T:System.ReadOnlySpan`1"/>.
            </returns>
        </member>
        <member name="T:System.ReadOnlySpanExtensions.`1">
            <summary>
            Provides extension members on <see cref="T:System.ReadOnlySpan`1"/>,
            where <typeparamref name="T"/> satisfies <see langword="notnull"/> constraint.
            </summary>
        </member>
        <member name="M:System.ReadOnlySpanExtensions.`1.EnumeratePaired">
            <summary>
            Creates a <see cref="T:System.Linq.Enumerators.PairEnumerator`1"/> instance that iterates on each element of pair elements.
            </summary>
            <returns>An enumerable collection.</returns>
        </member>
        <member name="T:System.ReadOnlySpanExtensions.`1">
            <summary>
            Provides extension members on <see langword="scoped"/> <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
        </member>
        <member name="M:System.ReadOnlySpanExtensions.`1.Reverse">
            <summary>
            Returns a new <see cref="T:System.ReadOnlySpan`1"/> instance whose internal elements are all come from the current collection,
            with reversed order.
            </summary>
            <returns>A new collection whose elements are in reversed order.</returns>
        </member>
        <member name="T:System.ref">
            <summary>
            Represents a list of methods that can check for the concept "References" defined in C#.
            </summary>
        </member>
        <member name="M:System.ref.Swap``1(``0@,``0@)">
            <summary>
            Swaps for two elements.
            </summary>
            <typeparam name="T">The type of both two arguments.</typeparam>
            <param name="left">The first element to be swapped.</param>
            <param name="right">The second element to be swapped.</param>
        </member>
        <member name="M:System.ref.ByteRef``1(``0@)">
            <summary>
            Simply invokes the method <see cref="M:System.Runtime.CompilerServices.Unsafe.As``2(``0@)"/>, but with target generic type being fixed type <see cref="T:System.Byte"/>.
            </summary>
            <typeparam name="T">The base type that is converted from.</typeparam>
            <param name="ref">
            The reference to the value. Generally speaking the value should be a <see langword="ref readonly"/> parameter, but C# disallows it,
            using <see langword="ref readonly"/> as a combined parameter modifier.
            </param>
        </member>
        <member name="M:System.ref.ReadOnlyByteRef``1(``0@)">
            <inheritdoc cref="M:System.ref.ByteRef``1(``0@)"/>
        </member>
        <member name="M:System.ref.Add``1(``0@,System.Int32)">
            <summary>
            Advances the pointer to an element after the specified number of block memory elements.
            </summary>
            <typeparam name="T">The type of the element in block memory.</typeparam>
            <param name="ref">The reference to be advanced.</param>
            <param name="length">The length that the pointer moves.</param>
            <returns>The target reference to the specified element.</returns>
            <remarks>
            Pass negative value into parameter <paramref name="length"/> if you want to move previously,
            which is equivalent to method call <see cref="M:System.Runtime.CompilerServices.Unsafe.Subtract``1(``0@,System.Int32)"/>
            </remarks>
            <seealso cref="M:System.Runtime.CompilerServices.Unsafe.Subtract``1(``0@,System.Int32)"/>
        </member>
        <member name="M:System.ref.AsSpan``1(``0@,System.Int32)">
            <summary>
            Casts the reference to a valid <see cref="T:System.Span`1"/> object.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="firstElementReference">The reference to the first element in a sequence.</param>
            <param name="length">The length.</param>
            <returns>A <see cref="T:System.Span`1"/> instance.</returns>
        </member>
        <member name="M:System.ref.AsReadOnlySpan``1(``0@,System.Int32)">
            <summary>
            Casts the reference to a valid <see cref="T:System.ReadOnlySpan`1"/> object.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="firstElementReference">The reference to the first element in a sequence.</param>
            <param name="length">The length.</param>
            <returns>A <see cref="T:System.ReadOnlySpan`1"/> instance.</returns>
        </member>
        <member name="T:System.Reflection.AssemblyExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.Reflection.Assembly"/>.
            </summary>
            <seealso cref="T:System.Reflection.Assembly"/>
        </member>
        <member name="T:System.Reflection.AssemblyExtensions.">
            <summary>
            Provides extension members on <see cref="T:System.Reflection.Assembly"/>.
            </summary>
        </member>
        <member name="M:System.Reflection.AssemblyExtensions..GetDerivedTypes(System.Type)">
            <summary>
            Gets all possible types derived from an <see langword="interface"/> type,
            or a base <see langword="class"/> type, in the specified assembly.
            </summary>
            <param name="baseType">The type as the base type.</param>
            <returns>All possible derived types.</returns>
        </member>
        <member name="M:System.Reflection.AssemblyExtensions..GetDerivedTypes``1">
            <inheritdoc cref="M:System.Reflection.AssemblyExtensions.GetDerivedTypes(System.Reflection.Assembly,System.Type)"/>
            <typeparam name="TBase">The type as the base type.</typeparam>
            <returns><inheritdoc/></returns>
        </member>
        <member name="T:System.Reflection.CustomAttributeProviderExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.Reflection.ICustomAttributeProvider"/>.
            </summary>
            <seealso cref="T:System.Reflection.ICustomAttributeProvider"/>
        </member>
        <member name="M:System.Reflection.CustomAttributeProviderExtensions.GetGenericAttributeTypeArguments``1(``0,System.Type)">
            <summary>
            Gets the type arguments of the specified attribute type applied to the specified property.
            </summary>
            <typeparam name="TCustomAttributeProvider">The type of custom attribute provider.</typeparam>
            <param name="this">The instance.</param>
            <param name="genericAttributeType">The generic attribute type.</param>
            <returns>The types of the generic type arguments.</returns>
        </member>
        <member name="M:System.Reflection.CustomAttributeProviderExtensions.GetCustomGenericAttribute``1(``0,System.Type)">
            <summary>
            <inheritdoc cref="M:System.Attribute.GetCustomAttribute(System.Reflection.MemberInfo,System.Type)" path="/summary"/>
            </summary>
            <typeparam name="TCustomAttributeProvider">The type of custom attribute provider.</typeparam>
            <param name="this">The instance.</param>
            <param name="genericAttributeType">The generic attribute type.</param>
            <returns>
            <inheritdoc cref="M:System.Attribute.GetCustomAttribute(System.Reflection.MemberInfo,System.Type)" path="/returns"/>
            </returns>
        </member>
        <member name="M:System.Reflection.CustomAttributeProviderExtensions.GetCustomGenericAttributes``1(``0,System.Type)">
            <summary>
            <inheritdoc cref="M:System.Attribute.GetCustomAttributes(System.Reflection.MemberInfo,System.Type)" path="/summary"/>
            </summary>
            <typeparam name="TCustomAttributeProvider">The type of custom attribute provider.</typeparam>
            <param name="this">The instance.</param>
            <param name="genericAttributeType">The generic attribute type.</param>
            <returns>
            <inheritdoc cref="M:System.Attribute.GetCustomAttributes(System.Reflection.MemberInfo,System.Type)" path="/returns"/>
            </returns>
        </member>
        <member name="M:System.Reflection.CustomAttributeProviderExtensions.IndexOfBacktick(System.String)">
            <summary>
            Get the index of the text of the back tick.
            </summary>
            <param name="this">The string text.</param>
            <returns>The index of the backtick in the string.</returns>
        </member>
        <member name="M:System.Reflection.CustomAttributeProviderExtensions.GetAttributesCore``1(``0)">
            <summary>
            Get custom attributes.
            </summary>
            <typeparam name="TCustomAttributeProvider">The type of the provider.</typeparam>
            <param name="this">The custom attribute provider.</param>
            <returns>The attributes.</returns>
        </member>
        <member name="T:System.Reflection.MemberInfoExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.Reflection.MemberInfo"/> instances.
            </summary>
            <seealso cref="T:System.Reflection.MemberInfo"/>
        </member>
        <member name="T:System.Reflection.MemberInfoExtensions.">
            <summary>
            Provides extension members on <see cref="T:System.Reflection.PropertyInfo"/>.
            </summary>
        </member>
        <member name="M:System.Reflection.MemberInfoExtensions..GetInitMethod(System.Boolean)">
            <summary>
            When overridden in a derived class, returns the <see langword="init"/> accessor for this property.
            </summary>
            <param name="nonPublic">
            Indicates whether the accessor should be returned if it is non-public.
            <see langword="true"/> if a non-public accessor is to be returned; otherwise, <see langword="false"/>.
            </param>
            <returns>
            This property's <see langword="init"/> method, or <see langword="null"/>, as shown in the following table.
            <list type="table">
            <listheader>
            <term>Value</term>
            <description>Condition</description>
            </listheader>
            <item>
            <term>The <see langword="init"/> method for this property</term>
            <description>
            The <see langword="init"/> accessor is public, or <paramref name="nonPublic"/> is <see langword="true"/>
            and the <see langword="init"/> accessor is non-public.
            </description>
            </item>
            <item>
            <term><see langword="null"/></term>
            <description>
            <paramref name="nonPublic"/> is <see langword="true"/>, but the property is read-only,
            or <paramref name="nonPublic"/> is <see langword="false"/> and the <see langword="init"/> accessor is non-public,
            or there is no <see langword="init"/> accessor.
            </description>
            </item>
            </list>
            </returns>
        </member>
        <member name="T:System.Reflection.MemberInfoExtensions.">
            <summary>
            Provides extension members on <see cref="T:System.Reflection.MemberInfo"/>.
            </summary>
        </member>
        <member name="M:System.Reflection.MemberInfoExtensions..IsDefined``1">
            <inheritdoc cref="M:System.Reflection.CustomAttributeExtensions.IsDefined(System.Reflection.MemberInfo,System.Type)"/>
        </member>
        <member name="T:System.Reflection.TypeExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.Type"/>.
            </summary>
            <seealso cref="T:System.Type"/>
        </member>
        <member name="T:System.Reflection.TypeExtensions.">
            <summary>
            Provides extension members on <see cref="T:System.Type"/>.
            </summary>
        </member>
        <member name="P:System.Reflection.TypeExtensions..HasParameterlessConstructor">
            <summary>
            Determines whether the type has a parameterless constructor.
            </summary>
        </member>
        <member name="M:System.Reflection.TypeExtensions..IsGenericAssignableTo(System.Type)">
            <summary>
            Determines whether the current type can be assigned to a variable of the specified
            <paramref name="targetType"/>, although it is with generic parameters.
            </summary>
            <param name="targetType">The type to compare with the current type.</param>
            <returns>Returns <see langword="true"/> if the target type is matched, without generic constraints.</returns>
            <seealso href="https://stackoverflow.com/questions/74616/how-to-detect-if-type-is-another-generic-type/1075059#1075059">
            Question: How to detect if type is another generic type
            </seealso>
        </member>
        <member name="T:System.Resources.DynamicResource">
            <summary>
            Represents an object that can use lookup syntax <c>resource["Key"]</c> or property syntax <c>resource.Key</c> to fetch resources.
            </summary>
            <remarks>
            Usages:
            <list type="bullet">
            <item>Indexer: <c>resource[ResourceKeyName]</c></item>
            <item>Indexer: <c>resource[ResourceKeyName, <see cref="T:System.String"/>]</c></item>
            <item>Indexer: <c>resource[ResourceKeyName, <see cref="T:System.String"/>, <see cref="T:System.Reflection.Assembly"/>]</c></item>
            <item>Indexer: <c>resource[ResourceKeyName, <see cref="T:System.Reflection.Assembly"/>]</c></item>
            <item>Indexer: <c>resource[ResourceKeyName, <see cref="T:System.Globalization.CultureInfo"/>]</c></item>
            <item>Indexer: <c>resource[ResourceKeyName, <see cref="T:System.Globalization.CultureInfo"/>, <see cref="T:System.Reflection.Assembly"/>]</c></item>
            <item>Property: <c>resource.ResourceKeyName</c></item>
            <item>Method: <c>resource.ResourceKeyName()</c></item>
            <item>Method: <c>resource.ResourceKeyName(<see cref="T:System.String"/>)</c></item>
            <item>Method: <c>resource.ResourceKeyName(<see cref="T:System.String"/>, <see cref="T:System.Reflection.Assembly"/>)</c></item>
            <item>Method: <c>resource.ResourceKeyName(<see cref="T:System.Globalization.CultureInfo"/>)</c></item>
            <item>Method: <c>resource.ResourceKeyName(<see cref="T:System.Globalization.CultureInfo"/>, <see cref="T:System.Reflection.Assembly"/>)</c></item>
            </list>
            All valid invocations will return a <see cref="T:System.String"/> result indicating result.
            </remarks>
        </member>
        <member name="F:System.Resources.DynamicResource.Instance">
            <summary>
            Represents the default instance.
            </summary>
        </member>
        <member name="M:System.Resources.DynamicResource.#ctor">
            <summary>
            Indicates the singleton constructor.
            </summary>
        </member>
        <member name="M:System.Resources.DynamicResource.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
            <inheritdoc/>
        </member>
        <member name="M:System.Resources.DynamicResource.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
            <inheritdoc/>
        </member>
        <member name="T:System.Resources.MissingResourceManagerException">
            <summary>
            Represents an exception that will be thrown if resource manager is missing.
            </summary>
            <param name="assembly"><inheritdoc/></param>
        </member>
        <member name="M:System.Resources.MissingResourceManagerException.#ctor(System.Reflection.Assembly)">
            <summary>
            Represents an exception that will be thrown if resource manager is missing.
            </summary>
            <param name="assembly"><inheritdoc/></param>
        </member>
        <member name="P:System.Resources.MissingResourceManagerException.Message">
            <inheritdoc/>
        </member>
        <member name="P:System.Resources.MissingResourceManagerException.Data">
            <inheritdoc/>
        </member>
        <member name="T:System.Resources.ResourceException">
            <summary>
            Represents an exception type that relates to resource dictionary.
            </summary>
            <param name="assembly">Indicates the target assembly.</param>
        </member>
        <member name="M:System.Resources.ResourceException.#ctor(System.Reflection.Assembly)">
            <summary>
            Represents an exception type that relates to resource dictionary.
            </summary>
            <param name="assembly">Indicates the target assembly.</param>
        </member>
        <member name="P:System.Resources.ResourceException.Message">
            <inheritdoc/>
        </member>
        <member name="P:System.Resources.ResourceException.Data">
            <inheritdoc/>
        </member>
        <member name="F:System.Resources.ResourceException._assembly">
            <summary>
            The generated field declaration for parameter <c>assembly</c>.
            </summary>
        </member>
        <member name="T:System.Resources.ResourceNotFoundException">
            <summary>
            Indicates an exception that will be thrown if target resource is not found.
            </summary>
            <param name="assembly"><inheritdoc/></param>
            <param name="resourceKey">The resource key.</param>
            <param name="culture">The culture information.</param>
        </member>
        <member name="M:System.Resources.ResourceNotFoundException.#ctor(System.Reflection.Assembly,System.String,System.Globalization.CultureInfo)">
            <summary>
            Indicates an exception that will be thrown if target resource is not found.
            </summary>
            <param name="assembly"><inheritdoc/></param>
            <param name="resourceKey">The resource key.</param>
            <param name="culture">The culture information.</param>
        </member>
        <member name="F:System.Resources.ResourceNotFoundException.CultureNotSpecifiedDefaultText">
            <summary>
            The "unspecified" text.
            </summary>
        </member>
        <member name="P:System.Resources.ResourceNotFoundException.Message">
            <inheritdoc/>
        </member>
        <member name="P:System.Resources.ResourceNotFoundException.Data">
            <inheritdoc/>
        </member>
        <member name="F:System.Resources.ResourceNotFoundException._resourceKey">
            <summary>
            The generated field declaration for parameter <c>resourceKey</c>.
            </summary>
        </member>
        <member name="F:System.Resources.ResourceNotFoundException._culture">
            <summary>
            The generated field declaration for parameter <c>culture</c>.
            </summary>
        </member>
        <member name="T:System.Resources.SR">
            <summary>
            Represents a easy way to fetch resource values using the specified key and culture information.
            </summary>
        </member>
        <member name="F:System.Resources.SR.EnglishLanguage">
            <summary>
            Indicates English language identifier.
            </summary>
        </member>
        <member name="F:System.Resources.SR.ChineseLanguage">
            <summary>
            Indicates Chinese language identifier.
            </summary>
        </member>
        <member name="F:System.Resources.SR.DefaultBindingFlags">
            <summary>
            Indicates the resource manager reflection binding flags.
            </summary>
        </member>
        <member name="F:System.Resources.SR.DefaultCulture">
            <summary>
            Indicates the default culture.
            </summary>
        </member>
        <member name="M:System.Resources.SR.IsChinese(System.Globalization.CultureInfo)">
            <summary>
            Determine whether the specified culture is Chinese.
            </summary>
            <param name="culture">The culture.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:System.Resources.SR.IsEnglish(System.Globalization.CultureInfo)">
            <summary>
            Determine whether the specified culture is English.
            </summary>
            <param name="culture">The culture.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:System.Resources.SR.RegisterResourceManager``1">
            <summary>
            Register a new resource manager for the current assembly calling this method.
            </summary>
            <typeparam name="TResourceManagerProvider">
            <para>The type of the resource manager provider.</para>
            <para>
            This type should point to a generated type, bound with your resource dictionary manifest file (*.resx),
            named like the file name of it.
            For example, if you create a resource dictionary manifest file called <c>Resource.resx</c>,
            a generated type will be named <c>Resource</c>.
            You should pass in this type (<c>Resource</c> here) as type argument to this method.
            </para>
            </typeparam>
            <exception cref="T:System.Resources.MissingResourceManagerException">
            Throws when the current calling assembly doesn't contain any resource manager.
            </exception>
        </member>
        <member name="F:System.Resources.SR.ResourceManagers">
            <summary>
            The internal resource managers.
            </summary>
        </member>
        <member name="P:System.Resources.SR.ResourceFetchingHandler">
            <summary>
            Represents the resource fetching rule. This method can control the fetching rule,
            especially for the cases using culture-switching.
            </summary>
        </member>
        <member name="M:System.Resources.SR.ExceptionMessage(System.String,System.Globalization.CultureInfo,System.Reflection.Assembly)">
            <summary>
            Try to get error information (used by exception message, <see cref="P:System.Exception.Message"/> property) values,
            or throw a <see cref="T:System.Resources.ResourceNotFoundException"/> if resource is not found.
            </summary>
            <inheritdoc cref="M:System.Resources.SR.TryGet(System.String,System.String@,System.Globalization.CultureInfo,System.Reflection.Assembly)"/>
            <exception cref="T:System.Resources.ResourceNotFoundException">Throws when the specified resource is not found.</exception>
        </member>
        <member name="M:System.Resources.SR.Get(System.String,System.Globalization.CultureInfo,System.Reflection.Assembly)">
            <summary>
            Try to get resource via the key, or throw a <see cref="T:System.Resources.ResourceNotFoundException"/> if resource is not found.
            </summary>
            <inheritdoc cref="M:System.Resources.SR.TryGet(System.String,System.String@,System.Globalization.CultureInfo,System.Reflection.Assembly)"/>
            <exception cref="T:System.Resources.ResourceNotFoundException">Throws when the specified resource is not found.</exception>
        </member>
        <member name="M:System.Resources.SR.TryGet(System.String,System.String@,System.Globalization.CultureInfo,System.Reflection.Assembly)">
            <summary>
            Try to get resource via the key, or return <see langword="null"/> if failed.
            </summary>
            <param name="resourceKey">The resource key.</param>
            <param name="resource">Indicates the target resource.</param>
            <param name="culture">The culture.</param>
            <param name="assembly">The assembly storing the resource dictionaries.</param>
            <returns>The result string result.</returns>
            <exception cref="T:System.Resources.MissingResourceManagerException">Throws when the resource manager object is missing.</exception>
        </member>
        <member name="T:System.Resources.SystemExtensionsResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:System.Resources.SystemExtensionsResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:System.Resources.SystemExtensionsResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:System.Resources.SystemExtensionsResources.ErrorInfo_ArgCannotBeNull">
            <summary>
              Looks up a localized string similar to The argument cannot return null..
            </summary>
        </member>
        <member name="P:System.Resources.SystemExtensionsResources.ErrorInfo_CharacterNotUtf8">
            <summary>
              Looks up a localized string similar to Cannot operate because the argument is not a UTF-8 formatted character..
            </summary>
        </member>
        <member name="P:System.Resources.SystemExtensionsResources.ErrorInfo_FormatInvalid">
            <summary>
              Looks up a localized string similar to The specified format is invalid..
            </summary>
        </member>
        <member name="P:System.Resources.SystemExtensionsResources.ErrorInfo_MemberNotSupported">
            <summary>
              Looks up a localized string similar to This member does not supported..
            </summary>
        </member>
        <member name="P:System.Resources.SystemExtensionsResources.ErrorInfo_NoElementsFoundInCollection">
            <summary>
              Looks up a localized string similar to There&apos;s no elements in this collection..
            </summary>
        </member>
        <member name="P:System.Resources.SystemExtensionsResources.ErrorInfo_NoSuchElementSatisfyingCondition">
            <summary>
              Looks up a localized string similar to The collection does not contain any possible element satisfying the specified condition..
            </summary>
        </member>
        <member name="P:System.Resources.SystemExtensionsResources.ErrorInfo_SpecifiedValueMustBeEven">
            <summary>
              Looks up a localized string similar to The argument must be of an even length..
            </summary>
        </member>
        <member name="P:System.Resources.SystemExtensionsResources.ErrorInfo_StringIsInvalidRegex">
            <summary>
              Looks up a localized string similar to The specified regular expression pattern is invalid..
            </summary>
        </member>
        <member name="P:System.Resources.SystemExtensionsResources.ErrorInfo_UnderlyingTypeNotSupported">
            <summary>
              Looks up a localized string similar to The target enumeration type has a wrong underlying numeric type. All possible underlying types for an enumeration type must be of size 1, 2, 4 or 8 bits..
            </summary>
        </member>
        <member name="P:System.Resources.SystemExtensionsResources.Message_MissingResourceManagerException">
            <summary>
              Looks up a localized string similar to Assembly &apos;{0}&apos; is lack of invocation &apos;{1}.{2}&apos;..
            </summary>
        </member>
        <member name="P:System.Resources.SystemExtensionsResources.Message_ResourceNotFoundException">
            <summary>
              Looks up a localized string similar to Specified resource not found.
             * Resource key: &apos;{0}&apos;,
             * Assembly: &apos;{1}&apos;,
             * Culture: &apos;{2}&apos;.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.LibraryIdentifiers">
            <summary>
            Represents some item names used by .NET library APIs.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.LibraryIdentifiers.List_Size">
            <summary>
            Indicates the name is <c>"_size"</c>.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.LibraryIdentifiers.List_Version">
            <summary>
            Indicates the name is <c>"_version"</c>.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.LibraryIdentifiers.List_Items">
            <summary>
            Indicates the name is <c>"_items"</c>.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.LibraryIdentifiers.Stack_Array">
            <summary>
            Indicates the name is <c>"_array"</c>.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.LibraryIdentifiers.Enumerator_Current">
            <summary>
            Indicates the name is <c>"_current"</c>.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.LibraryIdentifiers.BitArray_Array">
            <summary>
            Indicates the name is <c>"m_array"</c>.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.LibraryIdentifiers.KeyValuePair_Key">
            <summary>
            Indicates the name is <c>"key"</c>.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.LibraryIdentifiers.KeyValuePair_Value">
            <summary>
            Indicates the name is <c>"value"</c>.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.TupleEnumerator`1">
            <summary>
            Represents for an enumerator that iterates on each elements stored in a <see cref="T:System.Runtime.CompilerServices.ITuple"/>.
            </summary>
            <typeparam name="TTuple">The type of tuple.</typeparam>
            <param name="tuple">A tuple instance.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.TupleEnumerator`1.#ctor(`0)">
            <summary>
            Represents for an enumerator that iterates on each elements stored in a <see cref="T:System.Runtime.CompilerServices.ITuple"/>.
            </summary>
            <typeparam name="TTuple">The type of tuple.</typeparam>
            <param name="tuple">A tuple instance.</param>
        </member>
        <member name="F:System.Runtime.CompilerServices.TupleEnumerator`1._index">
            <summary>
            The current index.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.TupleEnumerator`1.Current">
            <inheritdoc cref="P:System.Collections.IEnumerator.Current"/>
        </member>
        <member name="M:System.Runtime.CompilerServices.TupleEnumerator`1.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:System.Runtime.CompilerServices.TupleEnumerator`1.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="F:System.Runtime.CompilerServices.TupleEnumerator`1._tuple">
            <summary>
            The generated field declaration for parameter <c>tuple</c>.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.TupleEnumerator`1.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.Runtime.CompilerServices.TupleEnumerator`1.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:System.Runtime.CompilerServices.TupleEnumerator`1.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:System.Runtime.CompilerServices.TupleEnumerator`1.System#IDisposable#Dispose">
            <inheritdoc/>
            <exception cref="T:System.ObjectDisposedException">Throws when the object had already been disposed.</exception>
        </member>
        <member name="T:System.Runtime.CompilerServices.TupleExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.Runtime.CompilerServices.ITuple"/>.
            </summary>
            <seealso cref="T:System.Runtime.CompilerServices.ITuple"/>
        </member>
        <member name="T:System.Runtime.CompilerServices.TupleExtensions.">
            <summary>
            Provides extension members on <see cref="T:System.Runtime.CompilerServices.ITuple"/>.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.TupleExtensions..AsSpan``1">
            <summary>
            Converts the tuple elements into a valid span of elements of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The unified type for all elements.</typeparam>
            <returns>A <see cref="T:System.ReadOnlySpan`1"/> instance.</returns>
        </member>
        <member name="M:System.Runtime.CompilerServices.TupleExtensions.ToArray``1(``0)">
            <summary>
            Converts the <see cref="T:System.Runtime.CompilerServices.ITuple"/> instance into an array of objects.
            </summary>
            <typeparam name="TTuple">The type of target tuple.</typeparam>
            <param name="this">The instance.</param>
            <returns>The array of elements.</returns>
        </member>
        <member name="M:System.Runtime.CompilerServices.TupleExtensions.GetEnumerator``1(``0)">
            <inheritdoc cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
        </member>
        <member name="T:System.StringExtensions">
            <summary>
            Provides extension methods on <see cref="T:System.String"/>.
            </summary>
            <seealso cref="T:System.String"/>
        </member>
        <member name="T:System.StringExtensions.">
            <summary>
            Provides extension members on <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="M:System.StringExtensions..RemoveAll(System.Char)">
            <summary>
            Removes all specified characters.
            </summary>
            <param name="character">The character to be removed from the base string.</param>
            <returns>The result string value after removal.</returns>
        </member>
        <member name="M:System.StringExtensions..ExpandCharacters">
            <summary>
            Gets a new <see cref="T:System.String"/>[] result, with each element (a <see cref="T:System.String"/> with a single character)
            from the specified <see cref="T:System.String"/>.
            </summary>
            <returns>An array of <see cref="T:System.String"/> elements.</returns>
        </member>
        <member name="M:System.StringExtensions..Chunk(System.Int32)">
            <summary>
            Cut the array to multiple part, making them are all of length <paramref name="length"/>.
            </summary>
            <param name="length">The desired length.</param>
            <returns>A list of <see cref="T:System.String"/> values.</returns>
        </member>
        <member name="T:System.Threading.Tasks.TimeSpanAwaitable">
            <summary>
            Provides with extension methods on <see cref="T:System.TimeSpan"/>.
            </summary>
            <seealso cref="T:System.TimeSpan"/>
        </member>
        <member name="M:System.Threading.Tasks.TimeSpanAwaitable.GetAwaiter(System.TimeSpan)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.TimeSpanAwaiter"/> instance used for <see langword="await"/> expressions.
            </summary>
            <param name="this">The time span.</param>
            <returns>A <see cref="T:System.Threading.Tasks.TimeSpanAwaiter"/> instance.</returns>
        </member>
        <member name="T:System.Threading.Tasks.TimeSpanAwaiter">
            <summary>
            Represents an awaiter for <see cref="T:System.TimeSpan"/> instance.
            </summary>
            <param name="_awaiter">The base awaiter instance.</param>
            <seealso cref="T:System.TimeSpan"/>
        </member>
        <member name="M:System.Threading.Tasks.TimeSpanAwaiter.#ctor(System.Runtime.CompilerServices.TaskAwaiter)">
            <summary>
            Represents an awaiter for <see cref="T:System.TimeSpan"/> instance.
            </summary>
            <param name="_awaiter">The base awaiter instance.</param>
            <seealso cref="T:System.TimeSpan"/>
        </member>
        <member name="P:System.Threading.Tasks.TimeSpanAwaiter.IsCompleted">
            <inheritdoc cref="P:System.Runtime.CompilerServices.TaskAwaiter.IsCompleted"/>
        </member>
        <member name="M:System.Threading.Tasks.TimeSpanAwaiter.GetResult">
            <inheritdoc cref="M:System.Runtime.CompilerServices.TaskAwaiter.GetResult"/>
        </member>
        <member name="M:System.Threading.Tasks.TimeSpanAwaiter.OnCompleted(System.Action)">
            <inheritdoc cref="M:System.Runtime.CompilerServices.TaskAwaiter.OnCompleted(System.Action)"/>
        </member>
        <member name="T:System.ValueTupleExtensions">
            <summary>
            Represents with extension methods for value tuple type set.
            </summary>
        </member>
        <member name="T:System.ValueTupleExtensions.`1">
            <summary>
            Provides extension members on <see langword="in"/> <see cref="T:System.ValueTuple`2"/> of <typeparamref name="T"/> values.
            </summary>
        </member>
        <member name="M:System.ValueTupleExtensions.`1.GetEnumerator">
            <summary>
            Gets an <see cref="T:System.Linq.Enumerators.ValueTupleEnumerator`1"/> instance that can iterate for a pair of values
            via a value tuple <see cref="T:System.ValueTuple`2"/> of a uniform type <typeparamref name="T"/>.
            </summary>
            <returns>An enumerator instance.</returns>
        </member>
        <member name="T:System.ValueTupleExtensions.`1">
            <summary>
            Provides extension members on <see langword="scoped in"/> <see cref="T:System.ValueTuple`2"/> of <typeparamref name="T"/> values.
            </summary>
        </member>
        <member name="M:System.ValueTupleExtensions.`1.AsSpan">
            <summary>
            Casts the current instance into a <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
            <returns>The <see cref="T:System.ReadOnlySpan`1"/> instance.</returns>
        </member>
        <member name="T:System.ValueTupleExtensions.`1">
            <summary>
            Provides extension members on <see langword="in"/> <see cref="T:System.ValueTuple`3"/> of <typeparamref name="T"/> values.
            </summary>
        </member>
        <member name="M:System.ValueTupleExtensions.`1.GetEnumerator">
            <summary>
            Gets an <see cref="T:System.Linq.Enumerators.ValueTupleEnumerator`1"/> instance that can iterate for a pair of values
            via a value tuple <see cref="T:System.ValueTuple`3"/> of a uniform type <typeparamref name="T"/>.
            </summary>
            <returns>An enumerator instance.</returns>
        </member>
        <member name="T:System.ValueTupleExtensions.`1">
            <summary>
            Provides extension members on <see langword="scoped in"/> <see cref="T:System.ValueTuple`3"/> of <typeparamref name="T"/> values.
            </summary>
        </member>
        <member name="M:System.ValueTupleExtensions.`1.AsSpan">
            <inheritdoc cref="M:System.ValueTupleExtensions.AsSpan``1(System.ValueTuple{``0,``0}@)"/>
        </member>
        <member name="T:System.ValueTupleExtensions.`1">
            <summary>
            Provides extension members on <see langword="in"/> <see cref="T:System.ValueTuple`4"/> of <typeparamref name="T"/> values.
            </summary>
        </member>
        <member name="M:System.ValueTupleExtensions.`1.GetEnumerator">
            <summary>
            Gets an <see cref="T:System.Linq.Enumerators.ValueTupleEnumerator`1"/> instance that can iterate for a pair of values
            via a value tuple <see cref="T:System.ValueTuple`4"/> of a uniform type <typeparamref name="T"/>.
            </summary>
            <returns>An enumerator instance.</returns>
        </member>
        <member name="T:System.ValueTupleExtensions.`1">
            <summary>
            Provides extension members on <see langword="scoped in"/> <see cref="T:System.ValueTuple`4"/> of <typeparamref name="T"/> values.
            </summary>
        </member>
        <member name="M:System.ValueTupleExtensions.`1.AsSpan">
            <inheritdoc cref="M:System.ValueTupleExtensions.AsSpan``1(System.ValueTuple{``0,``0}@)"/>
        </member>
        <member name="T:System.ValueTupleExtensions.`1">
            <summary>
            Provides extension members on <see langword="in"/> <see cref="T:System.ValueTuple`5"/> of <typeparamref name="T"/> values.
            </summary>
        </member>
        <member name="M:System.ValueTupleExtensions.`1.GetEnumerator">
            <summary>
            Gets an <see cref="T:System.Linq.Enumerators.ValueTupleEnumerator`1"/> instance that can iterate for a pair of values
            via a value tuple <see cref="T:System.ValueTuple`5"/> of a uniform type <typeparamref name="T"/>.
            </summary>
            <returns>An enumerator instance.</returns>
        </member>
        <member name="T:System.ValueTupleExtensions.`1">
            <summary>
            Provides extension members on <see langword="scoped in"/> <see cref="T:System.ValueTuple`5"/> of <typeparamref name="T"/> values.
            </summary>
        </member>
        <member name="M:System.ValueTupleExtensions.`1.AsSpan">
            <inheritdoc cref="M:System.ValueTupleExtensions.AsSpan``1(System.ValueTuple{``0,``0}@)"/>
        </member>
        <member name="T:System.ValueTupleExtensions.`1">
            <summary>
            Provides extension members on <see langword="in"/> <see cref="T:System.ValueTuple`6"/> of <typeparamref name="T"/> values.
            </summary>
        </member>
        <member name="M:System.ValueTupleExtensions.`1.GetEnumerator">
            <summary>
            Gets an <see cref="T:System.Linq.Enumerators.ValueTupleEnumerator`1"/> instance that can iterate for a pair of values
            via a value tuple <see cref="T:System.ValueTuple`6"/> of a uniform type <typeparamref name="T"/>.
            </summary>
            <returns>An enumerator instance.</returns>
        </member>
        <member name="T:System.ValueTupleExtensions.`1">
            <summary>
            Provides extension members on <see langword="scoped in"/> <see cref="T:System.ValueTuple`6"/> of <typeparamref name="T"/> values.
            </summary>
        </member>
        <member name="M:System.ValueTupleExtensions.`1.AsSpan">
            <inheritdoc cref="M:System.ValueTupleExtensions.AsSpan``1(System.ValueTuple{``0,``0}@)"/>
        </member>
        <member name="T:System.ValueTupleExtensions.`1">
            <summary>
            Provides extension members on <see langword="in"/> <see cref="T:System.ValueTuple`7"/> of <typeparamref name="T"/> values.
            </summary>
        </member>
        <member name="M:System.ValueTupleExtensions.`1.GetEnumerator">
            <summary>
            Gets an <see cref="T:System.Linq.Enumerators.ValueTupleEnumerator`1"/> instance that can iterate for a pair of values
            via a value tuple <see cref="T:System.ValueTuple`7"/> of a uniform type <typeparamref name="T"/>.
            </summary>
            <returns>An enumerator instance.</returns>
        </member>
        <member name="T:System.ValueTupleExtensions.`1">
            <summary>
            Provides extension members on <see langword="scoped in"/> <see cref="T:System.ValueTuple`7"/> of <typeparamref name="T"/> values.
            </summary>
        </member>
        <member name="M:System.ValueTupleExtensions.`1.AsSpan">
            <inheritdoc cref="M:System.ValueTupleExtensions.AsSpan``1(System.ValueTuple{``0,``0}@)"/>
        </member>
        <member name="T:System.ValueTupleExtensions.`2">
            <summary>
            Provides extension members on <see langword="in"/> <see cref="T:System.ValueTuple`8"/> of <typeparamref name="T"/> values.
            </summary>
        </member>
        <member name="M:System.ValueTupleExtensions.`2.GetEnumerator">
            <summary>
            Gets an <see cref="T:System.Linq.Enumerators.ValueTupleEnumerator`1"/> instance that can iterate for a pair of values
            via a value tuple <see cref="T:System.ValueTuple`8"/> of a uniform type <typeparamref name="T"/>.
            </summary>
            <returns>An enumerator instance.</returns>
        </member>
        <member name="T:System.ValueTupleExtensions.`2">
            <summary>
            Provides extension members on <see langword="scoped in"/> <see cref="T:System.ValueTuple`8"/> of <typeparamref name="T"/> values.
            </summary>
        </member>
        <member name="M:System.ValueTupleExtensions.`2.AsSpan">
            <summary>
            Casts the current instance into a <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
            <returns>The <see cref="T:System.ReadOnlySpan`1"/> instance.</returns>
        </member>
    </members>
</doc>
